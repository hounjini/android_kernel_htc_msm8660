From c7a057db5b63dc2c10fad999c3964d3b0c669a01 Mon Sep 17 00:00:00 2001
From: hounjini <hounjini@gmail.com>
Date: Thu, 27 Jun 2013 10:05:26 +0900
Subject: [PATCH] Initial Rider commit

---
 Makefile                                           |    2 +-
 arch/arm/configs/rider_cm10_defconfig              | 3061 +++++++++
 arch/arm/mach-msm/board-rider-audio-data.h         |  199 +
 arch/arm/mach-msm/board-rider-audio.c              |  470 ++
 arch/arm/mach-msm/board-rider-keypad.c             |  203 +
 arch/arm/mach-msm/board-rider-mmc.c                |  518 ++
 arch/arm/mach-msm/board-rider-mmc.h                |   15 +
 arch/arm/mach-msm/board-rider-rfkill.c             |  319 +
 arch/arm/mach-msm/board-rider-wifi.c               |  276 +
 arch/arm/mach-msm/board-rider-wifi.h               |   15 +
 arch/arm/mach-msm/board-rider.c                    | 6700 ++++++++++++++++++++
 arch/arm/mach-msm/board-rider.h                    |  234 +
 arch/arm/mach-msm/cp14.S                           |  669 ++
 arch/arm/mach-msm/cp14.h                           |   19 +
 arch/arm/mach-msm/etm.c                            |  978 +++
 arch/arm/mach-msm/include/mach/msm_serial_hs.h     |   21 +-
 drivers/media/video/msm/sensors/ov8830.c           | 2485 ++++++++
 drivers/media/video/msm/sensors/ov8830.h           |   89 +
 drivers/media/video/msm/sensors/ov8830_reg_vigor.c |  614 ++
 drivers/media/video/msm/sensors/s5k6aafx.h         |    2 +-
 .../media/video/msm/sensors/s5k6aafx_reg_rider.c   | 2760 ++++++++
 .../video/msm/sensors/s5k6aafx_reg_rider_cob.c     | 2765 ++++++++
 22 files changed, 22401 insertions(+), 13 deletions(-)
 create mode 100644 arch/arm/configs/rider_cm10_defconfig
 create mode 100644 arch/arm/mach-msm/board-rider-audio-data.h
 create mode 100644 arch/arm/mach-msm/board-rider-audio.c
 create mode 100644 arch/arm/mach-msm/board-rider-keypad.c
 create mode 100644 arch/arm/mach-msm/board-rider-mmc.c
 create mode 100644 arch/arm/mach-msm/board-rider-mmc.h
 create mode 100644 arch/arm/mach-msm/board-rider-rfkill.c
 create mode 100644 arch/arm/mach-msm/board-rider-wifi.c
 create mode 100644 arch/arm/mach-msm/board-rider-wifi.h
 create mode 100644 arch/arm/mach-msm/board-rider.c
 create mode 100644 arch/arm/mach-msm/board-rider.h
 create mode 100644 arch/arm/mach-msm/cp14.S
 create mode 100644 arch/arm/mach-msm/cp14.h
 create mode 100644 arch/arm/mach-msm/etm.c
 create mode 100644 drivers/media/video/msm/sensors/ov8830.c
 create mode 100644 drivers/media/video/msm/sensors/ov8830.h
 create mode 100644 drivers/media/video/msm/sensors/ov8830_reg_vigor.c
 create mode 100644 drivers/media/video/msm/sensors/s5k6aafx_reg_rider.c
 create mode 100644 drivers/media/video/msm/sensors/s5k6aafx_reg_rider_cob.c

diff --git a/Makefile b/Makefile
index fc3574c..66cc9d3 100644
--- a/Makefile
+++ b/Makefile
@@ -195,7 +195,7 @@ SUBARCH := arm
 SUBARCH := arm
 export KBUILD_BUILDHOST := $(SUBARCH)
 ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?= arm-eabi-
+CROSS_COMPILE	?= arm-linux-gnueabihf-
 CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
diff --git a/arch/arm/configs/rider_cm10_defconfig b/arch/arm/configs/rider_cm10_defconfig
new file mode 100644
index 0000000..4e16df6
--- /dev/null
+++ b/arch/arm/configs/rider_cm10_defconfig
@@ -0,0 +1,3061 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.41 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_ARM_TICKET_LOCKS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION="-hounjini_v2"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CC_OPTIMIZE_DEFAULT is not set
+CONFIG_CC_OPTIMIZE_ALOT=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLQB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_CGROUP_BFQIO=y
+CONFIG_IOSCHED_VR=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+# CONFIG_DEFAULT_SIO is not set
+CONFIG_DEFAULT_BFQ=y
+# CONFIG_DEFAULT_VR is not set
+CONFIG_DEFAULT_IOSCHED="bfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+CONFIG_ARCH_MSM=y
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+
+#
+# MSM SoC Type
+#
+# CONFIG_ARCH_MSM7X01A is not set
+# CONFIG_ARCH_MSM7X25 is not set
+# CONFIG_ARCH_MSM7X27 is not set
+# CONFIG_ARCH_MSM7X30 is not set
+# CONFIG_ARCH_QSD8X50 is not set
+CONFIG_ARCH_MSM8X60=y
+# CONFIG_ARCH_MSM8X60_LTE is not set
+# CONFIG_ARCH_MSM8960 is not set
+# CONFIG_ARCH_APQ8064 is not set
+# CONFIG_ARCH_MSMCOPPER is not set
+# CONFIG_ARCH_FSM9XXX is not set
+# CONFIG_ARCH_MSM9615 is not set
+CONFIG_MSM_SOC_REV_NONE=y
+# CONFIG_MSM_SOC_REV_A is not set
+CONFIG_ARCH_MSM_SCORPION=y
+CONFIG_MSM_SMP=y
+CONFIG_ARCH_MSM_SCORPIONMP=y
+CONFIG_MSM_RPM=y
+CONFIG_MSM_MPM=y
+CONFIG_MSM_XO=y
+CONFIG_MSM_REMOTE_SPINLOCK_LDREX=y
+CONFIG_MSM_ADM3=y
+# CONFIG_PERFLOCK is not set
+
+#
+# MSM Board Selection
+#
+# CONFIG_ARCH_MSM7X30_SMD is not set
+# CONFIG_MACH_MSM8X60_RUMI3 is not set
+# CONFIG_MACH_MSM8X60_SIM is not set
+# CONFIG_MACH_MSM8X60_SURF is not set
+# CONFIG_MACH_MSM8X60_FFA is not set
+# CONFIG_MACH_MSM8X60_FLUID is not set
+# CONFIG_MACH_MSM8X60_FUSION is not set
+# CONFIG_MACH_MSM8X60_FUSN_FFA is not set
+# CONFIG_MACH_MSM8X60_DRAGON is not set
+# CONFIG_MACH_PYRAMID is not set
+# CONFIG_MACH_SHOOTER is not set
+# CONFIG_MACH_SHOOTER_U is not set
+# CONFIG_MACH_SHOOTER_K is not set
+# CONFIG_MACH_SHOOTER_CT is not set
+CONFIG_MACH_RIDER=y
+# CONFIG_MACH_VERDI_LTE is not set
+# CONFIG_MACH_HOLIDAY is not set
+# CONFIG_MACH_VIGOR is not set
+# CONFIG_MACH_RUBY is not set
+# CONFIG_MSM_USE_TSIF1 is not set
+CONFIG_MSM_MDP40=y
+CONFIG_MSM_STACKED_MEMORY=y
+CONFIG_PHYS_OFFSET=0x48000000
+CONFIG_KERNEL_PMEM_EBI_REGION=y
+CONFIG_KERNEL_PMEM_SMI_REGION=y
+CONFIG_MSM_AMSS_VERSION=6225
+# CONFIG_MSM_AMSS_VERSION_6210 is not set
+# CONFIG_MSM_AMSS_VERSION_6220 is not set
+CONFIG_MSM_AMSS_VERSION_6225=y
+# CONFIG_MSM_AMSS_VERSION_6350 is not set
+# CONFIG_MSM_AMSS_VERSION_6355 is not set
+# CONFIG_MSM_AMSS_VERSION_1355 is not set
+# CONFIG_MSM_AMSS_VERSION_4725 is not set
+# CONFIG_MSM_AMSS_VERSION_4735 is not set
+# CONFIG_MSM_AMSS_VERSION_4410 is not set
+# CONFIG_MSM_AMSS_VERSION_3200 is not set
+# CONFIG_MSM_AMSS_VERSION_1170 is not set
+# CONFIG_MSM_AMSS_VERSION_1200 is not set
+CONFIG_MSM_DEBUG_UART_NONE=y
+# CONFIG_MSM_DEBUG_UART1 is not set
+# CONFIG_MSM_DEBUG_UART2 is not set
+# CONFIG_MSM_DEBUG_UART3 is not set
+# CONFIG_MSM_DEBUG_UART8 is not set
+# CONFIG_MSM_DEBUG_UART11 is not set
+CONFIG_HTC_BATT_CORE=y
+CONFIG_HTC_BATT8x60=y
+# CONFIG_HTC_BATT_8960 is not set
+CONFIG_MSM7X00A_USE_GP_TIMER=y
+# CONFIG_MSM7X00A_USE_DG_TIMER is not set
+# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
+CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE=y
+# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
+# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
+# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
+CONFIG_MSM7X00A_SLEEP_MODE=1
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
+CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE=4
+CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
+CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
+CONFIG_MSM_IDLE_STATS=y
+CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
+CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
+CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
+CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
+CONFIG_CPU_HAS_L2_PMU=y
+# CONFIG_HTC_HEADSET is not set
+# CONFIG_HTC_BATTCHG is not set
+# CONFIG_HTC_BATTCHG_MAX8957 is not set
+# CONFIG_HTC_PWRSINK is not set
+# CONFIG_BUILD_OMA_DM is not set
+# CONFIG_MSM_FIQ_SUPPORT is not set
+# CONFIG_MSM_SERIAL_DEBUGGER is not set
+# CONFIG_MSM_PROC_COMM is not set
+CONFIG_MSM_SMD=y
+# CONFIG_MSM_SMD_PKG3 is not set
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_SMD0_WQ=y
+CONFIG_MSM_SMD_DEBUG=y
+CONFIG_MSM_N_WAY_SMD=y
+CONFIG_MSM_N_WAY_SMSM=y
+# CONFIG_MSM_RESET_MODEM is not set
+CONFIG_MSM_SMD_LOGGING=y
+# CONFIG_MSM_SMD_NMEA is not set
+CONFIG_MSM_SMD_TTY=y
+# CONFIG_MSM_SMD_QMI is not set
+CONFIG_MSM_SMD_PKT=y
+CONFIG_MSM_DSPS=y
+CONFIG_MSM_ONCRPCROUTER=y
+# CONFIG_MSM_IPC_ROUTER is not set
+CONFIG_MSM_ONCRPCROUTER_DEBUG=y
+# CONFIG_MSM_RPC_LOOPBACK_XPRT is not set
+# CONFIG_MSM_RPCSERVER_TIME_REMOTE is not set
+# CONFIG_MSM_RPCSERVER_WATCHDOG is not set
+# CONFIG_MSM_RPC_WATCHDOG is not set
+CONFIG_MSM_RPC_PING=y
+CONFIG_MSM_RPC_OEM_RAPI=y
+# CONFIG_MSM_RPCSERVER_HANDSET is not set
+CONFIG_MSM_RMT_STORAGE_CLIENT=y
+# CONFIG_MSM_RMT_STORAGE_CLIENT_STATS is not set
+CONFIG_MSM_DALRPC=y
+# CONFIG_MSM_DALRPC_TEST is not set
+CONFIG_CPU_VOLTAGE_TABLE=y
+CONFIG_MSM_MPDEC=y
+CONFIG_MSM_MPDEC_ENABLED=y
+# CONFIG_MSM_MPDEC_DISABLED is not set
+CONFIG_MSM_CPU_FREQ_SET_MIN_MAX=y
+CONFIG_MSM_CPU_FREQ_MAX=1566000
+CONFIG_MSM_CPU_FREQ_MIN=192000
+# CONFIG_MSM_AVS_HW is not set
+# CONFIG_MSM_HW3D is not set
+CONFIG_AMSS_7X25_VERSION_2009=y
+# CONFIG_AMSS_7X25_VERSION_2008 is not set
+CONFIG_MSM8X60_AUDIO=y
+# CONFIG_MSM8X60_FTM_AUDIO_DEVICES is not set
+# CONFIG_HTC_OFFMODE_ALARM is not set
+# CONFIG_HTC_QUICKBOOT_OFFMODE_ALARM is not set
+CONFIG_RTAC=y
+# CONFIG_MSM_VREG_SWITCH_INVERTED is not set
+CONFIG_MSM_DMA_TEST=n
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_WIFI_MEM_PREALLOC=y
+CONFIG_WIFI_NVS_PROC_CREATE=y
+CONFIG_ARCH_MSM_FLASHLIGHT=y
+CONFIG_SURF_FFA_GPIO_KEYPAD=y
+CONFIG_MSM_SLEEP_TIME_OVERRIDE=y
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE is not set
+CONFIG_MSM_PM_TIMEOUT_HALT=y
+# CONFIG_MSM_PM_TIMEOUT_RESET_MODEM is not set
+# CONFIG_MSM_PM_TIMEOUT_RESET_CHIP is not set
+CONFIG_MSM_IDLE_WAIT_ON_MODEM=0
+CONFIG_HTC_HEADSET_MGR=y
+# CONFIG_HTC_HEADSET_H2W is not set
+CONFIG_HTC_HEADSET_GPIO=y
+CONFIG_HTC_HEADSET_PMIC=y
+# CONFIG_HTC_HEADSET_MAX8957 is not set
+# CONFIG_HTC_HEADSET_MISC is not set
+CONFIG_HTC_HEADSET_8X60=y
+CONFIG_HTC_ONMODE_CHARGING=y
+CONFIG_SMD_OFFSET_TCXO_STAT=0x0
+CONFIG_SMD_OFFSET_NEGATE_CLIENT_STAT=0x0
+CONFIG_MSM_PIL=y
+CONFIG_MSM_SCM=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_BUSPM_DEV=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_MSM_RPM_STATS_LOG=y
+# CONFIG_MSM_IOMMU is not set
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_MSM_GPIOMUX=y
+CONFIG_MSM_V2_TLMM=y
+CONFIG_MSM_SECURE_IO=y
+CONFIG_MSM_NATIVE_RESTART=y
+CONFIG_MSM_BUS_SCALING=y
+# CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED is not set
+CONFIG_MSM_WATCHDOG=y
+CONFIG_MSM_DLOAD_MODE=y
+# CONFIG_HAS_QDSS is not set
+# CONFIG_MSM_DEBUG_ACROSS_PC is not set
+# CONFIG_MSM_JTAG_V7 is not set
+CONFIG_MSM_TRACE_ACROSS_PC=y
+CONFIG_MSM_ETM=y
+CONFIG_MSM_SLEEP_STATS=y
+# CONFIG_MSM_STANDALONE_POWER_COLLAPSE is not set
+# CONFIG_MSM_GSBI9_UART is not set
+CONFIG_MSM_SHOW_RESUME_IRQ=y
+# CONFIG_BT_MSM_PINTEST is not set
+CONFIG_SUPPORT_DQ_BATTERY=y
+# CONFIG_MSM_FAKE_BATTERY is not set
+CONFIG_MSM_QDSP6_APR=y
+# CONFIG_MSM_AUDIO_QDSP6 is not set
+# CONFIG_MSM_RPC_VIBRATOR is not set
+# CONFIG_RPC_VER_60001 is not set
+CONFIG_MSM_SPM_V1=y
+# CONFIG_MSM_SPM_V2 is not set
+CONFIG_FOOTPRINT_IRQ=y
+
+#
+# TI WLAN driver
+#
+# CONFIG_TIWLAN_SDIO is not set
+CONFIG_HTC_BATT_ALARM=y
+# CONFIG_REMOVE_EBI1_FIXED_CLK is not set
+CONFIG_FORCE_FAST_CHARGE=y
+# CONFIG_HTC_ACCESSORY_ONEWIRE is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_CACHE_ERR_REPORT is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+# CONFIG_VCM is not set
+CONFIG_STRICT_MEMORY_RWX=y
+# CONFIG_RESERVE_FIRST_PAGE is not set
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_KSAPI is not set
+CONFIG_ARM_GIC=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_ARM_ARCH_TIMER is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_VMALLOC_RESERVE=0x2E000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG is not set
+# CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_ALLOW_CPU_ALIGNMENT=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+CONFIG_CP_ACCESS=y
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS2 is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_LAZY is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_LAGFREE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_WHEATLEY is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_LIONHEART is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SAVAGEDZEN is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCARY is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_BADASS is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SMARTASS2=y
+CONFIG_CPU_FREQ_GOV_LAZY=y
+CONFIG_CPU_FREQ_GOV_LAGFREE=y
+CONFIG_LAGFREE_MAX_LOAD=80
+CONFIG_LAGFREE_MIN_LOAD=20
+CONFIG_LAGFREE_FREQ_STEP_DOWN=108000
+CONFIG_LAGFREE_FREQ_SLEEP_MAX=384000
+CONFIG_LAGFREE_FREQ_AWAKE_MIN=384000
+CONFIG_LAGFREE_FREQ_STEP_UP_SLEEP_PERCENT=20
+CONFIG_CPU_FREQ_MIN_TICKS=10
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=2000
+CONFIG_CPU_FREQ_GOV_INTELLIDEMAND=y
+CONFIG_CPU_FREQ_GOV_WHEATLEY=y
+CONFIG_CPU_FREQ_GOV_LIONHEART=y
+CONFIG_CPU_FREQ_GOV_SAVAGEDZEN=y
+CONFIG_CPU_FREQ_GOV_SCARY=y
+CONFIG_CPU_FREQ_GOV_BADASS=y
+CONFIG_CPU_FREQ_GOV_BADASS_2_PHASE=y
+CONFIG_CPU_FREQ_GOV_BADASS_2_PHASE_FREQ=918000
+CONFIG_CPU_FREQ_GOV_BADASS_3_PHASE=y
+CONFIG_CPU_FREQ_GOV_BADASS_3_PHASE_FREQ=1188000
+CONFIG_CPU_FREQ_GOV_BADASS_GPU_CONTROL=y
+# CONFIG_CPU_FREQ_GOV_BADASS_LOWBAT_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_BADASS_ALLOW_BYPASS is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_FREQ_MSM=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_CPU_PM=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_SUSPEND is not set
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_RUNTIME_CLK=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_LARGE_TCP_INITIAL_BUFFER=y
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_RENO=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_VEGAS=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_TCP_CONG_LP=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_TCP_CONG_ILLINOIS=y
+CONFIG_DEFAULT_TCP_CONG="westwood"
+
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_HL=y
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_REJECT_SKERR is not set
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_AH=y
+CONFIG_IP6_NF_MATCH_EUI64=y
+CONFIG_IP6_NF_MATCH_FRAG=y
+CONFIG_IP6_NF_MATCH_OPTS=y
+CONFIG_IP6_NF_MATCH_HL=y
+CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+CONFIG_IP6_NF_MATCH_MH=y
+CONFIG_IP6_NF_MATCH_RT=y
+CONFIG_IP6_NF_TARGET_HL=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_TARGET_REJECT_SKERR is not set
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+# CONFIG_RFS_ACCEL is not set
+# CONFIG_XPS is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_SERIAL_BCM_BT_LPM=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCISMD is not set
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIBTSDIO=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIUART_IBS is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_MSM_SLEEP is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_MSM_BT_POWER=y
+# CONFIG_BT_ATH3K is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_WIMAX=y
+CONFIG_WIMAX_DEBUG_LEVEL=8
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_GENLOCK=y
+CONFIG_GENLOCK_MISCDEVICE=y
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+# CONFIG_TSIF is not set
+# CONFIG_HAPTIC_ISA1200 is not set
+CONFIG_PMIC8058_PWM=y
+# CONFIG_PMIC8058_VIBRATOR is not set
+CONFIG_PMIC8XXX_VIBRATOR=y
+# CONFIG_PMIC8XXX_NFC is not set
+CONFIG_PMIC8XXX_UPL=y
+CONFIG_PMIC8058_XOADC=y
+# CONFIG_PMIC8058_MISC is not set
+# CONFIG_PMIC8058_BATTALARM is not set
+CONFIG_TZCOM=y
+# CONFIG_QFP_FUSE is not set
+CONFIG_CABLE_DETECT_8X60=y
+# CONFIG_CABLE_DETECT_8X55 is not set
+CONFIG_CABLE_DETECT_ACCESSORY=y
+CONFIG_CABLE_DETECT_ACCESSORY_BY_ADC=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_MPU_SENSORS_MPU3050=y
+# CONFIG_MPU_SENSORS_ACCELEROMETER_NONE is not set
+# CONFIG_MPU_SENSORS_ADXL346 is not set
+# CONFIG_MPU_SENSORS_BMA150 is not set
+CONFIG_MPU_SENSORS_BMA250=y
+# CONFIG_MPU_SENSORS_BMA222 is not set
+# CONFIG_MPU_SENSORS_KXSD9 is not set
+# CONFIG_MPU_SENSORS_KXTF9 is not set
+# CONFIG_MPU_SENSORS_LIS331DLH is not set
+# CONFIG_MPU_SENSORS_LIS3DH is not set
+# CONFIG_MPU_SENSORS_LSM303DLHA is not set
+# CONFIG_MPU_SENSORS_MMA8450 is not set
+# CONFIG_MPU_SENSORS_MMA845X is not set
+# CONFIG_MPU_SENSORS_COMPASS_NONE is not set
+CONFIG_MPU_SENSORS_AK8975=y
+# CONFIG_MPU_SENSORS_MMC314X is not set
+# CONFIG_MPU_SENSORS_AMI30X is not set
+# CONFIG_MPU_SENSORS_HMC5883 is not set
+# CONFIG_MPU_SENSORS_LSM303DLHM is not set
+# CONFIG_MPU_SENSORS_YAS529 is not set
+# CONFIG_MPU_SENSORS_HSCDTD002B is not set
+# CONFIG_MPU_SENSORS_HSCDTD004A is not set
+CONFIG_MPU_SENSORS_TIMERIRQ=y
+# CONFIG_MPU_SENSORS_DEBUG is not set
+
+#
+# Motorola TS 27.010 Mux driver over UART
+#
+# CONFIG_MOT_FEAT_TS27010MUX_UART is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_LIBRA_SDIOIF is not set
+# CONFIG_BCM4329=
+CONFIG_BCM4329_248=m
+CONFIG_BCM4329_FW_PATH="/system/etc/firmware/fw_bcm4329.bin"
+CONFIG_BCM4329_NVRAM_PATH="/proc/calibration"
+#CONFIG_BCMDHD=m
+#CONFIG_BCMDHD_FW_PATH="/vendor/firmware/fw_bcmdhd.bin"
+#CONFIG_BCMDHD_NVRAM_PATH="/proc/calibration"
+# CONFIG_DHD_ENABLE_P2P=y
+# CONFIG_DHD_USE_STATIC_BUF=y
+# CONFIG_DHD_USE_SCHED_SCAN=y
+# CONFIG_HOSTAP is not set
+# CONFIG_WL12XX_PLATFORM_DATA is not set
+# CONFIG_QUALCOMM_WLAN is not set
+# CONFIG_BCM4330B2 is not set
+
+#
+# WiMAX Wireless Broadband devices
+#
+# CONFIG_WIMAX_I2400M_USB is not set
+# CONFIG_WIMAX_I2400M_SDIO is not set
+CONFIG_WIMAX_SQN=m
+CONFIG_WIMAX_SDIO_HIGH_SPEED=y
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_MSM_RMNET=y
+# CONFIG_MSM_RMNET_DEBUG is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_HTC_NETWORK_MODIFY=y
+# CONFIG_KINETO_GAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_KEYBOARD_PMIC8058 is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ATMEL_DETECT_CABLE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_DETECT_USB is not set
+# CONFIG_TOUCHSCREEN_ATMEL_DETECT_USB_VBUS is not set
+# CONFIG_TOUCHSCREEN_ATMEL_WLS is not set
+CONFIG_TOUCHSCREEN_ATMEL=y
+CONFIG_TOUCHSCREEN_ATMEL_SWEEP2WAKE=y
+# CONFIG_TOUCHSCREEN_ATMEL_SWEEP2WAKE_DISABLED is not set
+CONFIG_TOUCHSCREEN_ATMEL_SWEEP2WAKE_ENABLED=y
+# CONFIG_TOUCHSCREEN_ATMEL_SWEEP2WAKE_ENABLED_WITH_BACKLIGHT is not set
+# CONFIG_TOUCHSCREEN_NTRIG is not set
+# CONFIG_TOUCHSCREEN_ATMEL_224E is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MAXTOUCH is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_TMA is not set
+# CONFIG_TOUCHSCREEN_COMPATIBLE_REPORT is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CS is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_ELAN_KTF2K is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_3K is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_MSM_LEGACY is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_CY8C_TS is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_I2C is not set
+# CONFIG_TOUCHSCREEN_HIMAX is not set
+# CONFIG_TOUCHSCREEN_HIMAX_SH is not set
+# CONFIG_TOUCHSCREEN_HIMAX_SH2 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_INPUT_ISA1200_FF_MEMLESS is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PMIC8XXX_PWRKEY is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_PMIC8058_PWRKEY is not set
+CONFIG_PMIC8058_OTHC=y
+# CONFIG_INPUT_PMIC8058_VIBRA_MEMLESS is not set
+# CONFIG_BOSCH_BMA150 is not set
+# CONFIG_INPUT_DUMMY_KEYPAD is not set
+# CONFIG_POWER_KEY_LED is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_IMC_UART2DM_HANDSHAKE is not set
+# CONFIG_SERIAL_MSM is not set
+CONFIG_SERIAL_MSM_HS=y
+# CONFIG_SERIAL_MSM_HS_IMC is not set
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+# CONFIG_SERIAL_BCM_BT_LPM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_MSM_SMD is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+
+#
+# Diag Support
+#
+CONFIG_DIAG_CHAR=y
+
+#
+# DIAG traffic over USB
+#
+CONFIG_DIAG_OVER_USB=y
+
+#
+# SDIO support for DIAG
+#
+
+#
+# HSIC support for DIAG
+#
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_MSM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_MSM_ROTATOR_LEGACY is not set
+CONFIG_MSM_ROTATOR=y
+CONFIG_MSM_ROTATOR_USE_IMEM=n
+# CONFIG_MMC_GENERIC_CSDIO is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_ONLY_BMA250 is not set
+# CONFIG_SENSORS_I2C_AK_BMA250 is not set
+# CONFIG_SENSORS_AKM8975 is not set
+# CONFIG_SENSORS_AKM8975_PANA_GYRO is not set
+# CONFIG_SENSORS_PANASONIC_GYRO is not set
+CONFIG_TPS65200=y
+# CONFIG_SENSORS_BMA250 is not set
+# CONFIG_SENSORS_NFC_PN544 is not set
+# CONFIG_INPUT_CAPELLA_CM3628 is not set
+# CONFIG_INPUT_CAPELLA_CM3629 is not set
+# CONFIG_VP_A1026 is not set
+# CONFIG_VP_A1028 is not set
+CONFIG_AMP_TPA2051D3=y
+CONFIG_INPUT_ISL29028=y
+CONFIG_INPUT_ISL29029=y
+# CONFIG_AMP_TPA2051D3_ON_GPIO is not set
+# CONFIG_CODEC_AIC3254 is not set
+# CONFIG_CODEC_AIC3008 is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_MSM is not set
+CONFIG_I2C_QUP=y
+CONFIG_I2C_SSBI=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_AIC3254=y
+# CONFIG_SPI_SP8803COM is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+CONFIG_SPI_QUP=y
+CONFIG_SPI_TOUCHSCREEN_NTRIG=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SLIMBUS is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_MPP_PMIC8901=y
+CONFIG_GPIO_PM8XXX=y
+CONFIG_GPIO_PM8XXX_MPP=y
+# CONFIG_GPIO_PM8XXX_RPC is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_DS2746 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_BATTERY_MSM is not set
+# CONFIG_BATTERY_MSM8X60 is not set
+# CONFIG_SMB137B_CHARGER is not set
+# CONFIG_PM8058_FIX_USB is not set
+# CONFIG_BATTERY_BQ27520 is not set
+# CONFIG_BATTERY_BQ27541 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_WPCE775X is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+CONFIG_SENSORS_MSM_ADC=y
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_THERMAL_PM8901=y
+# CONFIG_THERMAL_PM8058 is not set
+# CONFIG_THERMAL_MSM_POPMEM is not set
+# CONFIG_THERMAL_TSENS is not set
+CONFIG_THERMAL_TSENS8x60=y
+CONFIG_THERMAL_MONITOR=y
+# CONFIG_THERMAL_PM8XXX is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+CONFIG_PMIC8058=y
+CONFIG_PMIC8901=y
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+CONFIG_MARIMBA_CORE=y
+# CONFIG_MARIMBA_CODEC is not set
+CONFIG_TIMPANI_CODEC=y
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+CONFIG_MFD_PM8XXX=y
+# CONFIG_MFD_PM8921_CORE is not set
+# CONFIG_MFD_PM8821_CORE is not set
+# CONFIG_MFD_PM8018_CORE is not set
+CONFIG_MFD_PM8XXX_IRQ=y
+# CONFIG_MFD_TPS65910 is not set
+CONFIG_MFD_PM8XXX_DEBUG=y
+# CONFIG_MFD_PM8XXX_PWM is not set
+CONFIG_MFD_PM8XXX_MISC=y
+CONFIG_MFD_PM8XXX_BATT_ALARM=y
+# CONFIG_WCD9310_CODEC is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_REGULATOR_PMIC8058=y
+CONFIG_REGULATOR_PMIC8901=y
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_PM8058_XO is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_RC_CORE is not set
+
+#
+# Qualcomm MSM Camera And Video
+#
+CONFIG_MSM_CAMERA=y
+# CONFIG_MSM_CAMERA_DEBUG is not set
+# CONFIG_MSM_CAMERA_V4L2 is not set
+# CONFIG_MSM_CAMERA_LEGACY is not set
+# CONFIG_MSM_CAMERA_7X30 is not set
+CONFIG_MSM_CAMERA_8X60=y
+CONFIG_CAMERA_ZSL=y
+# CONFIG_CAMERA_3D is not set
+# CONFIG_FLASH_BACKLIGHT_OFF is not set
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_MT9D113 is not set
+# CONFIG_IMX074 is not set
+# CONFIG_WEBCAM_OV7692 is not set
+# CONFIG_WEBCAM_OV9726 is not set
+# CONFIG_VX6953 is not set
+# CONFIG_MT9E013 is not set
+# CONFIG_QS_S5K4E1 is not set
+# CONFIG_S5K4E1 is not set
+# CONFIG_S5K4E5YX is not set
+# CONFIG_S5K3H1GX is not set
+# CONFIG_MSM_CAMERA_FLASH_SC628A is not set
+# CONFIG_IMX072 is not set
+# CONFIG_QS_MT9P017 is not set
+CONFIG_MSM_CAMERA_FLASH=y
+# CONFIG_MSM_CAMERA_SENSOR is not set
+# CONFIG_MSM_ACTUATOR is not set
+CONFIG_MSM_GEMINI=y
+CONFIG_MSM_VPE=y
+# CONFIG_RAWCHIP is not set
+CONFIG_QUP_EXCLUSIVE_TO_CAMERA=y
+CONFIG_S5K3H2YX=y
+# CONFIG_S5K3H2YX_ACT is not set
+# CONFIG_S5K4E5YX_ACT is not set
+# CONFIG_MT9V113 is not set
+# CONFIG_S5K6A1GX is not set
+CONFIG_S5K6AAFX=y
+CONFIG_OV8830=y
+# CONFIG_MT9D015 is not set
+# CONFIG_SP3D is not set
+
+#
+# Graphics support
+#
+CONFIG_MSM_VIDC=y
+CONFIG_MSM_VIDC_1080P=y
+CONFIG_MSM_VIDC_VENC=y
+CONFIG_MSM_VIDC_VDEC=y
+# CONFIG_DRM is not set
+# CONFIG_ION is not set
+CONFIG_MSM_KGSL_ADRENO220=y
+CONFIG_MSM_KGSL=y
+# CONFIG_MSM_KGSL_CFF_DUMP is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_CP_STAT_NO_DETAIL is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_NO_IB_DUMP is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_RB_HEX is not set
+CONFIG_MSM_KGSL_2D=y
+CONFIG_KGSL_PER_PROCESS_PAGE_TABLE=y
+CONFIG_MSM_KGSL_PAGE_TABLE_SIZE=0xFFF0000
+CONFIG_MSM_KGSL_PAGE_TABLE_COUNT=32
+CONFIG_MSM_KGSL_MMU_PAGE_FAULT=y
+# CONFIG_MSM_KGSL_DISABLE_SHADOW_WRITES is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+
+#
+# Miscellaneous I2C Chip support II
+#
+CONFIG_FB_MSM_HDMI_MHL=y
+CONFIG_FB_MSM_HDMI_MHL_SII9234=y
+CONFIG_INTERNAL_CHARGING_SUPPORT=y
+CONFIG_FB_MSM=y
+CONFIG_FB_MSM_TRIPLE_BUFFER=y
+CONFIG_FB_MSM_LCDC_HW=y
+# CONFIG_FB_MSM_LCDC is not set
+# CONFIG_FB_MSM_LCDC_PANEL is not set
+# CONFIG_FB_MSM_TVOUT is not set
+CONFIG_FB_MSM_OVERLAY=y
+CONFIG_FB_MSM_DTV=y
+# CONFIG_FB_MSM_MDP_ABL is not set
+# CONFIG_FB_MSM_8X60_DEFAULT_DEPTH_RGB565 is not set
+# CONFIG_FB_MSM_8X60_DEFAULT_DEPTH_ARGB8888 is not set
+CONFIG_FB_MSM_8X60_DEFAULT_DEPTH_RGBA8888=y
+# CONFIG_FB_MSM_SELF_REFRESH is not set
+CONFIG_FB_MSM_HDMI_MSM_PANEL=y
+# CONFIG_FB_MSM_HDMI_MSM_PANEL_DVI_SUPPORT is not set
+CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT=y
+CONFIG_FB_MSM_EXT_INTERFACE_COMMON=y
+CONFIG_FB_MSM_HDMI_COMMON=y
+CONFIG_FB_MSM_HDMI_3D=y
+# CONFIG_MSM_DSI_CLK_AUTO_CALCULATE is not set
+CONFIG_FB_MSM_MIPI_DSI=y
+CONFIG_FB_MSM_MIPI_DSI_TOSHIBA=y
+CONFIG_FB_MSM_MIPI_DSI_RENESAS=y
+CONFIG_FB_MSM_MIPI_DSI_NOVATEK=y
+CONFIG_FB_MSM_MIPI_DSI_HIMAX=y
+CONFIG_FB_MSM_MIPI_DSI_ORISE=y
+# CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA is not set
+# CONFIG_FB_MSM_LCDC_AUO_WVGA is not set
+CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT=y
+# CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_WVGA_PT is not set
+CONFIG_FB_MSM_MIPI_RENESAS_CMD_WVGA_PT=y
+CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT=y
+CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT=y
+CONFIG_FB_MSM_MIPI_ORISE_CMD_QHD_PT=y
+CONFIG_FB_MSM_MIPI_HIMAX_VIDEO_720P_PT=y
+# CONFIG_FB_MSM_MIPI_HIMAX_CMD_720P_PT is not set
+CONFIG_FB_MSM_OVERLAY_WRITEBACK=y
+CONFIG_FB_MSM_MIPI_PANEL_DETECT=y
+# CONFIG_LCDC_TURN_ON_BL_AFTER_PANEL_ON is not set
+# CONFIG_FB_MSM_BACKLIGHT is not set
+# CONFIG_FB_MSM_LOGO is not set
+# CONFIG_FB_MSM_MDP22 is not set
+# CONFIG_FB_MSM_MDP30 is not set
+# CONFIG_FB_MSM_MDP31 is not set
+CONFIG_FB_MSM_MDP40=y
+# CONFIG_FB_MSM_EBI2 is not set
+# CONFIG_FB_MSM_MDDI is not set
+# CONFIG_FB_MSM_EXTMDDI is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON_VGA is not set
+# CONFIG_FB_MSM_MDDI_ORISE is not set
+# CONFIG_FB_MSM_MDDI_QUICKVX is not set
+# CONFIG_FB_MSM_MDDI_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_AUTO_DETECT is not set
+CONFIG_FB_MSM_MIPI_DSI_SIMULATOR=y
+CONFIG_FB_MSM_MIPI_DSI_TC358764_DSI2LVDS=y
+# CONFIG_FB_MSM_LCDC_ST15_WXGA is not set
+# CONFIG_FB_MSM_LCDC_ST15_PANEL is not set
+# CONFIG_FB_MSM_LCDC_PRISM_WVGA is not set
+# CONFIG_FB_MSM_LCDC_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_LCDC_GORDON_VGA is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT is not set
+# CONFIG_FB_MSM_LCDC_NT35582_WVGA is not set
+# CONFIG_FB_MSM_LCDC_WXGA is not set
+CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT=y
+CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT=y
+CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT=y
+CONFIG_FB_MSM_MIPI_CHIMEI_WXGA=y
+CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO=y
+CONFIG_FB_MSM_OVERLAY0_WRITEBACK=y
+# CONFIG_FB_MSM_WRITEBACK_MSM_PANEL is not set
+# CONFIG_FB_MSM_LCDC_PRISM_WVGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_CHIMEI_WXGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_GORDON_VGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_AUO_WVGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_NT35582_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT_PANEL is not set
+# CONFIG_FB_MSM_TRY_MDDI_CATCH_LCDC_PRISM is not set
+# CONFIG_FB_MSM_MDDI_PANEL_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_PANEL_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_MIPI_PANEL_AUTO_DETECT is not set
+# CONFIG_FB_MSM_MDDI_PRISM_WVGA is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_WVGA_PORTRAIT is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_VGA is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_WVGA is not set
+# CONFIG_FB_MSM_MDDI_SHARP_QVGA_128x128 is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WXGA_PANEL is not set
+# CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO_PANEL is not set
+# CONFIG_FB_MSM_EBI2_TMD_QVGA_EPSON_QCIF is not set
+# CONFIG_FB_MSM_HDMI_AS_PRIMARY is not set
+# CONFIG_FB_MSM_PANEL_NONE is not set
+# CONFIG_FB_MSM_HDMI_ADV7520_PANEL is not set
+# CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_M is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_J is not set
+# CONFIG_FB_MSM_TVOUT_PAL_BDGHIN is not set
+# CONFIG_FB_MSM_TVOUT_PAL_M is not set
+# CONFIG_FB_MSM_TVOUT_PAL_N is not set
+CONFIG_FB_MSM_TVOUT_NONE=y
+# CONFIG_FB_MSM_DEFAULT_DEPTH_RGB565 is not set
+# CONFIG_FB_MSM_DEFAULT_DEPTH_ARGB8888 is not set
+CONFIG_FB_MSM_DEFAULT_DEPTH_RGBA8888=y
+# CONFIG_FB_MSM_OVERLAY_LEGACY is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+
+#
+# MSM SoC Audio support
+#
+CONFIG_SND_SOC_MSM8X60_PCM=y
+CONFIG_SND_SOC_MSM8X60_DAI=y
+CONFIG_SND_SOC_MSM8X60=y
+# CONFIG_MSM_8x60_VOIP is not set
+CONFIG_SND_SOC_MSM_QDSP6_INTF=y
+# CONFIG_SND_SOC_VOICE is not set
+# CONFIG_SND_SOC_QDSP6 is not set
+# CONFIG_SND_SOC_MSM8660_APQ is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+# CONFIG_HID_ELECOM is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+# CONFIG_HID_MAGICMOUSE is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_LEDS=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_ROCCAT_COMMON=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+# CONFIG_HID_WACOM is not set
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_OTG_HOST=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_WHITELIST=y
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_MSM=y
+# CONFIG_USB_EHCI_MSM_HSIC is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_PEHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_QCOM_DIAG_BRIDGE is not set
+# CONFIG_USB_QCOM_MDM_BRIDGE is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+CONFIG_USB_GADGET_CI13XXX_MSM=y
+CONFIG_USB_CI13XXX_MSM=y
+# CONFIG_USB_GADGET_MSM_72K is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_CSW_HACK is not set
+# CONFIG_USB_MSC_PROFILING is not set
+CONFIG_MODEM_SUPPORT=y
+CONFIG_RMNET_SMD_CTL_CHANNEL=""
+CONFIG_RMNET_SMD_DATA_CHANNEL=""
+# CONFIG_USB_ANDROID_RMNET_CTRL_SMD is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_MSM_OTG_72K is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_MSM_OTG=y
+CONFIG_USB_MSM_ACA=y
+CONFIG_USB_MSM_STANDARD_ACA=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=64
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_TI_SDIO_ADAPT is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MSM=y
+CONFIG_MMC_MSM_SDIO_SUPPORT=y
+CONFIG_MMC_MSM_CARD_HW_DETECTION=y
+CONFIG_MMC_MSM_SDC1_SUPPORT=y
+CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT=y
+CONFIG_MMC_MSM_SDC2_SUPPORT=y
+CONFIG_MMC_MSM_SDC2_8_BIT_SUPPORT=y
+CONFIG_MMC_MSM_SDC3_SUPPORT=y
+CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT=y
+# CONFIG_MMC_MSM_SDC3_WP_SUPPORT is not set
+CONFIG_MMC_MSM_SDC4_SUPPORT=y
+# CONFIG_MMC_MSM_SDC4_8_BIT_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC5_SUPPORT is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_ATHEROS_SDIO is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_MSM_PDM is not set
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_CPLD is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PM8XXX is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_MSM_PMIC is not set
+# CONFIG_LEDS_PMIC8058 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TRIGGERS is not set
+# CONFIG_LEDS_PM8029 is not set
+CONFIG_LEDS_PM8058=y
+
+#
+# LED Triggers
+#
+# CONFIG_FLASHLIGHT_TPS61310 is not set
+# CONFIG_FLASHLIGHT_AAT1271 is not set
+CONFIG_FLASHLIGHT_AAT1277=y
+# CONFIG_NFC_DEVICES is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_ANDROID_RTC_CHANGE_WAIT is not set
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_MSM is not set
+# CONFIG_RTC_DRV_MSM7X00A is not set
+# CONFIG_RTC_PM8058 is not set
+CONFIG_RTC_DRV_PM8XXX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_MDM9K_ERROR_CORRECTION is not set
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_RADIO_LOG_SIZE=256
+CONFIG_ANDROID_DEVICE_LOG_SIZE=256
+CONFIG_ANDROID_SYSTEM_LOG_SIZE=256
+CONFIG_ANDROID_EVENTS_LOG_SIZE=256
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+CONFIG_SNAPPY_COMPRESS=y
+CONFIG_SNAPPY_DECOMPRESS=y
+CONFIG_XVMALLOC=y
+CONFIG_ZRAM=y
+# CONFIG_ZRAM_DEBUG is not set
+# CONFIG_FB_SM7XX is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Qualcomm MSM specific device drivers
+#
+CONFIG_MSM_SSBI=y
+# CONFIG_SPS is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# File systems
+#
+CONFIG_VFS_CACHE_PRESSURE=100
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_EXT4_E2FSCK_RECOVER=y
+# CONFIG_EXT4_WORKAROUND is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_DEBUG=y
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=6
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_FDLEAK is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_CPU_STALL_VERBOSE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_WANT_PAGE_DEBUG_FLAGS=y
+CONFIG_PAGE_POISONING=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_QCRYPTO is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_QCEDEV is not set
+# CONFIG_CRYPTO_DEV_OTA_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
+
+CONFIG_BUILD_OMA_DM=y
+CONFIG_GPU_OVERCLOCK=y
diff --git a/arch/arm/mach-msm/board-rider-audio-data.h b/arch/arm/mach-msm/board-rider-audio-data.h
new file mode 100644
index 0000000..752c8dc
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-audio-data.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2010 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/spi/spi_aic3254.h>
+
+static CODEC_SPI_CMD LOOPBACK_DSP_INIT[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x01, 0x00},
+	{'w', 0x02, 0x21},
+	{'w', 0x7B, 0x01},
+	{'w', 0x00, 0x00},
+	{'w', 0x06, 0x18},
+	{'w', 0x05, 0x51},
+	{'w', 0x04, 0x03},
+	{'w', 0x05, 0xD1},
+	{'w', 0x0B, 0x83},
+	{'w', 0x0C, 0x85},
+	{'w', 0x12, 0x83},
+	{'w', 0x13, 0x85},
+	{'w', 0x00, 0x01},
+	{'w', 0x0A, 0x3B},
+	{'w', 0x0C, 0x08},
+	{'w', 0x0D, 0x08},
+	{'w', 0x0E, 0x08},
+	{'w', 0x0F, 0x08},
+	{'w', 0x10, 0x00},
+	{'w', 0x11, 0x00},
+	{'w', 0x12, 0x00},
+	{'w', 0x13, 0x00},
+	{'w', 0x00, 0x00},
+	{'w', 0x40, 0x00},
+	{'w', 0x52, 0x00},
+	{'w', 0x1B, 0x0C},
+	{'w', 0x1E, 0x94},
+	{'w', 0x44, 0x00},
+	{'w', 0x35, 0x02},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_DSP_INIT_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_DSP_INIT,
+	.len  = ARRAY_SIZE(LOOPBACK_DSP_INIT),
+};
+
+static CODEC_SPI_CMD LOOPBACK_Receiver_IMIC[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x34, 0x20},
+	{'w', 0x36, 0x20},
+	{'w', 0x37, 0x02},
+	{'w', 0x39, 0x80},
+	{'w', 0x3B, 0x3C},
+	{'w', 0x3C, 0x3C},
+	{'w', 0x09, 0x33},
+	{'w', 0x0C, 0x0A},
+	{'w', 0x0D, 0x12},
+	{'w', 0x0E, 0x00},
+	{'w', 0x0F, 0x00},
+	{'w', 0x10, 0x06},
+	{'w', 0x11, 0x06},
+	{'w', 0x12, 0x00},
+	{'w', 0x13, 0x00},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_Receiver_IMIC_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_Receiver_IMIC,
+	.len  = ARRAY_SIZE(LOOPBACK_Receiver_IMIC),
+};
+
+static CODEC_SPI_CMD LOOPBACK_Speaker_IMIC[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x34, 0x20},
+	{'w', 0x36, 0x20},
+	{'w', 0x37, 0x02},
+	{'w', 0x39, 0x80},
+	{'w', 0x3B, 0x3C},
+	{'w', 0x3C, 0x3C},
+	{'w', 0x09, 0x33},
+	{'w', 0x0C, 0x0A},
+	{'w', 0x0D, 0x12},
+	{'w', 0x0E, 0x00},
+	{'w', 0x0F, 0x00},
+	{'w', 0x10, 0x06},
+	{'w', 0x11, 0x06},
+	{'w', 0x12, 0x00},
+	{'w', 0x13, 0x00},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_Speaker_IMIC_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_Speaker_IMIC,
+	.len  = ARRAY_SIZE(LOOPBACK_Speaker_IMIC),
+};
+
+static CODEC_SPI_CMD LOOPBACK_Headset_EMIC[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x34, 0x02},
+	{'w', 0x36, 0x80},
+	{'w', 0x37, 0x00},
+	{'w', 0x39, 0x00},
+	{'w', 0x3B, 0x3C},
+	{'w', 0x3C, 0x3C},
+	{'w', 0x09, 0x33},
+	{'w', 0x0C, 0x0A},
+	{'w', 0x0D, 0x12},
+	{'w', 0x0E, 0x00},
+	{'w', 0x0F, 0x00},
+	{'w', 0x10, 0x06},
+	{'w', 0x11, 0x06},
+	{'w', 0x12, 0x00},
+	{'w', 0x13, 0x00},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_Headset_EMIC_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_Headset_EMIC,
+	.len  = ARRAY_SIZE(LOOPBACK_Headset_EMIC),
+};
+
+static CODEC_SPI_CMD LOOPBACK_Receiver_BMIC[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x34, 0x02},
+	{'w', 0x36, 0x80},
+	{'w', 0x37, 0x00},
+	{'w', 0x39, 0x00},
+	{'w', 0x3B, 0x3C},
+	{'w', 0x3C, 0x3C},
+	{'w', 0x09, 0x33},
+	{'w', 0x0C, 0x0A},
+	{'w', 0x0D, 0x12},
+	{'w', 0x0E, 0x00},
+	{'w', 0x0F, 0x00},
+	{'w', 0x10, 0x06},
+	{'w', 0x11, 0x06},
+	{'w', 0x12, 0x00},
+	{'w', 0x13, 0x00},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_Receiver_BMIC_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_Receiver_BMIC,
+	.len  = ARRAY_SIZE(LOOPBACK_Receiver_BMIC),
+};
+
+static CODEC_SPI_CMD LOOPBACK_Speaker_BMIC[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x34, 0x02},
+	{'w', 0x36, 0x80},
+	{'w', 0x37, 0x80},
+	{'w', 0x39, 0x20},
+	{'w', 0x3B, 0x3C},
+	{'w', 0x3C, 0x3C},
+	{'w', 0x09, 0x0F},
+	{'w', 0x0C, 0x00},
+	{'w', 0x0D, 0x00},
+	{'w', 0x0E, 0x0A},
+	{'w', 0x0F, 0x0A},
+	{'w', 0x10, 0x00},
+	{'w', 0x11, 0x00},
+	{'w', 0x12, 0x3C},
+	{'w', 0x13, 0x3C},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_Speaker_BMIC_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_Speaker_BMIC,
+	.len  = ARRAY_SIZE(LOOPBACK_Speaker_BMIC),
+};
+
+static CODEC_SPI_CMD LOOPBACK_Headset_BMIC[] = {
+	{'w', 0x00, 0x01},
+	{'w', 0x34, 0x02},
+	{'w', 0x36, 0x80},
+	{'w', 0x37, 0x80},
+	{'w', 0x39, 0x20},
+	{'w', 0x3B, 0x3C},
+	{'w', 0x3C, 0x3C},
+	{'w', 0x09, 0x0F},
+	{'w', 0x0C, 0x00},
+	{'w', 0x0D, 0x00},
+	{'w', 0x0E, 0x0A},
+	{'w', 0x0F, 0x0A},
+	{'w', 0x10, 0x00},
+	{'w', 0x11, 0x00},
+	{'w', 0x12, 0x3C},
+	{'w', 0x13, 0x3C},
+};
+
+static CODEC_SPI_CMD_PARAM LOOPBACK_Headset_BMIC_PARAM = {
+	.data = (CODEC_SPI_CMD *) &LOOPBACK_Headset_BMIC,
+	.len  = ARRAY_SIZE(LOOPBACK_Headset_BMIC),
+};
+
+
diff --git a/arch/arm/mach-msm/board-rider-audio.c b/arch/arm/mach-msm/board-rider-audio.c
new file mode 100644
index 0000000..0da089d
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-audio.c
@@ -0,0 +1,470 @@
+/* linux/arch/arm/mach-msm/board-rider-audio.c
+ *
+ * Copyright (C) 2010-2011 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/android_pmem.h>
+#include <linux/mfd/pmic8058.h>
+#include <linux/mfd/marimba.h>
+#include <linux/delay.h>
+#include <linux/pmic8058-othc.h>
+#include <linux/spi/spi_aic3254.h>
+
+#include <mach/gpio.h>
+#include <mach/dal.h>
+#include <mach/tpa2051d3.h>
+#include <mach/qdsp6v3/snddev_icodec.h>
+#include <mach/qdsp6v3/snddev_ecodec.h>
+#include <mach/qdsp6v3/snddev_hdmi.h>
+#include <mach/qdsp6v3/audio_dev_ctl.h>
+#include <mach/htc_acoustic_8x60.h>
+
+#include "board-rider.h"
+#include "board-rider-audio-data.h"
+#include <mach/qdsp6v3/audio_dev_ctl.h>
+
+static struct mutex bt_sco_lock;
+static struct mutex mic_lock;
+static int curr_rx_mode;
+static atomic_t aic3254_ctl = ATOMIC_INIT(0);
+
+#define BIT_SPEAKER	(1 << 0)
+#define BIT_HEADSET	(1 << 1)
+#define BIT_RECEIVER	(1 << 2)
+#define BIT_FM_SPK	(1 << 3)
+#define BIT_FM_HS	(1 << 4)
+#define RIDER_AUD_CODEC_RST        (67)
+#define RIDER_AUD_HP_EN          PMGPIO(18)
+#define RIDER_AUD_MIC_SEL        PMGPIO(14)
+#define PM8058_GPIO_BASE			NR_MSM_GPIOS
+#define PM8058_GPIO_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8058_GPIO_BASE)
+#define PMGPIO(x) (x-1)
+void rider_snddev_bmic_pamp_on(int en);
+
+
+static uint32_t msm_snddev_gpio[] = {
+	GPIO_CFG(108, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(109, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(110, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+};
+
+
+static uint32_t msm_aic3254_reset_gpio[] = {
+	GPIO_CFG(RIDER_AUD_CODEC_RST, 0,
+		GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+};
+
+void rider_snddev_poweramp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+	if (en) {
+		msleep(50);
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_SPK_ENO), 1);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode |= BIT_SPEAKER;
+	} else {
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_SPK_ENO), 0);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode &= ~BIT_SPEAKER;
+	}
+}
+
+void rider_snddev_hsed_pamp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+	if (en) {
+		msleep(50);
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN),
+						"AUD_HP_EN");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 1);
+		set_headset_amp(1);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode |= BIT_HEADSET;
+	} else {
+		set_headset_amp(0);
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN),
+						"AUD_HP_EN");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 0);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode &= ~BIT_HEADSET;
+	}
+}
+
+void rider_snddev_hs_spk_pamp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+	rider_snddev_poweramp_on(en);
+	if (en) {
+		/* enable rx route */
+		msleep(30);
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN),
+						"AUD_HP_EN");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 1);
+		set_speaker_headset_amp(1);
+
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode |= BIT_HEADSET;
+		msleep(5);
+	} else {
+		/* disable rx route */
+		set_speaker_headset_amp(0);
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN),
+						"AUD_HP_EN");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 0);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode &= ~BIT_HEADSET;
+	}
+}
+
+void rider_snddev_receiver_pamp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+	if (en) {
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN),
+						"AUD_HP_EN");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 1);
+		set_handset_amp(1);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode |= BIT_RECEIVER;
+	} else {
+		set_handset_amp(0);
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN),
+						"AUD_HP_EN");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 0);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode &= ~BIT_RECEIVER;
+	}
+}
+
+void rider_snddev_bt_sco_pamp_on(int en)
+{
+	/* to be implemented */
+}
+
+/* power on/off externnal mic bias */
+void rider_mic_enable(int en, int shift)
+{
+	pr_aud_info("%s: %d, shift %d\n", __func__, en, shift);
+
+	mutex_lock(&mic_lock);
+
+	if (en)
+		pm8058_micbias_enable(OTHC_MICBIAS_2, OTHC_SIGNAL_ALWAYS_ON);
+	else
+		pm8058_micbias_enable(OTHC_MICBIAS_2, OTHC_SIGNAL_OFF);
+
+	mutex_unlock(&mic_lock);
+}
+
+void rider_snddev_imic_pamp_on(int en)
+{
+	int ret;
+
+	pr_aud_info("%s %d\n", __func__, en);
+	rider_snddev_bmic_pamp_on(en);
+	if (en) {
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_0, OTHC_SIGNAL_ALWAYS_ON);
+		if (ret)
+			pr_aud_err("%s: Enabling int mic power failed\n", __func__);
+
+	} else {
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_0, OTHC_SIGNAL_OFF);
+		if (ret)
+			pr_aud_err("%s: Enabling int mic power failed\n", __func__);
+	}
+}
+
+void rider_snddev_bmic_pamp_on(int en)
+{
+	int ret;
+
+	pr_aud_info("%s %d\n", __func__, en);
+
+	if (en) {
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_1, OTHC_SIGNAL_ALWAYS_ON);
+		if (ret)
+			pr_aud_err("%s: Enabling back mic power failed\n", __func__);
+
+		/* select internal mic path */
+		gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_MIC_SEL),
+						"AUD_MIC_SEL");
+		gpio_direction_output(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_MIC_SEL), 0);
+	} else {
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_1, OTHC_SIGNAL_OFF);
+		if (ret)
+			pr_aud_err("%s: Enabling back mic power failed\n", __func__);
+	}
+}
+
+void rider_snddev_emic_pamp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+
+	if (en) {
+		/* select external mic path */
+
+		// Modify for Rider_ICS_35_S #84 - start
+		if ((curr_rx_mode & BIT_HEADSET) || (curr_rx_mode & BIT_FM_HS)) {
+			// turn on MIC_SEL will introduce a pop sound which occurs in ITS #84, (pop @ pick up phone call)
+			// turn off headset amp first and then turn on it after turned on MIC_SEL
+			set_headset_amp(0);
+			gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 0);
+
+			gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_MIC_SEL), 1); // turn on MIC_SEL
+
+			msleep(50);
+			gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 1);
+			set_headset_amp(1);
+		}
+		// Modify for Rider_ICS_35_S #84 - end
+	}
+}
+
+void rider_snddev_stereo_mic_pamp_on(int en)
+{
+	int ret;
+
+	pr_aud_info("%s %d\n", __func__, en);
+
+	if (en) {
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_0, OTHC_SIGNAL_ALWAYS_ON);
+		if (ret)
+			pr_aud_err("%s: Enabling int mic power failed\n", __func__);
+
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_1, OTHC_SIGNAL_ALWAYS_ON);
+		if (ret)
+			pr_aud_err("%s: Enabling back mic power failed\n", __func__);
+
+		/* select external mic path */
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_MIC_SEL), 0);
+	} else {
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_0, OTHC_SIGNAL_OFF);
+		if (ret)
+			pr_aud_err("%s: Disabling int mic power failed\n", __func__);
+
+
+		ret = pm8058_micbias_enable(OTHC_MICBIAS_1, OTHC_SIGNAL_OFF);
+		if (ret)
+			pr_aud_err("%s: Disabling back mic power failed\n", __func__);
+	}
+}
+
+void rider_snddev_fmspk_pamp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+	if (en) {
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_SPK_ENO), 1);
+		set_speaker_amp(1);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode |= BIT_FM_SPK;
+	} else {
+		set_speaker_amp(0);
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_SPK_ENO), 0);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode &= ~BIT_FM_SPK;
+	}
+}
+
+void rider_snddev_fmhs_pamp_on(int en)
+{
+	pr_aud_info("%s %d\n", __func__, en);
+	if (en) {
+		// Modify for Rider_ICS_35_S #84 - start (pop @ end of phone call)
+		msleep(50);
+		// Modify for Rider_ICS_35_S #84 - end
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 1);
+		set_headset_amp(1);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode |= BIT_FM_HS;
+	} else {
+		set_headset_amp(0);
+		gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HP_EN), 0);
+		if (!atomic_read(&aic3254_ctl))
+			curr_rx_mode &= ~BIT_FM_HS;
+	}
+}
+
+void rider_voltage_on(int en)
+{
+}
+
+int rider_get_rx_vol(uint8_t hw, int network, int level)
+{
+	int vol = 0;
+
+	/* to be implemented */
+
+	pr_aud_info("%s(%d, %d, %d) => %d\n", __func__, hw, network, level, vol);
+
+	return vol;
+}
+
+void rider_rx_amp_enable(int en)
+{
+	if (curr_rx_mode != 0) {
+		atomic_set(&aic3254_ctl, 1);
+		pr_aud_info("%s: curr_rx_mode 0x%x, en %d\n",
+			__func__, curr_rx_mode, en);
+		if (curr_rx_mode & BIT_SPEAKER)
+			rider_snddev_poweramp_on(en);
+		if (curr_rx_mode & BIT_HEADSET)
+			rider_snddev_hsed_pamp_on(en);
+		if (curr_rx_mode & BIT_RECEIVER)
+			rider_snddev_receiver_pamp_on(en);
+		if (curr_rx_mode & BIT_FM_SPK)
+			rider_snddev_fmspk_pamp_on(en);
+		if (curr_rx_mode & BIT_FM_HS)
+			rider_snddev_fmhs_pamp_on(en);
+		atomic_set(&aic3254_ctl, 0);;
+	}
+}
+
+int rider_support_aic3254(void)
+{
+	return 1;
+}
+
+int rider_support_back_mic(void)
+{
+	return 1;
+}
+
+int rider_is_msm_i2s_slave(void)
+{
+	/* 1 - CPU slave, 0 - CPU master */
+	return 1;
+}
+
+void rider_spibus_enable(int en)
+{
+	uint32_t msm_spi_gpio_on[] = {
+		GPIO_CFG(RIDER_SPI_DO,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_SPI_DI,  1, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_SPI_CS,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_SPI_CLK, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	};
+
+	uint32_t msm_spi_gpio_off[] = {
+		GPIO_CFG(RIDER_SPI_DO,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_SPI_DI,  0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_SPI_CS,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_SPI_CLK, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	};
+	pr_aud_info("%s %d\n", __func__, en);
+	if (en) {
+		gpio_tlmm_config(msm_spi_gpio_on[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(msm_spi_gpio_on[1], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(msm_spi_gpio_on[2], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(msm_spi_gpio_on[3], GPIO_CFG_ENABLE);
+	} else {
+		gpio_tlmm_config(msm_spi_gpio_off[0], GPIO_CFG_DISABLE);
+		gpio_tlmm_config(msm_spi_gpio_off[1], GPIO_CFG_DISABLE);
+		gpio_tlmm_config(msm_spi_gpio_off[2], GPIO_CFG_DISABLE);
+		gpio_tlmm_config(msm_spi_gpio_off[3], GPIO_CFG_DISABLE);
+	}
+	mdelay(1);
+}
+
+void rider_reset_3254(void)
+{
+	gpio_tlmm_config(msm_aic3254_reset_gpio[0], GPIO_CFG_ENABLE);
+	gpio_set_value(RIDER_AUD_CODEC_RST, 0);
+	mdelay(1);
+	gpio_set_value(RIDER_AUD_CODEC_RST, 1);
+}
+
+void rider_get_acoustic_tables(struct acoustic_tables *tb)
+{
+	strcpy(tb->aic3254,	"IOTable.txt\0");
+}
+
+static struct q6v2audio_analog_ops ops = {
+	.speaker_enable	        = rider_snddev_poweramp_on,
+	.headset_enable	        = rider_snddev_hsed_pamp_on,
+	.handset_enable	        = rider_snddev_receiver_pamp_on,
+	.headset_speaker_enable	= rider_snddev_hs_spk_pamp_on,
+	.bt_sco_enable	        = rider_snddev_bt_sco_pamp_on,
+	.int_mic_enable         = rider_snddev_imic_pamp_on,
+	.back_mic_enable        = rider_snddev_bmic_pamp_on,
+	.ext_mic_enable         = rider_snddev_emic_pamp_on,
+	.stereo_mic_enable      = rider_snddev_stereo_mic_pamp_on,
+	.fm_headset_enable      = rider_snddev_fmhs_pamp_on,
+	.fm_speaker_enable      = rider_snddev_fmspk_pamp_on,
+	.voltage_on		= rider_voltage_on,
+};
+
+static struct q6v2audio_icodec_ops iops = {
+	.support_aic3254 = rider_support_aic3254,
+	.is_msm_i2s_slave = rider_is_msm_i2s_slave,
+};
+
+static struct q6v2audio_ecodec_ops eops = {
+	.bt_sco_enable  = rider_snddev_bt_sco_pamp_on,
+};
+
+static struct aic3254_ctl_ops cops = {
+	.rx_amp_enable        = rider_rx_amp_enable,
+	.reset_3254           = rider_reset_3254,
+	.spibus_enable        = rider_spibus_enable,
+	.lb_dsp_init          = &LOOPBACK_DSP_INIT_PARAM,
+	.lb_receiver_imic     = &LOOPBACK_Receiver_IMIC_PARAM,
+	.lb_speaker_imic      = &LOOPBACK_Speaker_IMIC_PARAM,
+	.lb_headset_emic      = &LOOPBACK_Headset_EMIC_PARAM,
+	.lb_receiver_bmic     = &LOOPBACK_Receiver_BMIC_PARAM,
+	.lb_speaker_bmic      = &LOOPBACK_Speaker_BMIC_PARAM,
+	.lb_headset_bmic      = &LOOPBACK_Headset_BMIC_PARAM,
+};
+
+static struct acoustic_ops acoustic = {
+	.enable_mic_bias = rider_mic_enable,
+	.support_aic3254 = rider_support_aic3254,
+	.support_back_mic = rider_support_back_mic,
+	.get_acoustic_tables = rider_get_acoustic_tables
+};
+
+void rider_aic3254_set_mode(int config, int mode)
+{
+	aic3254_set_mode(config, mode);
+}
+
+static struct q6v2audio_aic3254_ops aops = {
+       .aic3254_set_mode = rider_aic3254_set_mode,
+};
+
+void __init rider_audio_init(void)
+{
+	mutex_init(&bt_sco_lock);
+	mutex_init(&mic_lock);
+
+#ifdef CONFIG_MSM8X60_AUDIO
+	pr_aud_info("%s\n", __func__);
+	htc_8x60_register_analog_ops(&ops);
+	htc_8x60_register_icodec_ops(&iops);
+	htc_8x60_register_ecodec_ops(&eops);
+	acoustic_register_ops(&acoustic);
+	htc_8x60_register_aic3254_ops(&aops);
+	msm_set_voc_freq(8000, 8000);
+#endif
+
+	aic3254_register_ctl_ops(&cops);
+
+	/* PMIC GPIO Init (See board-rider.c) */
+/* Reset AIC3254 */
+	rider_reset_3254();
+	gpio_tlmm_config(
+		GPIO_CFG(RIDER_AUD_CDC_LDO_SEL, 0, GPIO_CFG_OUTPUT,
+			GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA), GPIO_CFG_DISABLE);
+	gpio_tlmm_config(msm_snddev_gpio[0], GPIO_CFG_DISABLE);
+	gpio_tlmm_config(msm_snddev_gpio[1], GPIO_CFG_DISABLE);
+	gpio_tlmm_config(msm_snddev_gpio[2], GPIO_CFG_DISABLE);
+}
diff --git a/arch/arm/mach-msm/board-rider-keypad.c b/arch/arm/mach-msm/board-rider-keypad.c
new file mode 100644
index 0000000..fb08edf
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-keypad.c
@@ -0,0 +1,203 @@
+/* arch/arm/mach-msm/board-rider-keypad.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/gpio_event.h>
+#include <linux/keyreset.h>
+#include <asm/mach-types.h>
+#include <linux/gpio.h>
+#include <mach/gpio.h>
+
+#include "board-rider.h"
+
+#include <linux/mfd/pmic8058.h>
+#include <linux/input/pmic8058-keypad.h>
+
+/* Macros assume PMIC GPIOs start at 0 */
+#define PM8058_GPIO_BASE			NR_MSM_GPIOS
+#define PM8058_GPIO_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8058_GPIO_BASE)
+#define PM8058_GPIO_SYS_TO_PM(sys_gpio)		(sys_gpio - PM8058_GPIO_BASE)
+#define PM8058_MPP_BASE			(PM8058_GPIO_BASE + PM8058_GPIOS)
+#define PM8058_MPP_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8058_MPP_BASE)
+#define PM8058_MPP_SYS_TO_PM(sys_gpio)		(sys_gpio - PM8058_MPP_BASE)
+#define PM8058_IRQ_BASE				(NR_MSM_IRQS + NR_GPIO_IRQS)
+
+#define PM8901_GPIO_BASE			(PM8058_GPIO_BASE + \
+						PM8058_GPIOS + PM8058_MPPS)
+#define PM8901_GPIO_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8901_GPIO_BASE)
+#define PM8901_GPIO_SYS_TO_PM(sys_gpio)		(sys_gpio - PM901_GPIO_BASE)
+#define PM8901_IRQ_BASE				(PM8058_IRQ_BASE + \
+						NR_PMIC8058_IRQS)
+static char *keycaps = "--qwerty";
+#undef MODULE_PARAM_PREFIX
+#define MODULE_PARAM_PREFIX "board_rider."
+module_param_named(keycaps, keycaps, charp, 0);
+
+static void config_gpio_table(uint32_t *table, int len)
+{
+	int n, rc;
+	for (n = 0; n < len; n++) {
+		rc = gpio_tlmm_config(table[n], GPIO_CFG_ENABLE);
+		if (rc) {
+			pr_err("[keypad]%s: gpio_tlmm_config(%#x)=%d\n",
+				__func__, table[n], rc);
+			break;
+		}
+	}
+}
+
+static struct gpio_event_direct_entry rider_keypad_input_map[] = {
+	{
+		.gpio = RIDER_GPIO_KEY_POWER,
+		.code = KEY_POWER,
+	},
+	{
+		.gpio = RIDER_VOL_UP,
+		.code = KEY_VOLUMEUP,
+	},
+	{
+		.gpio = RIDER_VOL_DN,
+		.code = KEY_VOLUMEDOWN,
+	 },
+	{
+		.gpio = RIDER_GPIO_KEY_CAM_STEP1,
+		.code = KEY_HP,
+	},
+	{
+		.gpio = RIDER_GPIO_KEY_CAM_STEP2,
+		.code = KEY_CAMERA,
+	},
+};
+
+static void rider_setup_input_gpio(void)
+{
+	uint32_t inputs_gpio_table[] = {
+		GPIO_CFG(RIDER_GPIO_KEY_POWER, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_GPIO_KEY_VOL_UP, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_GPIO_KEY_VOL_DOWN, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_GPIO_KEY_CAM_STEP1, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_GPIO_KEY_CAM_STEP2, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+	};
+
+	config_gpio_table(inputs_gpio_table, ARRAY_SIZE(inputs_gpio_table));
+}
+
+static struct gpio_event_input_info rider_keypad_input_info = {
+	.info.func = gpio_event_input_func,
+	.flags = GPIOEDF_PRINT_KEYS,
+	.type = EV_KEY,
+#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
+	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
+# else
+	.debounce_time.tv64 = 5 * NSEC_PER_MSEC,
+# endif
+	.keymap = rider_keypad_input_map,
+	.keymap_size = ARRAY_SIZE(rider_keypad_input_map),
+	.setup_input_gpio = rider_setup_input_gpio,
+};
+
+static struct gpio_event_direct_entry rider_gpio_switch[] = {
+	{
+		.gpio = RIDER_GPIO_CAPTURE_MODE_KEY,
+		.code = SW_CAM,
+		.not_wakeup_src = true,
+	},
+};
+
+static void rider_setup_switch_gpio(void)
+{
+	uint32_t inputs_gpio_table[] = {
+		GPIO_CFG(RIDER_GPIO_CAPTURE_MODE_KEY, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_GPIO_VIDEO_MODE_KEY, 0, GPIO_CFG_INPUT,
+			GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+	};
+
+	config_gpio_table(inputs_gpio_table, ARRAY_SIZE(inputs_gpio_table));
+}
+
+static struct gpio_event_switch_info rider_keypad_switch_info = {
+	.info.func = gpio_event_switch_func,
+	.info.no_suspend = true,
+	.flags = GPIOEDF_PRINT_KEYS,
+	.type = EV_SW,
+#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
+	.debounce_time.tv.nsec = 5 * NSEC_PER_MSEC,
+# else
+	.debounce_time.tv64 = 5 * NSEC_PER_MSEC,
+# endif
+	.keymap = rider_gpio_switch,
+	.keymap_size = ARRAY_SIZE(rider_gpio_switch),
+	.setup_switch_gpio = rider_setup_switch_gpio,
+};
+
+static struct gpio_event_info *rider_keypad_info[] = {
+	&rider_keypad_input_info.info,
+	&rider_keypad_switch_info.info,
+};
+
+static struct gpio_event_platform_data rider_keypad_data = {
+	.names = {
+		"rider-keypad",
+		NULL,
+	},
+	.info = rider_keypad_info,
+	.info_count = ARRAY_SIZE(rider_keypad_info),
+};
+
+static struct platform_device rider_keypad_input_device = {
+	.name = GPIO_EVENT_DEV_NAME,
+	.id = 0,
+	.dev		= {
+		.platform_data	= &rider_keypad_data,
+	},
+};
+/*
+static int rider_reset_keys_up[] = {
+	KEY_VOLUMEUP,
+	0
+};
+*/
+static struct keyreset_platform_data rider_reset_keys_pdata = {
+	/*.keys_up = rider_reset_keys_up,*/
+	.keys_down = {
+		KEY_POWER,
+		KEY_VOLUMEDOWN,
+		KEY_VOLUMEUP,
+		0
+	},
+};
+
+struct platform_device rider_reset_keys_device = {
+	.name = KEYRESET_NAME,
+	.dev.platform_data = &rider_reset_keys_pdata,
+};
+
+int __init rider_init_keypad(void)
+{
+	printk(KERN_DEBUG "%s\n", __func__);
+
+	if (platform_device_register(&rider_reset_keys_device))
+		printk(KERN_WARNING "%s: register reset key fail\n", __func__);
+
+	return platform_device_register(&rider_keypad_input_device);
+}
diff --git a/arch/arm/mach-msm/board-rider-mmc.c b/arch/arm/mach-msm/board-rider-mmc.c
new file mode 100644
index 0000000..f5edf0e
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-mmc.c
@@ -0,0 +1,518 @@
+/* linux/arch/arm/mach-msm/board-rider-mmc.c
+ *
+ * Copyright (C) 2008 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/gpio.h>
+
+#include <asm/gpio.h>
+#include <asm/io.h>
+
+#include <mach/vreg.h>
+#include <mach/htc_pwrsink.h>
+
+#include <asm/mach/mmc.h>
+#include <mach/msm_iomap.h>
+#include <linux/mfd/pmic8058.h>
+#include <mach/htc_sleep_clk.h>
+
+#include "devices.h"
+#include "board-rider.h"
+#include "proc_comm.h"
+#include "board-common-wimax.h"
+#include "board-rider-mmc.h"
+#include "mpm.h"
+
+#ifdef CONFIG_WIMAX_SERIAL_MSM
+#include <mach/msm_serial_wimax.h>
+#include <linux/irq.h>
+
+#define MSM_GSBI3_PHYS		0x16200000
+#define MSM_UART3_PHYS 		(MSM_GSBI3_PHYS + 0x40000)
+#define INT_UART3_IRQ		GSBI3_UARTDM_IRQ
+#endif
+
+#include "mpm.h"
+#include <linux/irq.h>
+#include "board-rider-mmc.h"
+
+#include <mach/rpm.h>
+#include <mach/rpm-regulator.h>
+
+#include "mpm.h"
+#include "rpm_resources.h"
+
+int msm_proc_comm(unsigned cmd, unsigned *data1, unsigned *data2);
+
+/* ---- PM QOS ---- */
+static struct msm_rpmrs_level msm_rpmrs_levels[] = {
+	{
+		MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT,
+		MSM_RPMRS_LIMITS(ON, ACTIVE, MAX, ACTIVE),
+		true,
+		1, 8000, 100000, 1,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE,
+		MSM_RPMRS_LIMITS(ON, ACTIVE, MAX, ACTIVE),
+		true,
+		1500, 5000, 60100000, 3000,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(ON, ACTIVE, MAX, ACTIVE),
+		false,
+		1800, 5000, 60350000, 3500,
+	},
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, ACTIVE, MAX, ACTIVE),
+		false,
+		3800, 4500, 65350000, 5500,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(ON, HSFS_OPEN, MAX, ACTIVE),
+		false,
+		2800, 2500, 66850000, 4800,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, HSFS_OPEN, MAX, ACTIVE),
+		false,
+		4800, 2000, 71850000, 6800,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, HSFS_OPEN, ACTIVE, RET_HIGH),
+		false,
+		6800, 500, 75850000, 8800,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, HSFS_OPEN, RET_HIGH, RET_LOW),
+		false,
+		7800, 0, 76350000, 9800,
+	},
+};
+
+static uint32_t msm_rpm_get_swfi_latency(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(msm_rpmrs_levels); i++) {
+		if (msm_rpmrs_levels[i].sleep_mode ==
+			MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT)
+			return msm_rpmrs_levels[i].latency_us;
+	}
+
+	return 0;
+}
+
+/* Macros assume PMIC GPIOs start at 0 */
+#define PM8058_GPIO_BASE			NR_MSM_GPIOS
+#define PM8058_GPIO_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8058_GPIO_BASE)
+#define PM8058_GPIO_SYS_TO_PM(sys_gpio)		(sys_gpio - PM8058_GPIO_BASE)
+
+/* ---- SDCARD ---- */
+/* ---- WIFI ---- */
+
+static uint32_t wifi_on_gpio_table[] = {
+	GPIO_CFG(RIDER_GPIO_WIFI_IRQ, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_4MA), /* WLAN IRQ */
+};
+
+static uint32_t wifi_off_gpio_table[] = {
+	GPIO_CFG(RIDER_GPIO_WIFI_IRQ, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_4MA), /* WLAN IRQ */
+};
+
+static void config_gpio_table(uint32_t *table, int len)
+{
+	int n, rc;
+	for (n = 0; n < len; n++) {
+		rc = gpio_tlmm_config(table[n], GPIO_CFG_ENABLE);
+		if (rc) {
+			pr_err("%s: gpio_tlmm_config(%#x)=%d\n", __func__, table[n], rc);
+			break;
+		}
+	}
+}
+
+/* BCM4329 returns wrong sdio_vsn(1) when we read cccr,
+ * we use predefined value (sdio_vsn=2) here to initial sdio driver well
+ */
+static struct embedded_sdio_data rider_wifi_emb_data = {
+	.cccr	= {
+		.sdio_vsn	= 2,
+		.multi_block	= 1,
+		.low_speed	= 0,
+		.wide_bus	= 0,
+		.high_power	= 1,
+		.high_speed	= 1,
+	}
+};
+
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+
+static int
+rider_wifi_status_register(void (*callback)(int card_present, void *dev_id),
+				void *dev_id)
+{
+	if (wifi_status_cb)
+		return -EAGAIN;
+
+	wifi_status_cb = callback;
+	wifi_status_cb_devid = dev_id;
+	return 0;
+}
+
+static int rider_wifi_cd;	/* WiFi virtual 'card detect' status */
+
+static unsigned int rider_wifi_status(struct device *dev)
+{
+	return rider_wifi_cd;
+}
+
+static unsigned int rider_wifislot_type = MMC_TYPE_SDIO_WIFI;
+static struct mmc_platform_data rider_wifi_data = {
+	.ocr_mask               = MMC_VDD_28_29,
+	.status                 = rider_wifi_status,
+	.register_status_notify = rider_wifi_status_register,
+	.embedded_sdio          = &rider_wifi_emb_data,
+	.mmc_bus_width  = MMC_CAP_4_BIT_DATA,
+	.slot_type = &rider_wifislot_type,
+	.msmsdcc_fmin   = 400000,
+	.msmsdcc_fmid   = 24000000,
+	.msmsdcc_fmax   = 48000000,
+	.nonremovable   = 0,
+	.pclk_src_dfab	= 1,
+};
+
+
+int rider_wifi_set_carddetect(int val)
+{
+	printk(KERN_INFO "%s: %d\n", __func__, val);
+	rider_wifi_cd = val;
+	if (wifi_status_cb)
+		wifi_status_cb(val, wifi_status_cb_devid);
+	else
+		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(rider_wifi_set_carddetect);
+
+int rider_wifi_power(int on)
+{
+	const unsigned SDC4_HDRV_PULL_CTL_ADDR = (unsigned) MSM_TLMM_BASE + 0x20A0;
+
+	printk(KERN_INFO "%s: %d\n", __func__, on);
+
+	if (on) {
+		writel(0x1FDB, SDC4_HDRV_PULL_CTL_ADDR);
+		config_gpio_table(wifi_on_gpio_table,
+				  ARRAY_SIZE(wifi_on_gpio_table));
+	} else {
+		writel(0x0BDB, SDC4_HDRV_PULL_CTL_ADDR);
+		config_gpio_table(wifi_off_gpio_table,
+				  ARRAY_SIZE(wifi_off_gpio_table));
+	}
+	/* htc_wifi_bt_sleep_clk_ctl(on, ID_WIFI); */
+	mdelay(1);/*Delay 1 ms, Recommand by Hardware*/
+	gpio_set_value(RIDER_GPIO_WIFI_SHUTDOWN_N, on); /* WIFI_SHUTDOWN */
+
+	mdelay(120);
+	return 0;
+}
+EXPORT_SYMBOL(rider_wifi_power);
+
+int rider_wifi_reset(int on)
+{
+	printk(KERN_INFO "%s: do nothing\n", __func__);
+	return 0;
+}
+
+/* ---- WIMAX ---- */
+static uint32_t wimax_on_gpio_table[] = {
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D0,  2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA), /* DAT0 */
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D1,  2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA), /* DAT1 */
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D2,  2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA), /* DAT2 */
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D3,  2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA), /* DAT3 */
+    GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_CMD, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA), /* CMD */
+    GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_CLK_CPU, 2, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA), /* CLK */
+    GPIO_CFG(RIDER_GPIO_V_WIMAX_1V2_RF_EN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA),  /* 1v2RF */
+    GPIO_CFG(RIDER_GPIO_V_WIMAX_DVDD_EN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA),    /* DVDD */
+    GPIO_CFG(RIDER_GPIO_V_WIMAX_PVDD_EN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_8MA),    /* PVDD */
+    GPIO_CFG(RIDER_GPIO_WIMAX_EXT_RST,   0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),    /* EXT_RST */
+
+};
+
+static uint32_t wimax_off_gpio_table[] = {
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D0,  0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), /* DAT0 */
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D1,  0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), /* DAT1 */
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D2,  0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), /* DAT2 */
+	GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_D3,  0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), /* DAT3 */
+    GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_CMD, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), /* CMD */
+    GPIO_CFG(RIDER_GPIO_WIMAX_SDIO_CLK_CPU, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), /* CLK */
+    GPIO_CFG(RIDER_GPIO_V_WIMAX_1V2_RF_EN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),  /* 1v2RF */
+    GPIO_CFG(RIDER_GPIO_V_WIMAX_DVDD_EN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),    /* DVDD */
+    GPIO_CFG(RIDER_GPIO_V_WIMAX_PVDD_EN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),    /* PVDD */
+    GPIO_CFG(RIDER_GPIO_WIMAX_EXT_RST,   0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),    /* EXT_RST */
+};
+
+static uint32_t wimax_uart_on_gpio_table[] = {
+	/* UART3 TX */
+	GPIO_CFG(RIDER_GPIO_WIMAX_UART_SIN, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+	/* UART3 RX , setting PULL_UP , NO_PULL is all ok. */
+	GPIO_CFG(RIDER_GPIO_WIMAX_UART_SOUT, 1, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+};
+
+static uint32_t wimax_uart_off_gpio_table[] = {
+	/* UART3 TX */
+	GPIO_CFG(RIDER_GPIO_WIMAX_UART_SIN, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+	/* UART3 RX */
+	GPIO_CFG(RIDER_GPIO_WIMAX_UART_SOUT, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+};
+
+static void (*wimax_status_cb)(int card_present, void *dev_id);
+static void *wimax_status_cb_devid;
+static int mmc_wimax_cd = 0;
+static int mmc_wimax_hostwakeup_gpio = PM8058_GPIO_PM_TO_SYS(RIDER_WIMAX_HOST_WAKEUP);
+
+static int mmc_wimax_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
+{
+	if (wimax_status_cb)
+		return -EAGAIN;
+	printk(KERN_INFO "%s\n", __func__);
+	wimax_status_cb = callback;
+	wimax_status_cb_devid = dev_id;
+	return 0;
+}
+
+static unsigned int mmc_wimax_status(struct device *dev)
+{
+	printk(KERN_INFO "%s\n", __func__);
+	return mmc_wimax_cd;
+}
+
+void mmc_wimax_set_carddetect(int val)
+{
+	printk(KERN_INFO "%s: %d\n", __func__, val);
+	mmc_wimax_cd = val;
+	if (wimax_status_cb)
+		wimax_status_cb(val, wimax_status_cb_devid);
+	else
+		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
+}
+EXPORT_SYMBOL(mmc_wimax_set_carddetect);
+
+static unsigned int mmc_wimax_type = MMC_TYPE_SDIO_WIMAX;
+
+static struct mmc_platform_data mmc_wimax_data = {
+	.ocr_mask		= MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+	.status			= mmc_wimax_status,
+	.register_status_notify	= mmc_wimax_status_register,
+	.embedded_sdio		= NULL,
+	.mmc_bus_width  = MMC_CAP_4_BIT_DATA,
+	.msmsdcc_fmin   = 400000,
+	.msmsdcc_fmid   = 24000000,
+	.msmsdcc_fmax   = 48000000,
+	.nonremovable   = 0,
+	.slot_type		= &mmc_wimax_type,
+	.pclk_src_dfab	= 1,
+	.dummy52_required = 1,
+};
+
+struct _vreg {
+	const char *name;
+	unsigned id;
+};
+
+int mmc_wimax_power(int on)
+{
+	printk(KERN_INFO "%s\n", __func__);
+
+	if (on) {
+		/*Power ON sequence*/
+		/* Configure UART3 TX/RX */
+		config_gpio_table(wimax_uart_on_gpio_table,
+			  ARRAY_SIZE(wimax_uart_on_gpio_table));
+		config_gpio_table(wimax_on_gpio_table,
+			  ARRAY_SIZE(wimax_on_gpio_table));
+		gpio_set_value(RIDER_GPIO_V_WIMAX_PVDD_EN, 1);  /* V_WIMAX_PVDD_EN */
+		mdelay(2);
+		gpio_set_value(RIDER_GPIO_V_WIMAX_DVDD_EN, 1);   /* V_WIMAX_DVDD_EN */
+		gpio_set_value(RIDER_GPIO_V_WIMAX_1V2_RF_EN, 1); /* V_WIMAX_1V2_RF_EN */
+		mdelay(10);
+		gpio_set_value(RIDER_GPIO_WIMAX_EXT_RST, 1);	 /* WIMAX_EXT_RSTz */
+		mdelay(2);
+	} else {
+		/*Power OFF sequence*/
+		gpio_set_value(RIDER_GPIO_WIMAX_EXT_RST, 0);	 /* WIMAX_EXT_RSTz */
+		config_gpio_table(wimax_off_gpio_table,
+			  ARRAY_SIZE(wimax_off_gpio_table));
+		gpio_set_value(RIDER_GPIO_V_WIMAX_1V2_RF_EN, 0); /* V_WIMAX_1V2_RF_EN */
+		gpio_set_value(RIDER_GPIO_V_WIMAX_DVDD_EN, 0);   /* V_WIMAX_DVDD_EN */
+		gpio_set_value(RIDER_GPIO_V_WIMAX_PVDD_EN, 0);  /* V_WIMAX_PVDD_EN */
+		/* Configure UART3 TX/RX */
+		config_gpio_table(wimax_uart_off_gpio_table,
+			  ARRAY_SIZE(wimax_uart_off_gpio_table));
+
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_wimax_power);
+
+int wimax_uart_switch = 0;
+int mmc_wimax_uart_switch(int uart)
+{
+#ifdef CONFIG_WIMAX_SERIAL_MSM
+	int ret = 0;
+#endif
+	printk(KERN_INFO "%s uart:%d\n", __func__, uart);
+	wimax_uart_switch = uart;
+
+	if (wimax_uart_switch == 0) { /* initialize */
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_UART_EN, 0);
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_SW, 0);
+		gpio_set_value(RIDER_GPIO_MHL_USB_EN, 1);
+
+	} else if (wimax_uart_switch == 1) { /* enable WIMAX UART to USB */
+		config_gpio_table(wimax_uart_off_gpio_table,
+			  ARRAY_SIZE(wimax_uart_off_gpio_table)); /* Disable UART3 to GPIO */
+
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_UART_EN, 0);
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_SW, 1);
+		gpio_set_value(RIDER_GPIO_MHL_USB_EN, 1);
+	} else if (wimax_uart_switch == 2) { /* enable WIMAX_UART to MSM */
+		config_gpio_table(wimax_uart_on_gpio_table,
+			  ARRAY_SIZE(wimax_uart_on_gpio_table)); /* Enable UART3 to ALT1 */
+
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_UART_EN, 1);
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_SW, 0);
+		gpio_set_value(RIDER_GPIO_MHL_USB_EN, 0);
+	}
+#ifdef CONFIG_WIMAX_SERIAL_MSM
+	else if (wimax_uart_switch == 10) { /* WIMAX UART debug thread. */
+		printk(KERN_INFO "%s : wimax_uart_switch %d\n", __func__, wimax_uart_switch);
+		msm_serial_wimax_init(MSM_UART3_PHYS, MSM_GSBI3_PHYS, GSBI3_UARTDM_IRQ,
+			&msm_device_uart3.dev, 23, MSM_GPIO_TO_INT(RIDER_GPIO_WIMAX_UART_SOUT));
+	} else if (wimax_uart_switch > 10 && wimax_uart_switch <= 99) { /* WIMAX UART debug thread. */
+		printk(KERN_INFO "%s : wimax_uart_switch %d\n", __func__, wimax_uart_switch);
+		ret = msm_serial_wimax_thread(wimax_uart_switch);
+		if (ret != 0)
+			printk(KERN_INFO "%s : wimax_uart_switch ret=%d\n", __func__, ret);
+	}
+#endif
+	else { /* others, USB to USB */
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_UART_EN, 1);
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_SW, 0);
+		gpio_set_value(RIDER_GPIO_MHL_USB_EN, 0);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_wimax_uart_switch);
+
+int mmc_wimax_get_uart_switch(void)
+{
+	printk(KERN_INFO "%s uart:%d\n", __func__, wimax_uart_switch);
+	return wimax_uart_switch;
+}
+EXPORT_SYMBOL(mmc_wimax_get_uart_switch);
+
+/*non-8X60 PROJECT need to use GPIO mapping to decode the IRQ number(id) for PMIC GPIO*/
+int mmc_wimax_get_hostwakeup_gpio(void)
+{
+	return mmc_wimax_hostwakeup_gpio;
+}
+EXPORT_SYMBOL(mmc_wimax_get_hostwakeup_gpio);
+
+/*8X60 PROJECT need to use Marco PM8058_GPIO_IRQ to decode the IRQ number(id) for PMIC GPIO*/
+int mmc_wimax_get_hostwakeup_IRQ_ID(void)
+{
+	return PM8058_GPIO_IRQ(PM8058_IRQ_BASE, RIDER_WIMAX_HOST_WAKEUP);
+}
+EXPORT_SYMBOL(mmc_wimax_get_hostwakeup_IRQ_ID);
+
+void mmc_wimax_enable_host_wakeup(int on)
+{
+	if (mmc_wimax_get_status())
+		if (on) {
+			if (!mmc_wimax_get_gpio_irq_enabled()) {
+			    if (printk_ratelimit())
+					printk(KERN_INFO "[WIMAX] set PMIC GPIO%d as wakeup source on IRQ %d\n", RIDER_WIMAX_HOST_WAKEUP+1, mmc_wimax_get_hostwakeup_IRQ_ID());
+				enable_irq(mmc_wimax_get_hostwakeup_IRQ_ID());
+				enable_irq_wake(mmc_wimax_get_hostwakeup_IRQ_ID());
+				mmc_wimax_set_gpio_irq_enabled(1);
+			}
+		} else {
+			if (mmc_wimax_get_gpio_irq_enabled()) {
+				if (printk_ratelimit())
+					printk(KERN_INFO "[WIMAX] disable PMIC GPIO%d wakeup source\n", RIDER_WIMAX_HOST_WAKEUP+1);
+				disable_irq_wake(mmc_wimax_get_hostwakeup_IRQ_ID());
+				disable_irq_nosync(mmc_wimax_get_hostwakeup_IRQ_ID());
+				mmc_wimax_set_gpio_irq_enabled(0);
+			}
+		}
+	else
+		printk(KERN_INFO "%s mmc_wimax_sdio_status is OFF\n", __func__);
+}
+EXPORT_SYMBOL(mmc_wimax_enable_host_wakeup);
+
+/* ---- MMC ---- */
+int __init rider_init_mmc()
+{
+	uint32_t id;
+	wifi_status_cb = NULL;
+
+	printk(KERN_INFO "rider: %s\n", __func__);
+
+	/* SDC2: WiMax */
+	/* PM QoS for wimax */
+    mmc_wimax_data.swfi_latency = msm_rpm_get_swfi_latency();
+	msm_add_sdcc(2, &mmc_wimax_data);
+
+	/* re-initialize wimax GPIO */
+	config_gpio_table(wimax_off_gpio_table,
+			  ARRAY_SIZE(wimax_off_gpio_table));
+
+	/* Configure UART3 TX/RX */
+   config_gpio_table(wimax_uart_off_gpio_table,
+			  ARRAY_SIZE(wimax_uart_off_gpio_table));
+
+	/* SDC4: WiFi */
+	/* initial WIFI_SHUTDOWN# */
+	id = GPIO_CFG(RIDER_GPIO_WIFI_SHUTDOWN_N, 0, GPIO_CFG_OUTPUT,
+		GPIO_CFG_NO_PULL, GPIO_CFG_2MA);
+	gpio_tlmm_config(id, 0);
+	gpio_set_value(RIDER_GPIO_WIFI_SHUTDOWN_N, 0);
+
+	/* PM QoS for wifi*/
+    rider_wifi_data.swfi_latency = msm_rpm_get_swfi_latency();
+	msm_add_sdcc(4, &rider_wifi_data);
+
+	return 0;
+}
diff --git a/arch/arm/mach-msm/board-rider-mmc.h b/arch/arm/mach-msm/board-rider-mmc.h
new file mode 100644
index 0000000..5a65c1c
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-mmc.h
@@ -0,0 +1,15 @@
+/* linux/arch/arm/mach-msm/board-rider-mmc.h
+ *
+ * Copyright (C) 2011 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+extern int msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat);
diff --git a/arch/arm/mach-msm/board-rider-rfkill.c b/arch/arm/mach-msm/board-rider-rfkill.c
new file mode 100644
index 0000000..4759518
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-rfkill.c
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2010 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* Control bluetooth power for shooter platform */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <asm/mach-types.h>
+
+#include <linux/mfd/pmic8058.h>
+#include "board-rider.h"
+/*
+#include <mach/htc_sleep_clk.h>
+*/
+
+static struct rfkill *bt_rfk;
+static const char bt_name[] = "bcm4329";
+
+/* bt on configuration */
+static uint32_t rider_bt_on_table[] = {
+
+	/* BT_RTS */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_RTS,
+				1,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_8MA),
+	/* BT_CTS */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_CTS,
+				1,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP,
+				GPIO_CFG_8MA),
+	/* BT_RX */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_RX,
+				1,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP,
+				GPIO_CFG_8MA),
+	/* BT_TX */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_TX,
+				1,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_8MA),
+
+	/* BT_HOST_WAKE */
+	GPIO_CFG(RIDER_GPIO_BT_HOST_WAKE,
+				0,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+	/* BT_CHIP_WAKE */
+	GPIO_CFG(RIDER_GPIO_BT_CHIP_WAKE,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+
+	/* BT_RESET_N */
+	GPIO_CFG(RIDER_GPIO_BT_RESET_N,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+	/* BT_SHUTDOWN_N */
+	GPIO_CFG(RIDER_GPIO_BT_SHUTDOWN_N,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+};
+
+/* bt off configuration */
+static uint32_t rider_bt_off_table[] = {
+
+	/* BT_RTS */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_RTS,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_8MA),
+	/* BT_CTS */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_CTS,
+				0,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP,
+				GPIO_CFG_8MA),
+	/* BT_RX */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_RX,
+				0,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP,
+				GPIO_CFG_8MA),
+	/* BT_TX */
+	GPIO_CFG(RIDER_GPIO_BT_UART1_TX,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_8MA),
+
+	/* BT_RESET_N */
+	GPIO_CFG(RIDER_GPIO_BT_RESET_N,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+	/* BT_SHUTDOWN_N */
+	GPIO_CFG(RIDER_GPIO_BT_SHUTDOWN_N,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+
+	/* BT_HOST_WAKE */
+	GPIO_CFG(RIDER_GPIO_BT_HOST_WAKE,
+				0,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_DOWN,
+				GPIO_CFG_2MA),
+	/* BT_CHIP_WAKE */
+	GPIO_CFG(RIDER_GPIO_BT_CHIP_WAKE,
+				0,
+				GPIO_CFG_OUTPUT,
+				GPIO_CFG_NO_PULL,
+				GPIO_CFG_2MA),
+};
+
+static void config_bt_table(uint32_t *table, int len)
+{
+	int n, rc;
+
+	for (n = 0; n < len; n++) {
+		rc = gpio_tlmm_config(table[n], GPIO_CFG_ENABLE);
+		if (rc) {
+			pr_err("[BT]%s: gpio_tlmm_config(%#x)=%d\n",
+				__func__, table[n], rc);
+			break;
+		}
+	}
+}
+
+static void rider_config_bt_on(void)
+{
+	printk(KERN_INFO "[BT]-- R ON --\n");
+
+	/* set bt on configuration*/
+	config_bt_table(rider_bt_on_table,
+				ARRAY_SIZE(rider_bt_on_table));
+	mdelay(2);
+
+	/* BT_RESET_N */
+	gpio_set_value(RIDER_GPIO_BT_RESET_N, 0);
+	mdelay(1);
+
+	/* BT_SHUTDOWN_N */
+	gpio_set_value(RIDER_GPIO_BT_SHUTDOWN_N, 0);
+	mdelay(5);
+
+	/* BT_SHUTDOWN_N */
+	gpio_set_value(RIDER_GPIO_BT_SHUTDOWN_N, 1);
+	mdelay(1);
+
+	/* BT_RESET_N */
+	gpio_set_value(RIDER_GPIO_BT_RESET_N, 1);
+	mdelay(2);
+
+}
+
+static void rider_config_bt_off(void)
+{
+	printk(KERN_INFO "[BT]-- R OFF --\n");
+
+	/* BT_RESET_N */
+	gpio_set_value(RIDER_GPIO_BT_RESET_N, 0);
+	mdelay(1);
+
+	/* BT_SHUTDOWN_N */
+	gpio_set_value(RIDER_GPIO_BT_SHUTDOWN_N, 0);
+	mdelay(1);
+
+	/* set bt off configuration*/
+	config_bt_table(rider_bt_off_table,
+				ARRAY_SIZE(rider_bt_off_table));
+	mdelay(2);
+
+	/* BT_RTS */
+	gpio_set_value(RIDER_GPIO_BT_UART1_RTS, 1);
+
+	/* BT_CTS */
+
+	/* BT_TX */
+	gpio_set_value(RIDER_GPIO_BT_UART1_TX, 0);
+
+	/* BT_RX */
+
+
+	/* BT_HOST_WAKE */
+
+	/* BT_CHIP_WAKE */
+	gpio_set_value(RIDER_GPIO_BT_CHIP_WAKE, 0);
+}
+
+static int bluetooth_set_power(void *data, bool blocked)
+{
+	if (!blocked)
+		rider_config_bt_on();
+	else
+		rider_config_bt_off();
+
+	return 0;
+}
+
+static struct rfkill_ops rider_rfkill_ops = {
+	.set_block = bluetooth_set_power,
+};
+
+static int rider_rfkill_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	bool default_state = true; /* off */
+
+#if 0 /* Is this necessary? */
+	rc = gpio_request(RIDER_GPIO_BT_RESET_N, "bt_reset");
+	if (rc)
+		goto err_gpio_reset;
+	rc = gpio_request(RIDER_GPIO_BT_SHUTDOWN_N, "bt_shutdown");
+	if (rc)
+		goto err_gpio_shutdown;
+#endif
+
+	/* always turn on clock? */
+/*
+	htc_wifi_bt_sleep_clk_ctl(CLK_ON, ID_BT);
+*/
+	mdelay(2);
+
+	bluetooth_set_power(NULL, default_state);
+
+	bt_rfk = rfkill_alloc(bt_name, &pdev->dev, RFKILL_TYPE_BLUETOOTH,
+				&rider_rfkill_ops, NULL);
+	if (!bt_rfk) {
+		rc = -ENOMEM;
+		goto err_rfkill_alloc;
+	}
+
+	rfkill_set_states(bt_rfk, default_state, false);
+
+	/* userspace cannot take exclusive control */
+	rc = rfkill_register(bt_rfk);
+	if (rc)
+		goto err_rfkill_reg;
+
+	return 0;
+
+err_rfkill_reg:
+	rfkill_destroy(bt_rfk);
+err_rfkill_alloc:
+#if 0
+	gpio_free(RIDER_GPIO_BT_SHUTDOWN_N);
+err_gpio_shutdown:
+	gpio_free(RIDER_GPIO_BT_RESET_N);
+err_gpio_reset:
+#endif
+	return rc;
+}
+
+static int rider_rfkill_remove(struct platform_device *dev)
+{
+	rfkill_unregister(bt_rfk);
+	rfkill_destroy(bt_rfk);
+#if 0
+	gpio_free(RIDER_GPIO_BT_SHUTDOWN_N);
+	gpio_free(RIDER_GPIO_BT_RESET_N);
+#endif
+
+	return 0;
+}
+
+static struct platform_driver rider_rfkill_driver = {
+	.probe = rider_rfkill_probe,
+	.remove = rider_rfkill_remove,
+	.driver = {
+		.name = "rider_rfkill",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init rider_rfkill_init(void)
+{
+	return platform_driver_register(&rider_rfkill_driver);
+}
+
+static void __exit rider_rfkill_exit(void)
+{
+	platform_driver_unregister(&rider_rfkill_driver);
+}
+
+module_init(rider_rfkill_init);
+module_exit(rider_rfkill_exit);
+MODULE_DESCRIPTION("rider rfkill");
+MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msm/board-rider-wifi.c b/arch/arm/mach-msm/board-rider-wifi.c
new file mode 100644
index 0000000..be33eb7
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-wifi.c
@@ -0,0 +1,276 @@
+/* linux/arch/arm/mach-msm/board-rider-wifi.c
+*/
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/skbuff.h>
+#include <linux/wifi_tiwlan.h>
+
+#include "board-rider.h"
+#include "board-rider-wifi.h"
+
+int rider_wifi_power(int on);
+int rider_wifi_reset(int on);
+int rider_wifi_set_carddetect(int on);
+int rider_wifi_get_mac_addr(unsigned char *buf);
+
+#define PREALLOC_WLAN_NUMBER_OF_SECTIONS	4
+#define PREALLOC_WLAN_NUMBER_OF_BUFFERS		160
+#define PREALLOC_WLAN_SECTION_HEADER		24
+
+#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
+#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 128)
+#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 512)
+#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_NUMBER_OF_BUFFERS * 1024)
+
+#define WLAN_SKB_BUF_NUM	16
+
+/*#define HW_OOB 1*/
+
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
+
+typedef struct wifi_mem_prealloc_struct {
+	void *mem_ptr;
+	unsigned long size;
+} wifi_mem_prealloc_t;
+
+static wifi_mem_prealloc_t wifi_mem_array[PREALLOC_WLAN_NUMBER_OF_SECTIONS] = {
+	{ NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER) },
+	{ NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER) },
+	{ NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER) },
+	{ NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER) }
+};
+
+static void *rider_wifi_mem_prealloc(int section, unsigned long size)
+{
+	if (section == PREALLOC_WLAN_NUMBER_OF_SECTIONS)
+		return wlan_static_skb;
+	if ((section < 0) || (section > PREALLOC_WLAN_NUMBER_OF_SECTIONS))
+		return NULL;
+	if (wifi_mem_array[section].size < size)
+		return NULL;
+	return wifi_mem_array[section].mem_ptr;
+}
+
+int __init rider_init_wifi_mem(void)
+{
+	int i;
+
+	for (i = 0; (i < WLAN_SKB_BUF_NUM); i++) {
+		if (i < (WLAN_SKB_BUF_NUM/2))
+			wlan_static_skb[i] = dev_alloc_skb(4096);
+		else
+			wlan_static_skb[i] = dev_alloc_skb(8192);
+	}
+	for (i = 0; (i < PREALLOC_WLAN_NUMBER_OF_SECTIONS); i++) {
+		wifi_mem_array[i].mem_ptr = kmalloc(wifi_mem_array[i].size,
+							GFP_KERNEL);
+		if (wifi_mem_array[i].mem_ptr == NULL)
+			return -ENOMEM;
+	}
+	return 0;
+}
+
+static struct resource rider_wifi_resources[] = {
+	[0] = {
+		.name		= "bcm4329_wlan_irq",
+		.start		= MSM_GPIO_TO_INT(RIDER_GPIO_WIFI_IRQ),
+		.end		= MSM_GPIO_TO_INT(RIDER_GPIO_WIFI_IRQ),
+#ifdef HW_OOB
+		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL | IORESOURCE_IRQ_SHAREABLE,
+#else
+		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+#endif
+	},
+};
+
+static struct wifi_platform_data rider_wifi_control = {
+	.set_power      = rider_wifi_power,
+	.set_reset      = rider_wifi_reset,
+	.set_carddetect = rider_wifi_set_carddetect,
+	.mem_prealloc   = rider_wifi_mem_prealloc,
+	.get_mac_addr	= rider_wifi_get_mac_addr,
+};
+
+static struct platform_device rider_wifi_device = {
+	.name           = "bcm4329_wlan",
+	.id             = 1,
+	.num_resources  = ARRAY_SIZE(rider_wifi_resources),
+	.resource       = rider_wifi_resources,
+	.dev            = {
+		.platform_data = &rider_wifi_control,
+	},
+};
+
+static unsigned rider_wifi_update_nvs(char *str)
+{
+#define NVS_LEN_OFFSET		0x0C
+#define NVS_DATA_OFFSET		0x40
+	unsigned char *ptr;
+	unsigned len;
+
+	if (!str)
+		return -EINVAL;
+	ptr = get_wifi_nvs_ram();
+	/* Size in format LE assumed */
+	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
+
+	/* the last bye in NVRAM is 0, trim it */
+	if (ptr[NVS_DATA_OFFSET + len - 1] == 0)
+		len -= 1;
+
+	if (ptr[NVS_DATA_OFFSET + len - 1] != '\n') {
+		len += 1;
+		ptr[NVS_DATA_OFFSET + len - 1] = '\n';
+	}
+
+	strcpy(ptr + NVS_DATA_OFFSET + len, str);
+	len += strlen(str);
+	memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
+	return 0;
+}
+
+#ifdef HW_OOB
+static unsigned strip_nvs_param(char *param)
+{
+	unsigned char *nvs_data;
+
+	unsigned param_len;
+	int start_idx, end_idx;
+
+	unsigned char *ptr;
+	unsigned len;
+
+	if (!param)
+		return -EINVAL;
+	ptr = get_wifi_nvs_ram();
+	/* Size in format LE assumed */
+	memcpy(&len, ptr + NVS_LEN_OFFSET, sizeof(len));
+
+	/* the last bye in NVRAM is 0, trim it */
+	if (ptr[NVS_DATA_OFFSET + len - 1] == 0)
+		len -= 1;
+
+	nvs_data = ptr + NVS_DATA_OFFSET;
+
+	param_len = strlen(param);
+
+	/* search param */
+	for (start_idx = 0; start_idx < len - param_len; start_idx++) {
+		if (memcmp(&nvs_data[start_idx], param, param_len) == 0)
+			break;
+	}
+
+	end_idx = 0;
+	if (start_idx < len - param_len) {
+		/* search end-of-line */
+		for (end_idx = start_idx + param_len; end_idx < len; end_idx++) {
+			if (nvs_data[end_idx] == '\n' || nvs_data[end_idx] == 0)
+				break;
+		}
+	}
+
+	if (start_idx < end_idx) {
+		/* move the remain data forward */
+		for (; end_idx + 1 < len; start_idx++, end_idx++)
+			nvs_data[start_idx] = nvs_data[end_idx+1];
+
+		len = len - (end_idx - start_idx + 1);
+		memcpy(ptr + NVS_LEN_OFFSET, &len, sizeof(len));
+	}
+	return 0;
+}
+#endif
+
+#define WIFI_MAC_PARAM_STR     "macaddr="
+#define WIFI_MAX_MAC_LEN       17 /* XX:XX:XX:XX:XX:XX */
+
+static uint
+get_mac_from_wifi_nvs_ram(char *buf, unsigned int buf_len)
+{
+	unsigned char *nvs_ptr;
+	unsigned char *mac_ptr;
+	uint len = 0;
+
+	if (!buf || !buf_len)
+		return 0;
+
+	nvs_ptr = get_wifi_nvs_ram();
+	if (nvs_ptr)
+		nvs_ptr += NVS_DATA_OFFSET;
+
+	mac_ptr = strstr(nvs_ptr, WIFI_MAC_PARAM_STR);
+	if (mac_ptr) {
+		mac_ptr += strlen(WIFI_MAC_PARAM_STR);
+
+		/* skip leading space */
+		while (mac_ptr[0] == ' ')
+			mac_ptr++;
+
+		/* locate end-of-line */
+		len = 0;
+		while (mac_ptr[len] != '\r' && mac_ptr[len] != '\n' &&
+			mac_ptr[len] != '\0') {
+			len++;
+		}
+
+		if (len > buf_len)
+			len = buf_len;
+
+		memcpy(buf, mac_ptr, len);
+	}
+
+	return len;
+}
+
+#define ETHER_ADDR_LEN 6
+int rider_wifi_get_mac_addr(unsigned char *buf)
+{
+	static u8 ether_mac_addr[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0xFF};
+	char mac[WIFI_MAX_MAC_LEN];
+	unsigned mac_len;
+	unsigned int macpattern[ETHER_ADDR_LEN];
+	int i;
+
+	mac_len = get_mac_from_wifi_nvs_ram(mac, WIFI_MAX_MAC_LEN);
+	if (mac_len > 0) {
+		/* Mac address to pattern */
+		sscanf(mac, "%02x:%02x:%02x:%02x:%02x:%02x",
+		&macpattern[0], &macpattern[1], &macpattern[2],
+		&macpattern[3], &macpattern[4], &macpattern[5]
+		);
+
+		for (i = 0; i < ETHER_ADDR_LEN; i++)
+			ether_mac_addr[i] = (u8)macpattern[i];
+	}
+
+	memcpy(buf, ether_mac_addr, sizeof(ether_mac_addr));
+
+	printk(KERN_INFO"rider_wifi_get_mac_addr = %02x %02x %02x %02x %02x %02x \n",
+		ether_mac_addr[0], ether_mac_addr[1], ether_mac_addr[2], ether_mac_addr[3], ether_mac_addr[4], ether_mac_addr[5]);
+
+	return 0;
+}
+
+int __init rider_wifi_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "%s: start\n", __func__);
+#ifdef HW_OOB
+	strip_nvs_param("sd_oobonly");
+#else
+	rider_wifi_update_nvs("sd_oobonly=1\n");
+#endif
+	rider_wifi_update_nvs("btc_params80=0\n");
+	rider_wifi_update_nvs("btc_params6=30\n");
+	rider_init_wifi_mem();
+	ret = platform_device_register(&rider_wifi_device);
+	return ret;
+}
+
diff --git a/arch/arm/mach-msm/board-rider-wifi.h b/arch/arm/mach-msm/board-rider-wifi.h
new file mode 100644
index 0000000..9a98008
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider-wifi.h
@@ -0,0 +1,15 @@
+/* linux/arch/arm/mach-msm/board-rider-wifi.h
+ *
+ * Copyright (C) 2008 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+extern unsigned char *get_wifi_nvs_ram(void);
diff --git a/arch/arm/mach-msm/board-rider.c b/arch/arm/mach-msm/board-rider.c
new file mode 100644
index 0000000..8e93de4
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider.c
@@ -0,0 +1,6700 @@
+/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#define HASTIMPANI 0
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/mfd/pmic8058.h>
+#include <linux/msm_ssbi.h>
+#include <linux/leds.h>
+#include <linux/pmic8058-othc.h>
+#include <linux/mfd/pmic8901.h>
+#include <linux/regulator/pmic8901-regulator.h>
+#include <linux/bootmem.h>
+#include <linux/leds-pm8058.h>
+#include <linux/htc_flashlight.h>
+#include <linux/msm_adc.h>
+#include <linux/m_adcproc.h>
+#include <linux/mfd/marimba.h>
+#include <linux/isl29028.h>
+#include <linux/isl29029.h>
+#include <linux/mpu.h>
+
+#include <linux/msm-charger.h>
+#include <linux/i2c.h>
+#include <linux/i2c/sx150x.h>
+#include <linux/smsc911x.h>
+#include <linux/spi/spi.h>
+#include <linux/input/tdisc_shinetsu.h>
+#include <linux/i2c/isa1200.h>
+#include <linux/dma-mapping.h>
+#include <linux/i2c/bq27520.h>
+#include "sysinfo-8x60.h"
+#include <linux/atmel_qt602240.h>
+
+
+#ifdef CONFIG_ANDROID_PMEM
+#include <linux/android_pmem.h>
+#endif
+
+#if defined(CONFIG_SMB137B_CHARGER) || defined(CONFIG_SMB137B_CHARGER_MODULE)
+#include <linux/i2c/smb137b.h>
+#endif
+#ifdef CONFIG_SND_SOC_WM8903
+#include <sound/wm8903.h>
+#endif
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/setup.h>
+
+#include <mach/board.h>
+#include <mach/board_htc.h>
+#include <mach/dma.h>
+#include <mach/mpp.h>
+#include <mach/board.h>
+#include <mach/irqs.h>
+#include <mach/msm_spi.h>
+#include <mach/msm_serial_hs.h>
+#include <mach/msm_serial_hs_lite.h>
+#include <mach/msm_iomap.h>
+#include <mach/msm_memtypes.h>
+#include <asm/mach/mmc.h>
+#include <mach/htc_battery_8x60.h>
+#ifdef CONFIG_TPS65200
+#include <linux/tps65200.h>
+#endif
+#include <mach/msm_battery.h>
+#ifdef CONFIG_USB_MSM_OTG_72K
+#include <mach/msm_hsusb.h>
+#else
+#include <linux/usb/msm_hsusb.h>
+#endif
+#ifdef CONFIG_BT
+#include <mach/htc_bdaddress.h>
+#include <mach/htc_sleep_clk.h>
+#endif
+#include <mach/htc_usb.h>
+#include <mach/gpiomux.h>
+#ifdef CONFIG_MSM_DSPS
+#include <mach/msm_dsps.h>
+#endif
+#include <mach/msm_xo.h>
+#include <mach/msm_bus_board.h>
+#include <mach/socinfo.h>
+#include <mach/htc_headset_mgr.h>
+#include <mach/htc_headset_gpio.h>
+#include <mach/htc_headset_pmic.h>
+#include <mach/htc_headset_8x60.h>
+#include <linux/i2c/isl9519.h>
+#ifdef CONFIG_USB_G_ANDROID
+#include <linux/usb/android_composite.h>
+#include <mach/tpa2051d3.h>
+#include <mach/usbdiag.h>
+#endif
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <mach/sdio_al.h>
+#include <mach/rpm.h>
+#include <mach/rpm-regulator.h>
+#include <mach/restart.h>
+#include <mach/cable_detect.h>
+#include <linux/msm_tsens.h>
+
+#include "board-rider.h"
+#include "devices.h"
+#include "devices-msm8x60.h"
+#include "cpuidle.h"
+#include "pm.h"
+#include "pm-boot.h"
+#include "mpm.h"
+#include "spm.h"
+#include "rpm_log.h"
+#include "timer.h"
+#ifdef CONFIG_FB_MSM_HDMI_MHL
+#include <mach/mhl.h>
+#endif
+#include "gpiomux-8x60.h"
+#include "rpm_stats.h"
+#include "peripheral-loader.h"
+#include <linux/platform_data/qcom_crypto_device.h>
+#include "rpm_resources.h"
+#include "acpuclock.h"
+#include <mach/board_htc.h>
+
+#ifdef CONFIG_PERFLOCK
+#include <mach/perflock.h>
+#endif
+
+#ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
+int set_two_phase_freq(int cpufreq);
+#endif
+
+#ifdef CONFIG_CPU_FREQ_GOV_BADASS_2_PHASE
+int set_two_phase_freq_badass(int cpufreq);
+#endif
+#ifdef CONFIG_CPU_FREQ_GOV_BADASS_3_PHASE
+int set_three_phase_freq_badass(int cpufreq);
+#endif
+
+/* Macros assume PMIC GPIOs start at 0 */
+#define PM8058_GPIO_BASE			NR_MSM_GPIOS
+#define PM8058_GPIO_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8058_GPIO_BASE)
+#define PM8058_GPIO_SYS_TO_PM(sys_gpio)		(sys_gpio - PM8058_GPIO_BASE)
+#define PM8058_MPP_BASE			(PM8058_GPIO_BASE + PM8058_GPIOS)
+#define PM8058_MPP_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8058_MPP_BASE)
+#define PM8058_MPP_SYS_TO_PM(sys_gpio)		(sys_gpio - PM8058_MPP_BASE)
+
+#define PM8901_GPIO_BASE			(PM8058_GPIO_BASE + \
+						PM8058_GPIOS + PM8058_MPPS)
+#define PM8901_GPIO_PM_TO_SYS(pm_gpio)		(pm_gpio + PM8901_GPIO_BASE)
+#define PM8901_GPIO_SYS_TO_PM(sys_gpio)		(sys_gpio - PM901_GPIO_BASE)
+#define PM8901_IRQ_BASE				(PM8058_IRQ_BASE + \
+						NR_PMIC8058_IRQS)
+
+#define A01_DEV 0x80
+
+enum {
+	GPIO_EXPANDER_IRQ_BASE  = PM8901_IRQ_BASE + NR_PMIC8901_IRQS,
+	GPIO_EXPANDER_GPIO_BASE = PM8901_GPIO_BASE + PM8901_MPPS,
+	/* CORE expander */
+	GPIO_CORE_EXPANDER_BASE = GPIO_EXPANDER_GPIO_BASE,
+	GPIO_CLASS_D1_EN        = GPIO_CORE_EXPANDER_BASE,
+	GPIO_WLAN_DEEP_SLEEP_N,
+	GPIO_LVDS_SHUTDOWN_N,
+	GPIO_DISP_RESX_N        = GPIO_LVDS_SHUTDOWN_N,
+	GPIO_MS_SYS_RESET_N,
+	GPIO_CAP_TS_RESOUT_N,
+	GPIO_CAP_GAUGE_BI_TOUT,
+	GPIO_ETHERNET_PME,
+	GPIO_EXT_GPS_LNA_EN,
+	GPIO_MSM_WAKES_BT,
+	GPIO_ETHERNET_RESET_N,
+	GPIO_HEADSET_DET_N,
+	GPIO_USB_UICC_EN,
+	GPIO_BACKLIGHT_EN,
+	GPIO_EXT_CAMIF_PWR_EN,
+	GPIO_BATT_GAUGE_INT_N,
+	GPIO_BATT_GAUGE_EN,
+	/* DOCKING expander */
+	GPIO_DOCKING_EXPANDER_BASE = GPIO_EXPANDER_GPIO_BASE + 16,
+	GPIO_MIPI_DSI_RST_N        = GPIO_DOCKING_EXPANDER_BASE,
+	GPIO_AUX_JTAG_DET_N,
+	GPIO_DONGLE_DET_N,
+	GPIO_SVIDEO_LOAD_DET,
+	GPIO_SVID_AMP_SHUTDOWN1_N,
+	GPIO_SVID_AMP_SHUTDOWN0_N,
+	GPIO_SDC_WP,
+	GPIO_IRDA_PWDN,
+	GPIO_IRDA_RESET_N,
+	GPIO_DONGLE_GPIO0,
+	GPIO_DONGLE_GPIO1,
+	GPIO_DONGLE_GPIO2,
+	GPIO_DONGLE_GPIO3,
+	GPIO_DONGLE_PWR_EN,
+	GPIO_EMMC_RESET_N,
+	GPIO_TP_EXP2_IO15,
+	/* SURF expander */
+	GPIO_SURF_EXPANDER_BASE = GPIO_EXPANDER_GPIO_BASE + (16 * 2),
+	GPIO_SD_CARD_DET_1      = GPIO_SURF_EXPANDER_BASE,
+	GPIO_SD_CARD_DET_2,
+	GPIO_SD_CARD_DET_4,
+	GPIO_SD_CARD_DET_5,
+	GPIO_UIM3_RST,
+	GPIO_SURF_EXPANDER_IO5,
+	GPIO_SURF_EXPANDER_IO6,
+	GPIO_ADC_I2C_EN,
+	GPIO_SURF_EXPANDER_IO8,
+	GPIO_SURF_EXPANDER_IO9,
+	GPIO_SURF_EXPANDER_IO10,
+	GPIO_SURF_EXPANDER_IO11,
+	GPIO_SURF_EXPANDER_IO12,
+	GPIO_SURF_EXPANDER_IO13,
+	GPIO_SURF_EXPANDER_IO14,
+	GPIO_SURF_EXPANDER_IO15,
+	/* LEFT KB IO expander */
+	GPIO_LEFT_KB_EXPANDER_BASE = GPIO_EXPANDER_GPIO_BASE + (16 * 3),
+	GPIO_LEFT_LED_1            = GPIO_LEFT_KB_EXPANDER_BASE,
+	GPIO_LEFT_LED_2,
+	GPIO_LEFT_LED_3,
+	GPIO_LEFT_LED_WLAN,
+	GPIO_JOYSTICK_EN,
+	GPIO_CAP_TS_SLEEP,
+	GPIO_LEFT_KB_IO6,
+	GPIO_LEFT_LED_5,
+	/* RIGHT KB IO expander */
+	GPIO_RIGHT_KB_EXPANDER_BASE = GPIO_EXPANDER_GPIO_BASE + (16 * 3) + 8,
+	GPIO_RIGHT_LED_1            = GPIO_RIGHT_KB_EXPANDER_BASE,
+	GPIO_RIGHT_LED_2,
+	GPIO_RIGHT_LED_3,
+	GPIO_RIGHT_LED_BT,
+	GPIO_WEB_CAMIF_STANDBY,
+	GPIO_COMPASS_RST_N,
+	GPIO_WEB_CAMIF_RESET_N,
+	GPIO_RIGHT_LED_5,
+	GPIO_R_ALTIMETER_RESET_N,
+	/* FLUID S IO expander */
+	GPIO_SOUTH_EXPANDER_BASE,
+	GPIO_MIC2_ANCR_SEL = GPIO_SOUTH_EXPANDER_BASE,
+	GPIO_MIC1_ANCL_SEL,
+	GPIO_HS_MIC4_SEL,
+	GPIO_FML_MIC3_SEL,
+	GPIO_FMR_MIC5_SEL,
+	GPIO_TS_SLEEP,
+	GPIO_HAP_SHIFT_LVL_OE,
+	GPIO_HS_SW_DIR,
+	/* FLUID N IO expander */
+	GPIO_NORTH_EXPANDER_BASE,
+	GPIO_EPM_3_3V_EN = GPIO_NORTH_EXPANDER_BASE,
+	GPIO_EPM_5V_BOOST_EN,
+	GPIO_AUX_CAM_2P7_EN,
+	GPIO_LED_FLASH_EN,
+	GPIO_LED1_GREEN_N,
+	GPIO_LED2_RED_N,
+	GPIO_FRONT_CAM_RESET_N,
+	GPIO_EPM_LVLSFT_EN,
+	GPIO_N_ALTIMETER_RESET_N,
+	/* EPM expander */
+	GPIO_EPM_EXPANDER_BASE,
+	GPIO_PWR_MON_START = GPIO_EPM_EXPANDER_BASE,
+	GPIO_PWR_MON_RESET_N,
+	GPIO_ADC1_PWDN_N,
+	GPIO_ADC2_PWDN_N,
+	GPIO_EPM_EXPANDER_IO4,
+	GPIO_ADC1_MUX_SPI_INT_N_3_3V,
+	GPIO_ADC2_MUX_SPI_INT_N,
+	GPIO_EPM_EXPANDER_IO7,
+	GPIO_PWR_MON_ENABLE,
+	GPIO_EPM_SPI_ADC1_CS_N,
+	GPIO_EPM_SPI_ADC2_CS_N,
+	GPIO_EPM_EXPANDER_IO11,
+	GPIO_EPM_EXPANDER_IO12,
+	GPIO_EPM_EXPANDER_IO13,
+	GPIO_EPM_EXPANDER_IO14,
+	GPIO_EPM_EXPANDER_IO15,
+};
+
+struct pm8xxx_mpp_init_info {
+	unsigned			mpp;
+	struct pm8xxx_mpp_config_data	config;
+};
+
+#define PM8XXX_MPP_INIT(_mpp, _type, _level, _control) \
+{ \
+	.mpp	= PM8058_MPP_PM_TO_SYS(_mpp), \
+	.config	= { \
+		.type		= PM8XXX_MPP_TYPE_##_type, \
+		.level		= _level, \
+		.control	= PM8XXX_MPP_##_control, \
+	} \
+}
+
+#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT
+static void (*sdc2_status_notify_cb)(int card_present, void *dev_id);
+static void *sdc2_status_notify_cb_devid;
+#endif
+
+/* Speed bin register. */
+#define QFPROM_SPEED_BIN_ADDR		(MSM_QFPROM_BASE + 0x00C0)
+
+/* -----------------------------------------------------------------------------
+*                         External routine declaration
+--------------------------------------------------------------------------------*/
+
+
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+static void (*sdc5_status_notify_cb)(int card_present, void *dev_id);
+static void *sdc5_status_notify_cb_devid;
+#endif
+
+static unsigned int engineerid, mem_size_mb;
+
+unsigned int rider_get_engineerid(void)
+{
+	return engineerid;
+}
+
+#define _GET_REGULATOR(var, name) do {				\
+	var = regulator_get(NULL, name);			\
+	if (IS_ERR(var)) {					\
+		pr_err("'%s' regulator not found, rc=%ld\n",	\
+			name, IS_ERR(var));			\
+		var = NULL;					\
+		return -ENODEV;					\
+	}							\
+} while (0)
+
+static struct msm_spm_platform_data msm_spm_data_v1[] __initdata = {
+	[0] = {
+		.reg_base_addr = MSM_SAW0_BASE,
+
+#ifdef CONFIG_MSM_AVS_HW
+		.reg_init_values[MSM_SPM_REG_SAW_AVS_CTL] = 0x586020FF,
+#endif
+		.reg_init_values[MSM_SPM_REG_SAW_CFG] = 0x0F,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_CTL] = 0x68,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_SLP_TMR_DLY] = 0xFFFFFFFF,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_WAKE_TMR_DLY] = 0xFFFFFFFF,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLK_EN] = 0x11,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_PRECLMP_EN] = 0x07,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_POSTCLMP_EN] = 0x00,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLMP_EN] = 0x01,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_RST_EN] = 0x00,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_MPM_CFG] = 0x00,
+
+		.awake_vlevel = 0x94,
+		.retention_vlevel = 0x81,
+		.collapse_vlevel = 0x20,
+		.retention_mid_vlevel = 0x94,
+		.collapse_mid_vlevel = 0x8C,
+
+		.vctl_timeout_us = 50,
+	},
+
+	[1] = {
+		.reg_base_addr = MSM_SAW1_BASE,
+
+#ifdef CONFIG_MSM_AVS_HW
+		.reg_init_values[MSM_SPM_REG_SAW_AVS_CTL] = 0x586020FF,
+#endif
+		.reg_init_values[MSM_SPM_REG_SAW_CFG] = 0x0F,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_CTL] = 0x68,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_SLP_TMR_DLY] = 0xFFFFFFFF,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_WAKE_TMR_DLY] = 0xFFFFFFFF,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLK_EN] = 0x13,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_PRECLMP_EN] = 0x07,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_POSTCLMP_EN] = 0x00,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLMP_EN] = 0x01,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_RST_EN] = 0x00,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_MPM_CFG] = 0x00,
+
+		.awake_vlevel = 0x94,
+		.retention_vlevel = 0x81,
+		.collapse_vlevel = 0x20,
+		.retention_mid_vlevel = 0x94,
+		.collapse_mid_vlevel = 0x8C,
+
+		.vctl_timeout_us = 50,
+	},
+};
+
+static struct msm_spm_platform_data msm_spm_data[] __initdata = {
+	[0] = {
+		.reg_base_addr = MSM_SAW0_BASE,
+
+#ifdef CONFIG_MSM_AVS_HW
+		.reg_init_values[MSM_SPM_REG_SAW_AVS_CTL] = 0x586020FF,
+#endif
+		.reg_init_values[MSM_SPM_REG_SAW_CFG] = 0x1C,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_CTL] = 0x68,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_SLP_TMR_DLY] = 0x0C0CFFFF,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_WAKE_TMR_DLY] = 0x78780FFF,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLK_EN] = 0x11,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_PRECLMP_EN] = 0x07,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_POSTCLMP_EN] = 0x00,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLMP_EN] = 0x01,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_RST_EN] = 0x00,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_MPM_CFG] = 0x00,
+
+		.awake_vlevel = 0xA0,
+		.retention_vlevel = 0x89,
+		.collapse_vlevel = 0x20,
+		.retention_mid_vlevel = 0x89,
+		.collapse_mid_vlevel = 0x89,
+
+		.vctl_timeout_us = 50,
+	},
+
+	[1] = {
+		.reg_base_addr = MSM_SAW1_BASE,
+
+#ifdef CONFIG_MSM_AVS_HW
+		.reg_init_values[MSM_SPM_REG_SAW_AVS_CTL] = 0x586020FF,
+#endif
+		.reg_init_values[MSM_SPM_REG_SAW_CFG] = 0x1C,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_CTL] = 0x68,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_SLP_TMR_DLY] = 0x0C0CFFFF,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_WAKE_TMR_DLY] = 0x78780FFF,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLK_EN] = 0x13,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_PRECLMP_EN] = 0x07,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_HSFS_POSTCLMP_EN] = 0x00,
+
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_CLMP_EN] = 0x01,
+		.reg_init_values[MSM_SPM_REG_SAW_SLP_RST_EN] = 0x00,
+		.reg_init_values[MSM_SPM_REG_SAW_SPM_MPM_CFG] = 0x00,
+
+		.awake_vlevel = 0xA0,
+		.retention_vlevel = 0x89,
+		.collapse_vlevel = 0x20,
+		.retention_mid_vlevel = 0x89,
+		.collapse_mid_vlevel = 0x89,
+
+		.vctl_timeout_us = 50,
+	},
+};
+
+#ifdef CONFIG_PERFLOCK
+static unsigned rider_perf_acpu_table[] = {
+	540000000,
+	1026000000,
+	1512000000,
+};
+
+static struct perflock_platform_data rider_perflock_data = {
+	.perf_acpu_table = rider_perf_acpu_table,
+	.table_size = ARRAY_SIZE(rider_perf_acpu_table),
+};
+#endif
+
+/*
+ * Consumer specific regulator names:
+ *			 regulator name		consumer dev_name
+ */
+static struct regulator_consumer_supply vreg_consumers_8901_S0[] = {
+	REGULATOR_SUPPLY("8901_s0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_8901_S1[] = {
+	REGULATOR_SUPPLY("8901_s1",		NULL),
+};
+
+static struct regulator_init_data saw_s0_init_data = {
+		.constraints = {
+			.name = "8901_s0",
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.min_uV = 750000,
+			.max_uV = 1350000,
+		},
+		.consumer_supplies = vreg_consumers_8901_S0,
+		.num_consumer_supplies = ARRAY_SIZE(vreg_consumers_8901_S0),
+};
+
+static struct regulator_init_data saw_s1_init_data = {
+		.constraints = {
+			.name = "8901_s1",
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.min_uV = 750000,
+			.max_uV = 1350000,
+		},
+		.consumer_supplies = vreg_consumers_8901_S1,
+		.num_consumer_supplies = ARRAY_SIZE(vreg_consumers_8901_S1),
+};
+
+static struct platform_device msm_device_saw_s0 = {
+	.name          = "saw-regulator",
+	.id            = 0,
+	.dev           = {
+		.platform_data = &saw_s0_init_data,
+	},
+};
+
+static struct platform_device msm_device_saw_s1 = {
+	.name          = "saw-regulator",
+	.id            = 1,
+	.dev           = {
+		.platform_data = &saw_s1_init_data,
+	},
+};
+
+static struct resource smsc911x_resources[] = {
+	[0] = {
+		.flags = IORESOURCE_MEM,
+		.start = 0x1b800000,
+		.end   = 0x1b8000ff
+	},
+	[1] = {
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWLEVEL,
+	},
+};
+
+static struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
+	.flags		= SMSC911X_USE_16BIT,
+	.has_reset_gpio	= 1,
+	.reset_gpio	= GPIO_ETHERNET_RESET_N
+};
+
+static struct platform_device smsc911x_device = {
+	.name          = "smsc911x",
+	.id            = 0,
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource      = smsc911x_resources,
+	.dev           = {
+		.platform_data = &smsc911x_config
+	}
+};
+
+#if defined(CONFIG_CRYPTO_DEV_QCRYPTO) || \
+		defined(CONFIG_CRYPTO_DEV_QCRYPTO_MODULE) || \
+		defined(CONFIG_CRYPTO_DEV_QCEDEV) || \
+		defined(CONFIG_CRYPTO_DEV_QCEDEV_MODULE)
+
+#define QCE_HW_KEY_SUPPORT	0
+#define QCE_SHA_HMAC_SUPPORT	0
+#define QCE_SHARE_CE_RESOURCE	2
+#define QCE_CE_SHARED		1
+
+static struct resource qcrypto_resources[] = {
+	[0] = {
+		.start = QCE_0_BASE,
+		.end = QCE_0_BASE + QCE_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name = "crypto_channels",
+		.start = DMOV_CE_IN_CHAN,
+		.end = DMOV_CE_OUT_CHAN,
+		.flags = IORESOURCE_DMA,
+	},
+	[2] = {
+		.name = "crypto_crci_in",
+		.start = DMOV_CE_IN_CRCI,
+		.end = DMOV_CE_IN_CRCI,
+		.flags = IORESOURCE_DMA,
+	},
+	[3] = {
+		.name = "crypto_crci_out",
+		.start = DMOV_CE_OUT_CRCI,
+		.end = DMOV_CE_OUT_CRCI,
+		.flags = IORESOURCE_DMA,
+	},
+	[4] = {
+		.name = "crypto_crci_hash",
+		.start = DMOV_CE_HASH_CRCI,
+		.end = DMOV_CE_HASH_CRCI,
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+static struct resource qcedev_resources[] = {
+	[0] = {
+		.start = QCE_0_BASE,
+		.end = QCE_0_BASE + QCE_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name = "crypto_channels",
+		.start = DMOV_CE_IN_CHAN,
+		.end = DMOV_CE_OUT_CHAN,
+		.flags = IORESOURCE_DMA,
+	},
+	[2] = {
+		.name = "crypto_crci_in",
+		.start = DMOV_CE_IN_CRCI,
+		.end = DMOV_CE_IN_CRCI,
+		.flags = IORESOURCE_DMA,
+	},
+	[3] = {
+		.name = "crypto_crci_out",
+		.start = DMOV_CE_OUT_CRCI,
+		.end = DMOV_CE_OUT_CRCI,
+		.flags = IORESOURCE_DMA,
+	},
+	[4] = {
+		.name = "crypto_crci_hash",
+		.start = DMOV_CE_HASH_CRCI,
+		.end = DMOV_CE_HASH_CRCI,
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+#endif
+
+#if defined(CONFIG_CRYPTO_DEV_QCRYPTO) || \
+		defined(CONFIG_CRYPTO_DEV_QCRYPTO_MODULE)
+
+static struct msm_ce_hw_support qcrypto_ce_hw_suppport = {
+	.ce_shared = QCE_CE_SHARED,
+	.shared_ce_resource = QCE_SHARE_CE_RESOURCE,
+	.hw_key_support = QCE_HW_KEY_SUPPORT,
+	.sha_hmac = QCE_SHA_HMAC_SUPPORT,
+};
+
+static struct platform_device qcrypto_device = {
+	.name		= "qcrypto",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(qcrypto_resources),
+	.resource	= qcrypto_resources,
+	.dev		= {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &qcrypto_ce_hw_suppport,
+	},
+};
+#endif
+
+#if defined(CONFIG_CRYPTO_DEV_QCEDEV) || \
+		defined(CONFIG_CRYPTO_DEV_QCEDEV_MODULE)
+
+static struct msm_ce_hw_support qcedev_ce_hw_suppport = {
+	.ce_shared = QCE_CE_SHARED,
+	.shared_ce_resource = QCE_SHARE_CE_RESOURCE,
+	.hw_key_support = QCE_HW_KEY_SUPPORT,
+	.sha_hmac = QCE_SHA_HMAC_SUPPORT,
+};
+
+static struct platform_device qcedev_device = {
+	.name		= "qce",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(qcedev_resources),
+	.resource	= qcedev_resources,
+	.dev		= {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &qcedev_ce_hw_suppport,
+	},
+};
+#endif
+
+#if defined(CONFIG_HAPTIC_ISA1200) || \
+		defined(CONFIG_HAPTIC_ISA1200_MODULE)
+
+static const char *vregs_isa1200_name[] = {
+	"8058_s3",
+	"8901_l4",
+};
+
+static const int vregs_isa1200_val[] = {
+	1800000,/* uV */
+	2600000,
+};
+static struct regulator *vregs_isa1200[ARRAY_SIZE(vregs_isa1200_name)];
+static struct msm_xo_voter *xo_handle_a1;
+
+static int isa1200_power(int vreg_on)
+{
+	int i, rc = 0;
+
+	for (i = 0; i < ARRAY_SIZE(vregs_isa1200_name); i++) {
+		rc = vreg_on ? regulator_enable(vregs_isa1200[i]) :
+			regulator_disable(vregs_isa1200[i]);
+		if (rc < 0) {
+			pr_err("%s: vreg %s %s failed (%d)\n",
+				__func__, vregs_isa1200_name[i],
+				vreg_on ? "enable" : "disable", rc);
+			goto vreg_fail;
+		}
+	}
+
+	rc = vreg_on ? msm_xo_mode_vote(xo_handle_a1, MSM_XO_MODE_ON) :
+			msm_xo_mode_vote(xo_handle_a1, MSM_XO_MODE_OFF);
+	if (rc < 0) {
+		pr_err("%s: failed to %svote for TCXO A1 buffer%d\n",
+				__func__, vreg_on ? "" : "de-", rc);
+		goto vreg_fail;
+	}
+	return 0;
+
+vreg_fail:
+	while (i--)
+		!vreg_on ? regulator_enable(vregs_isa1200[i]) :
+			regulator_disable(vregs_isa1200[i]);
+	return rc;
+}
+
+static int isa1200_dev_setup(bool enable)
+{
+	int i, rc;
+
+	if (enable == true) {
+		for (i = 0; i < ARRAY_SIZE(vregs_isa1200_name); i++) {
+			vregs_isa1200[i] = regulator_get(NULL,
+						vregs_isa1200_name[i]);
+			if (IS_ERR(vregs_isa1200[i])) {
+				pr_err("%s: regulator get of %s failed (%ld)\n",
+					__func__, vregs_isa1200_name[i],
+					PTR_ERR(vregs_isa1200[i]));
+				rc = PTR_ERR(vregs_isa1200[i]);
+				goto vreg_get_fail;
+			}
+			rc = regulator_set_voltage(vregs_isa1200[i],
+				vregs_isa1200_val[i], vregs_isa1200_val[i]);
+			if (rc) {
+				pr_err("%s: regulator_set_voltage(%s) failed\n",
+					__func__, vregs_isa1200_name[i]);
+				goto vreg_get_fail;
+			}
+		}
+
+		rc = gpio_request(GPIO_HAP_SHIFT_LVL_OE, "haptics_shft_lvl_oe");
+		if (rc) {
+			pr_err("%s: unable to request gpio %d (%d)\n",
+					__func__, GPIO_HAP_SHIFT_LVL_OE, rc);
+			goto vreg_get_fail;
+		}
+
+		rc = gpio_direction_output(GPIO_HAP_SHIFT_LVL_OE, 1);
+		if (rc) {
+			pr_err("%s: Unable to set direction\n", __func__);;
+			goto free_gpio;
+		}
+
+		xo_handle_a1 = msm_xo_get(MSM_XO_TCXO_A1, "isa1200");
+		if (IS_ERR(xo_handle_a1)) {
+			rc = PTR_ERR(xo_handle_a1);
+			pr_err("%s: failed to get the handle for A1(%d)\n",
+							__func__, rc);
+			goto gpio_set_dir;
+		}
+	} else {
+		gpio_set_value(GPIO_HAP_SHIFT_LVL_OE, 0);
+		gpio_free(GPIO_HAP_SHIFT_LVL_OE);
+
+		for (i = 0; i < ARRAY_SIZE(vregs_isa1200_name); i++)
+			regulator_put(vregs_isa1200[i]);
+
+		msm_xo_put(xo_handle_a1);
+	}
+
+	return 0;
+gpio_set_dir:
+	gpio_set_value(GPIO_HAP_SHIFT_LVL_OE, 0);
+free_gpio:
+	gpio_free(GPIO_HAP_SHIFT_LVL_OE);
+vreg_get_fail:
+	while (i)
+		regulator_put(vregs_isa1200[--i]);
+	return rc;
+}
+
+static struct isa1200_platform_data isa1200_1_pdata = {
+	.name = "vibrator",
+	.power_on = isa1200_power,
+	.dev_setup = isa1200_dev_setup,
+	/*gpio to enable haptic*/
+	.hap_en_gpio = PM8058_GPIO_PM_TO_SYS(RIDER_HAP_ENABLE),
+	.max_timeout = 15000,
+	.mode_ctrl = PWM_GEN_MODE,
+	.pwm_fd = {
+		.pwm_div = 256,
+	},
+	.is_erm = false,
+	.smart_en = true,
+	.ext_clk_en = true,
+	.chip_en = 1,
+};
+
+static struct i2c_board_info msm_isa1200_board_info[] = {
+	{
+		I2C_BOARD_INFO("isa1200_1", 0x90>>1),
+		.platform_data = &isa1200_1_pdata,
+	},
+};
+#endif
+
+static struct msm_pm_platform_data msm_pm_data[MSM_PM_SLEEP_MODE_NR * 2] = {
+	[MSM_PM_MODE(0, MSM_PM_SLEEP_MODE_POWER_COLLAPSE)] = {
+		.suspend_supported = 1,
+		.idle_supported = 1,
+		.suspend_enabled = 1,
+		.idle_enabled = 1,
+		.latency = 4000,
+		.residency = 13000,
+	},
+
+	[MSM_PM_MODE(0, MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE)] = {
+		.idle_supported = 1,
+		.suspend_supported = 1,
+		.suspend_enabled = 1,
+		.idle_enabled = 1,
+		.latency = 500,
+		.residency = 6000,
+	},
+
+	[MSM_PM_MODE(0, MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT)] = {
+		.idle_supported = 1,
+		.suspend_supported = 1,
+		.suspend_enabled = 1,
+		.idle_enabled = 1,
+		.latency = 2,
+		.residency = 0,
+	},
+
+	[MSM_PM_MODE(1, MSM_PM_SLEEP_MODE_POWER_COLLAPSE)] = {
+		.idle_supported = 1,
+		.suspend_supported = 1,
+		.suspend_enabled = 1,
+		.idle_enabled = 1,
+		.latency = 600,
+		.residency = 7200,
+	},
+
+	[MSM_PM_MODE(1, MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE)] = {
+		.idle_supported = 1,
+		.suspend_supported = 1,
+		.suspend_enabled = 1,
+		.idle_enabled = 1,
+		.latency = 500,
+		.residency = 6000,
+	},
+
+	[MSM_PM_MODE(1, MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT)] = {
+		.idle_supported = 1,
+		.suspend_supported = 1,
+		.suspend_enabled = 1,
+		.idle_enabled = 1,
+		.latency = 2,
+		.residency = 0,
+	},
+};
+
+static struct msm_cpuidle_state msm_cstates[] __initdata = {
+	{0, 0, "C0", "WFI",
+		MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT},
+
+	{0, 1, "C1", "STANDALONE_POWER_COLLAPSE",
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE},
+
+	{0, 2, "C2", "POWER_COLLAPSE",
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE},
+
+	{1, 0, "C0", "WFI",
+		MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT},
+
+	{1, 1, "C1", "STANDALONE_POWER_COLLAPSE",
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE},
+};
+
+static struct msm_rpmrs_level msm_rpmrs_levels[] __initdata = {
+	{
+		MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT,
+		MSM_RPMRS_LIMITS(ON, ACTIVE, MAX, ACTIVE),
+		true,
+		1, 8000, 100000, 1,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE,
+		MSM_RPMRS_LIMITS(ON, ACTIVE, MAX, ACTIVE),
+		true,
+		1500, 5000, 60100000, 3000,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(ON, ACTIVE, MAX, ACTIVE),
+		false,
+		1800, 5000, 60350000, 3500,
+	},
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, ACTIVE, MAX, ACTIVE),
+		false,
+		3800, 4500, 65350000, 5500,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(ON, HSFS_OPEN, MAX, ACTIVE),
+		false,
+		2800, 2500, 66850000, 4800,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, HSFS_OPEN, MAX, ACTIVE),
+		false,
+		4800, 2000, 71850000, 6800,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, HSFS_OPEN, ACTIVE, RET_HIGH),
+		false,
+		6800, 500, 75850000, 8800,
+	},
+
+	{
+		MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
+		MSM_RPMRS_LIMITS(OFF, HSFS_OPEN, RET_HIGH, RET_LOW),
+		false,
+		7800, 0, 76350000, 9800,
+	},
+};
+
+#if defined(CONFIG_USB_PEHCI_HCD) || defined(CONFIG_USB_PEHCI_HCD_MODULE)
+
+#define ISP1763_INT_GPIO		117
+#define ISP1763_RST_GPIO		152
+static struct resource isp1763_resources[] = {
+	[0] = {
+		.flags	= IORESOURCE_MEM,
+		.start	= 0x1D000000,
+		.end	= 0x1D005FFF,		/* 24KB */
+	},
+	[1] = {
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+static void __init msm8x60_cfg_isp1763(void)
+{
+	isp1763_resources[1].start = gpio_to_irq(ISP1763_INT_GPIO);
+	isp1763_resources[1].end = gpio_to_irq(ISP1763_INT_GPIO);
+}
+
+static int isp1763_setup_gpio(int enable)
+{
+	int status = 0;
+
+	if (enable) {
+		status = gpio_request(ISP1763_INT_GPIO, "isp1763_usb");
+		if (status) {
+			pr_err("%s:Failed to request GPIO %d\n",
+						__func__, ISP1763_INT_GPIO);
+			return status;
+		}
+		status = gpio_direction_input(ISP1763_INT_GPIO);
+		if (status) {
+			pr_err("%s:Failed to configure GPIO %d\n",
+					__func__, ISP1763_INT_GPIO);
+			goto gpio_free_int;
+		}
+		status = gpio_request(ISP1763_RST_GPIO, "isp1763_usb");
+		if (status) {
+			pr_err("%s:Failed to request GPIO %d\n",
+						__func__, ISP1763_RST_GPIO);
+			goto gpio_free_int;
+		}
+		status = gpio_direction_output(ISP1763_RST_GPIO, 1);
+		if (status) {
+			pr_err("%s:Failed to configure GPIO %d\n",
+					__func__, ISP1763_RST_GPIO);
+			goto gpio_free_rst;
+		}
+		pr_debug("\nISP GPIO configuration done\n");
+		return status;
+	}
+
+gpio_free_rst:
+	gpio_free(ISP1763_RST_GPIO);
+gpio_free_int:
+	gpio_free(ISP1763_INT_GPIO);
+
+	return status;
+}
+static struct isp1763_platform_data isp1763_pdata = {
+	.reset_gpio	= ISP1763_RST_GPIO,
+	.setup_gpio	= isp1763_setup_gpio
+};
+
+static struct platform_device isp1763_device = {
+	.name          = "isp1763_usb",
+	.num_resources = ARRAY_SIZE(isp1763_resources),
+	.resource      = isp1763_resources,
+	.dev           = {
+		.platform_data = &isp1763_pdata
+	}
+};
+#endif
+
+#if defined(CONFIG_USB_GADGET_MSM_72K) || defined(CONFIG_USB_EHCI_MSM_72K)
+static struct regulator *ldo6_3p3;
+static struct regulator *ldo7_1p8;
+static struct regulator *vdd_cx;
+#define PMICID_INT		PM8058_GPIO_IRQ(PM8058_IRQ_BASE, 36)
+notify_vbus_state notify_vbus_state_func_ptr;
+static int usb_phy_susp_dig_vol = 750000;
+static int pmic_id_notif_supported;
+
+#ifdef CONFIG_USB_EHCI_MSM_72K
+#define USB_PMIC_ID_DET_DELAY	msecs_to_jiffies(100)
+struct delayed_work pmic_id_det;
+
+static int __init usb_id_pin_rework_setup(char *support)
+{
+	if (strncmp(support, "true", 4) == 0)
+		pmic_id_notif_supported = 1;
+
+	return 1;
+}
+__setup("usb_id_pin_rework=", usb_id_pin_rework_setup);
+
+static void pmic_id_detect(struct work_struct *w)
+{
+	int val = gpio_get_value_cansleep(PM8058_GPIO_PM_TO_SYS(36));
+	pr_debug("%s(): gpio_read_value = %d\n", __func__, val);
+
+	if (notify_vbus_state_func_ptr)
+		(*notify_vbus_state_func_ptr) (val);
+}
+
+static irqreturn_t pmic_id_on_irq(int irq, void *data)
+{
+	/*
+	 * Spurious interrupts are observed on pmic gpio line
+	 * even though there is no state change on USB ID. Schedule the
+	 * work to to allow debounce on gpio
+	 */
+	schedule_delayed_work(&pmic_id_det, USB_PMIC_ID_DET_DELAY);
+
+	return IRQ_HANDLED;
+}
+
+static int msm_hsusb_pmic_id_notif_init(void (*callback)(int online), int init)
+{
+	unsigned ret = -ENODEV;
+
+	if (!callback)
+		return -EINVAL;
+
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) != 2) {
+		pr_debug("%s: USB_ID pin is not routed to PMIC"
+					"on V1 surf/ffa\n", __func__);
+		return -ENOTSUPP;
+	}
+
+	usb_phy_susp_dig_vol = 500000;
+
+	if (init) {
+		notify_vbus_state_func_ptr = callback;
+		ret = pm8901_mpp_config_digital_out(1,
+			PM8901_MPP_DIG_LEVEL_L5, 1);
+		if (ret) {
+			pr_err("%s: MPP2 configuration failed\n", __func__);
+			return -ENODEV;
+		}
+		INIT_DELAYED_WORK(&pmic_id_det, pmic_id_detect);
+		ret = request_threaded_irq(PMICID_INT, NULL, pmic_id_on_irq,
+			(IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING),
+						"msm_otg_id", NULL);
+		if (ret) {
+			pm8901_mpp_config_digital_out(1,
+					PM8901_MPP_DIG_LEVEL_L5, 0);
+			pr_err("%s:pmic_usb_id interrupt registration failed",
+					__func__);
+			return ret;
+		}
+		/* Notify the initial Id status */
+		pmic_id_detect(&pmic_id_det.work);
+	} else {
+		free_irq(PMICID_INT, 0);
+		cancel_delayed_work_sync(&pmic_id_det);
+		notify_vbus_state_func_ptr = NULL;
+		ret = pm8901_mpp_config_digital_out(1,
+			PM8901_MPP_DIG_LEVEL_L5, 0);
+		if (ret) {
+			pr_err("%s:MPP2 configuration failed\n", __func__);
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+#endif
+#endif
+#ifdef CONFIG_USB_EHCI_MSM_72K
+#if defined(CONFIG_SMB137B_CHARGER) || defined(CONFIG_SMB137B_CHARGER_MODULE)
+static void msm_hsusb_smb137b_vbus_power(unsigned phy_info, int on)
+{
+	static int vbus_is_on;
+
+	/* If VBUS is already on (or off), do nothing. */
+	if (on == vbus_is_on)
+		return;
+	smb137b_otg_power(on);
+	vbus_is_on = on;
+}
+#endif
+static struct msm_usb_host_platform_data msm_usb_host_pdata = {
+	.phy_info	= (USB_PHY_INTEGRATED | USB_PHY_MODEL_45NM),
+	.power_budget	= 390,
+};
+#endif
+/* static void msm_hsusb_vbus_power(unsigned phy_info, int on) */
+static void msm_hsusb_vbus_power(bool on)
+{
+	static struct regulator *votg_5v_switch;
+	static struct regulator *ext_5v_reg;
+	static int vbus_is_on;
+
+	/* If VBUS is already on (or off), do nothing. */
+	if (on == vbus_is_on)
+		return;
+
+	if (!votg_5v_switch) {
+		votg_5v_switch = regulator_get(NULL, "8901_usb_otg");
+		if (IS_ERR(votg_5v_switch)) {
+			pr_err("%s: unable to get votg_5v_switch\n", __func__);
+			return;
+		}
+	}
+	if (!ext_5v_reg) {
+		ext_5v_reg = regulator_get(NULL, "8901_mpp0");
+		if (IS_ERR(ext_5v_reg)) {
+			pr_err("%s: unable to get ext_5v_reg\n", __func__);
+			return;
+		}
+	}
+	if (on) {
+		if (regulator_enable(ext_5v_reg)) {
+			pr_err("%s: Unable to enable the regulator:"
+					" ext_5v_reg\n", __func__);
+			return;
+		}
+		if (regulator_enable(votg_5v_switch)) {
+			pr_err("%s: Unable to enable the regulator:"
+					" votg_5v_switch\n", __func__);
+			return;
+		}
+	} else {
+		if (regulator_disable(votg_5v_switch))
+			pr_err("%s: Unable to enable the regulator:"
+				" votg_5v_switch\n", __func__);
+		if (regulator_disable(ext_5v_reg))
+			pr_err("%s: Unable to enable the regulator:"
+				" ext_5v_reg\n", __func__);
+	}
+
+	vbus_is_on = on;
+}
+
+/*
+static uint32_t usb_uart_switch_table[] = {
+	GPIO_CFG(RIDER_GPIO_CPU_WIMAX_UART_EN, 0, GPIO_CFG_OUTPUT,
+		GPIO_CFG_NO_PULL, GPIO_CFG_2MA)
+};
+
+static void config_rider_usb_uart_gpios(int uart)
+{
+	config_gpio_table(usb_uart_switch_table, ARRAY_SIZE(usb_uart_switch_table));
+	printk("%s: %d\n", __func__, uart);
+	if (uart) {
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_UART_EN, 0);
+	} else {
+		gpio_set_value(RIDER_GPIO_CPU_WIMAX_UART_EN, 1);
+	}
+}
+*/
+
+/* ToDo: mark it */
+/* #if defined(CONFIG_USB_GADGET_MSM_72K) || defined(CONFIG_USB_EHCI_MSM_72K) */
+static int rider_phy_init_seq[] = { 0x06, 0x36, 0x0C, 0x31, 0x31, 0x32, 0x1, 0x0E, 0x1, 0x11, -1 };
+static struct msm_otg_platform_data msm_otg_pdata = {
+	.phy_init_seq		= rider_phy_init_seq,
+	.mode			= USB_OTG,
+	.otg_control		= OTG_PMIC_CONTROL,
+	.phy_type		= SNPS_28NM_INTEGRATED_PHY,
+	.vbus_power		= msm_hsusb_vbus_power,
+	.power_budget		= 750,
+	.ldo_3v3_name	= "8058_l6",
+	.ldo_1v8_name	= "8058_l7",
+	.phy_type = CI_45NM_INTEGRATED_PHY,
+};
+/* #endif */
+
+#ifdef CONFIG_USB_GADGET_MSM_72K
+static struct msm_hsusb_gadget_platform_data msm_gadget_pdata = {
+	.is_phy_status_timer_on = 1,
+};
+#endif
+
+#ifdef CONFIG_USB_G_ANDROID
+
+#define PID_MAGIC_ID		0x71432909
+#define SERIAL_NUM_MAGIC_ID	0x61945374
+#define SERIAL_NUMBER_LENGTH	127
+#define DLOAD_USB_BASE_ADD	0x2A05F0C8
+
+struct magic_num_struct {
+	uint32_t pid;
+	uint32_t serial_num;
+};
+
+struct dload_struct {
+	uint32_t	reserved1;
+	uint32_t	reserved2;
+	uint32_t	reserved3;
+	uint16_t	reserved4;
+	uint16_t	pid;
+	char		serial_number[SERIAL_NUMBER_LENGTH];
+	uint16_t	reserved5;
+	struct magic_num_struct
+			magic_struct;
+};
+
+static int usb_diag_update_pid_and_serial_num(uint32_t pid, const char *snum)
+{
+	struct dload_struct __iomem *dload = 0;
+
+	dload = ioremap(DLOAD_USB_BASE_ADD, sizeof(*dload));
+	if (!dload) {
+		pr_err("%s: cannot remap I/O memory region: %08x\n",
+					__func__, DLOAD_USB_BASE_ADD);
+		return -ENXIO;
+	}
+
+	pr_debug("%s: dload:%p pid:%x serial_num:%s\n",
+				__func__, dload, pid, snum);
+	/* update pid */
+	dload->magic_struct.pid = PID_MAGIC_ID;
+	dload->pid = pid;
+
+	/* update serial number */
+	dload->magic_struct.serial_num = 0;
+	if (!snum)
+		return 0;
+
+	dload->magic_struct.serial_num = SERIAL_NUM_MAGIC_ID;
+	strncpy(dload->serial_number, snum, SERIAL_NUMBER_LENGTH);
+	dload->serial_number[SERIAL_NUMBER_LENGTH - 1] = '\0';
+
+	iounmap(dload);
+
+	return 0;
+}
+
+static struct usb_mass_storage_platform_data mass_storage_pdata = {
+	.nluns		= 1,
+	.vendor		= "HTC",
+	.product	= "Android Phone",
+};
+
+static struct platform_device usb_mass_storage_device = {
+	.name	= "usb_mass_storage",
+	.id	= -1,
+	.dev	= {
+	.platform_data = &mass_storage_pdata,
+	},
+};
+
+static struct android_usb_platform_data android_usb_pdata = {
+	.vendor_id	= 0x0BB4,
+	.product_id	= 0x0cbe,
+	.version	= 0x0100,
+	.product_name		= "Android Phone",
+	.manufacturer_name	= "HTC",
+	.num_products = ARRAY_SIZE(usb_products),
+	.products = usb_products,
+	.num_functions = ARRAY_SIZE(usb_functions_all),
+	.functions = usb_functions_all,
+	.update_pid_and_serial_num = usb_diag_update_pid_and_serial_num,
+	.fserial_init_string = "tty:modem,tty,tty:serial",
+	.nluns = 1,
+};
+
+static struct platform_device android_usb_device = {
+	.name	= "android_usb",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &android_usb_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_MSM_VPE
+static struct resource msm_vpe_resources[] = {
+	{
+		.start	= 0x05300000,
+		.end	= 0x05300000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= INT_VPE,
+		.end	= INT_VPE,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device msm_vpe_device = {
+	.name = "msm_vpe",
+	.id   = 0,
+	.num_resources = ARRAY_SIZE(msm_vpe_resources),
+	.resource = msm_vpe_resources,
+};
+#endif
+
+#ifdef CONFIG_HTC_BATT8x60
+static struct htc_battery_platform_data htc_battery_pdev_data = {
+	.guage_driver = GUAGE_NONE,
+	.gpio_mbat_in = MSM_GPIO_TO_INT(RIDER_GPIO_MBAT_IN),
+	.gpio_mbat_in_trigger_level = MBAT_IN_HIGH_TRIGGER,
+	.charger = SWITCH_CHARGER_TPS65200,
+	.mpp_data = {
+		{PM8058_MPP_PM_TO_SYS(XOADC_MPP_3), PM_MPP_AIN_AMUX_CH6},
+		{PM8058_MPP_PM_TO_SYS(XOADC_MPP_5), PM_MPP_AIN_AMUX_CH6},
+		{PM8058_MPP_PM_TO_SYS(XOADC_MPP_7), PM_MPP_AIN_AMUX_CH6},
+		{PM8058_MPP_PM_TO_SYS(XOADC_MPP_8), PM_MPP_AIN_AMUX_CH6},
+       },
+};
+
+static struct platform_device htc_battery_pdev = {
+	.name = "htc_battery",
+	.id = -1,
+	.dev    = {
+	.platform_data = &htc_battery_pdev_data,
+	},
+};
+#endif
+
+static void config_gpio_table(uint32_t *table, int len)
+{
+	int n, rc;
+	for (n = 0; n < len; n++) {
+		rc = gpio_tlmm_config(table[n], GPIO_CFG_ENABLE);
+		if (rc) {
+			pr_err("[CAM] %s: gpio_tlmm_config(%#x)=%d\n",
+				__func__, table[n], rc);
+			break;
+		}
+	}
+}
+
+#ifdef CONFIG_MSM_CAMERA
+static uint32_t camera_off_gpio_table[] = {
+	GPIO_CFG(RIDER_CAM_I2C_SDA, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_CAM_I2C_SCL, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(32, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_16MA),
+	GPIO_CFG(RIDER_CAM_ID, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA)
+};
+
+static uint32_t camera_on_gpio_table[] = {
+	GPIO_CFG(RIDER_CAM_I2C_SDA, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_CAM_I2C_SCL, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(32, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_16MA),
+	GPIO_CFG(RIDER_CAM_ID, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA)
+};
+
+static struct regulator *rider_reg_8901_l0 = NULL;
+static struct regulator *rider_reg_8058_l8 = NULL;
+static struct regulator *rider_reg_8058_l9 = NULL;
+static struct regulator *rider_reg_8058_l10 = NULL;
+static struct regulator *rider_reg_8058_l15 = NULL;
+static struct regulator *rider_reg_8058_l24 = NULL;
+static struct regulator *votg_2_8v_switch = NULL;
+
+static int camera_sensor_power_enable(char *power, unsigned volt, struct regulator **sensor_power)
+{
+	int rc;
+	if (power == NULL)
+		return -ENODEV;
+
+	*sensor_power = regulator_get(NULL, power);
+	if (IS_ERR(sensor_power)) {
+		pr_err("[CAM] %s: Unable to get %s\n", __func__, power);
+		return -ENODEV;
+	}
+	rc = regulator_set_voltage(*sensor_power, volt, volt);
+	if (rc) {
+		pr_err("[CAM] %s: unable to set %s voltage to %d rc:%d\n",
+			__func__, power, volt, rc);
+		regulator_put(*sensor_power);
+		*sensor_power = NULL;
+		return -ENODEV;
+	}
+	rc = regulator_enable(*sensor_power);
+	if (rc) {
+		pr_err("[CAM] %s: Enable regulator %s failed\n", __func__, power);
+		regulator_put(*sensor_power);
+		*sensor_power = NULL;
+	}
+
+	return rc;
+}
+
+
+static int camera_sensor_power_disable(struct regulator *sensor_power)
+{
+	int rc;
+	if (sensor_power == NULL)
+		return -ENODEV;
+
+	if (IS_ERR(sensor_power)) {
+		pr_err("[CAM] %s: Invalid regulator ptr\n", __func__);
+		return -ENODEV;
+	}
+	rc = regulator_disable(sensor_power);
+	if (rc)
+		pr_err("[CAM] %s: Disable regulator failed\n", __func__);
+
+	regulator_put(sensor_power);
+	sensor_power = NULL;
+	return rc;
+
+}
+
+#ifdef CONFIG_S5K3H2YX
+static int Rider_s5k3h2yx_vreg_on(void)
+{
+	int rc;
+	pr_info("[CAM] %s\n", __func__);
+
+	/* VCM */
+	rc = camera_sensor_power_enable("8058_l10", 2850000, &rider_reg_8058_l10);
+	pr_info("[CAM] sensor_power_enable(\"8058_l10\", 2.85V) == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	/* IO */
+	rc = camera_sensor_power_enable("8058_l8", 1800000, &rider_reg_8058_l8);
+	pr_info("[CAM] sensor_power_enable(\"8058_l8\", 1.8V) == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	/* analog */
+	rc = camera_sensor_power_enable("8058_l15", 2800000, &rider_reg_8058_l15);
+	pr_info("[CAM] sensor_power_enable(\"8058_l15\", 2.8V) == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	votg_2_8v_switch = regulator_get(NULL, "8901_usb_otg");
+	if (IS_ERR(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: unable to get votg_2_8v_switch\n", __func__);
+		goto init_fail;
+	}
+	if (regulator_enable(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: Unable to enable the regulator: votg_2_8v_switch\n", __func__);
+		regulator_put(votg_2_8v_switch);
+		votg_2_8v_switch = NULL;
+		goto init_fail;
+	}
+
+	udelay(50);
+
+	/* digital */
+	if (system_rev == 0x80) {
+		rc = camera_sensor_power_enable("8901_l0", 1200000, &rider_reg_8901_l0);
+		pr_info("[CAM] sensor_power_enable(\"8901_l0\", 1.2V) == %d\n", rc);
+	} else {
+		rc = camera_sensor_power_enable("8058_l24", 1200000, &rider_reg_8058_l24);
+		pr_info("[CAM] sensor_power_enable(\"8058_l24\", 1.2V) == %d\n", rc);
+	}
+
+init_fail:
+	return rc;
+}
+
+static int Rider_s5k3h2yx_vreg_off(void)
+{
+	int rc = 0;
+	pr_info("[CAM] %s\n", __func__);
+
+	/* VCM */
+	rc = camera_sensor_power_disable(rider_reg_8058_l10);
+	pr_info("[CAM] sensor_power_disable(\"8058_l10\") == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	/* digital */
+	if (system_rev == 0x80) {
+		rc = camera_sensor_power_disable(rider_reg_8901_l0);
+		pr_info("[CAM] sensor_power_disable(\"8901_l0\") == %d\n", rc);
+	} else {
+		rc = camera_sensor_power_disable(rider_reg_8058_l24);
+		pr_info("[CAM] sensor_power_disable(\"8058_l24\") == %d\n", rc);
+	}
+
+	if (rc < 0)
+		goto init_fail;
+
+	/* analog */
+	rc = camera_sensor_power_disable(rider_reg_8058_l15);
+	pr_info("[CAM] sensor_power_disable(\"8058_l15\") == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	if ((votg_2_8v_switch == NULL) || IS_ERR(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: unable to get votg_2_8v_switch\n", __func__);
+		goto init_fail;
+	}
+	if (regulator_disable(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: Unable to disable the regulator: votg_2_8v_switch\n", __func__);
+		regulator_put(votg_2_8v_switch);
+		votg_2_8v_switch = NULL;
+		goto init_fail;
+	}
+	regulator_put(votg_2_8v_switch);
+	votg_2_8v_switch = NULL;
+
+	udelay(50);
+
+	/* IO */
+	rc = camera_sensor_power_disable(rider_reg_8058_l8);
+	pr_info("[CAM] sensor_power_disable(\"8058_l8\") == %d\n", rc);
+
+init_fail:
+	return rc;
+}
+#endif
+
+#ifdef CONFIG_OV8830
+static int Rider_ov8830_vreg_on(void)
+{
+	int rc;
+	pr_info("[CAM] %s\n", __func__);
+
+	/* VCM */
+	rc = camera_sensor_power_enable("8058_l10", 2850000, &rider_reg_8058_l10);
+	pr_info("[CAM] sensor_power_enable(\"8058_l10\", 2.85V) == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	/* analog */
+	rc = camera_sensor_power_enable("8058_l15", 2800000, &rider_reg_8058_l15);
+	pr_info("[CAM] sensor_power_enable(\"8058_l15\", 2.8V) == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	votg_2_8v_switch = regulator_get(NULL, "8901_usb_otg");
+	if (IS_ERR(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: unable to get votg_2_8v_switch\n", __func__);
+		goto init_fail;
+	}
+
+	if (regulator_enable(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: Unable to enable the regulator: votg_2_8v_switch\n", __func__);
+		regulator_put(votg_2_8v_switch);
+		votg_2_8v_switch = NULL;
+		goto init_fail;
+	}
+
+	msleep(10);
+
+	/* IO */
+	rc = camera_sensor_power_enable("8058_l8", 1800000, &rider_reg_8058_l8);
+	pr_info("[CAM] sensor_power_enable(\"8058_l8\", 1.8V) == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	msleep(10);
+
+	pr_info("Rider_ov8830_vreg_on,end");
+
+init_fail:
+	return rc;
+}
+
+static int Rider_ov8830_vreg_off(void)
+{
+	int rc = 0;
+	pr_info("[CAM] %s\n", __func__);
+
+	rc = camera_sensor_power_disable(rider_reg_8058_l10);
+	pr_info("[CAM]sensor_power_disable(\"8058_l10\") == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+
+	/* IO */
+	rc = camera_sensor_power_disable(rider_reg_8058_l8);
+	pr_info("[CAM] sensor_power_disable(\"8058_l8\") == %d\n", rc);
+
+	if (rc < 0)
+		goto init_fail;
+
+	/* analog */
+	rc = camera_sensor_power_disable(rider_reg_8058_l15);
+
+	if (rc < 0)
+		goto init_fail;
+
+	if ((votg_2_8v_switch == NULL) || IS_ERR(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: unable to get votg_2_8v_switch\n", __func__);
+		goto init_fail;
+	}
+	if (regulator_disable(votg_2_8v_switch)) {
+		pr_err("[CAM] %s: Unable to disable the regulator: votg_2_8v_switch\n", __func__);
+		regulator_put(votg_2_8v_switch);
+		votg_2_8v_switch = NULL;
+		goto init_fail;
+	}
+	regulator_put(votg_2_8v_switch);
+	votg_2_8v_switch = NULL;
+
+	udelay(50);
+
+init_fail:
+	return rc;
+}
+#endif
+
+static void Rider_maincam_clk_switch(void);
+#ifdef CONFIG_S5K6AAFX
+static int Rider_s5k6aafx_vreg_on(void)
+{
+	int rc;
+	pr_info("[CAM] %s\n", __func__);
+
+	/* analog */
+	rc = camera_sensor_power_enable("8058_l15", 2800000, &rider_reg_8058_l15);
+	pr_info("[CAM] sensor_power_enable(\"8058_l15\", 2.8V) == %d\n", rc);
+
+	mdelay(5);
+
+	/* digital */
+	rc = camera_sensor_power_enable("8058_l9", 1800000, &rider_reg_8058_l9);
+	pr_info("[CAM] sensor_power_enable(\"8058_l9\", 1.8V) == %d\n", rc);
+
+	mdelay(5);
+
+	/* IO */
+	rc = camera_sensor_power_enable("8058_l8", 1800000, &rider_reg_8058_l8);
+	pr_info("[CAM] sensor_power_enable(\"8058_l8\", 1.8V) == %d\n", rc);
+
+	mdelay(1);
+
+	return rc;
+}
+
+static int Rider_s5k6aafx_vreg_off(void)
+{
+	int rc;
+	pr_info("[CAM] %s\n", __func__);
+
+	/* IO */
+	rc = camera_sensor_power_disable(rider_reg_8058_l8);
+	pr_info("[CAM] sensor_power_disable(\"8058_l8\") == %d\n", rc);
+	mdelay(1);
+
+	/* digital */
+	rc = camera_sensor_power_disable(rider_reg_8058_l9);
+	pr_info("[CAM] sensor_power_disable(\"8058_l9\") == %d\n", rc);
+	mdelay(1);
+
+	/* analog */
+	rc = camera_sensor_power_disable(rider_reg_8058_l15);
+	pr_info("[CAM] sensor_power_disable(\"8058_l15\") == %d\n", rc);
+
+	Rider_maincam_clk_switch();
+	return rc;
+}
+#endif
+#define CLK_SWITCH 141
+static void Rider_maincam_clk_switch(void)
+{
+	int rc = 0;
+	pr_info("[CAM] Doing clk switch (Main Cam)\n");
+	rc = gpio_request(CLK_SWITCH, "s5k3h2yx");
+	if (rc < 0)
+		pr_err("[CAM] GPIO (%d) request fail\n", CLK_SWITCH);
+	else
+		gpio_direction_output(CLK_SWITCH, 0);
+	gpio_free(CLK_SWITCH);
+	return;
+}
+
+static void Rider_seccam_clk_switch(void)
+{
+	int rc = 0;
+	pr_info("[CAM] Doing clk switch (2nd Cam)\n");
+	rc = gpio_request(CLK_SWITCH, "s5k6aafx");
+
+	if (rc < 0)
+		pr_err("[CAM] GPIO (%d) request fail\n", CLK_SWITCH);
+	else
+		gpio_direction_output(CLK_SWITCH, 1);
+
+	gpio_free(CLK_SWITCH);
+	return;
+}
+
+static int rider_config_camera_on_gpios(void)
+{
+	config_gpio_table(camera_on_gpio_table,
+		ARRAY_SIZE(camera_on_gpio_table));
+	return 0;
+}
+
+static void rider_config_camera_off_gpios(void)
+{
+	config_gpio_table(camera_off_gpio_table,
+		ARRAY_SIZE(camera_off_gpio_table));
+}
+
+static int config_camera_on_gpios_web_cam(void)
+{
+	config_gpio_table(camera_on_gpio_table,
+		ARRAY_SIZE(camera_on_gpio_table));
+	return 0;
+}
+
+static void config_camera_off_gpios_web_cam(void)
+{
+	config_gpio_table(camera_off_gpio_table,
+		ARRAY_SIZE(camera_off_gpio_table));
+
+}
+
+static struct msm_camera_device_platform_data msm_camera_device_data = {
+	.camera_gpio_on  = rider_config_camera_on_gpios,
+	.camera_gpio_off = rider_config_camera_off_gpios,
+	.ioext.csiphy = 0x04800000,
+	.ioext.csisz  = 0x00000400,
+	.ioext.csiirq = CSI_0_IRQ,
+	.ioclk.mclk_clk_rate = 24000000,
+	.ioclk.vfe_clk_rate  = 266667000,
+};
+
+static struct msm_camera_device_platform_data msm_camera_device_data_web_cam = {
+	.camera_gpio_on  = config_camera_on_gpios_web_cam,
+	.camera_gpio_off = config_camera_off_gpios_web_cam,
+	.ioext.csiphy = 0x04900000,
+	.ioext.csisz  = 0x00000400,
+	.ioext.csiirq = CSI_1_IRQ,
+	.ioclk.mclk_clk_rate = 24000000,
+	.ioclk.vfe_clk_rate  = 228570000,
+};
+
+struct resource msm_camera_resources[] = {
+	{
+		.start	= 0x04500000,
+		.end	= 0x04500000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= VFE_IRQ,
+		.end	= VFE_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+int aat1277_flashlight_control(int mode);
+static int flashlight_control(int mode)
+{
+#ifdef CONFIG_ARCH_MSM_FLASHLIGHT
+	return aat1277_flashlight_control(mode);
+#else
+	return 0;
+#endif
+}
+
+static struct msm_camera_sensor_flash_src msm_flash_src = {
+	.flash_sr_type				= MSM_CAMERA_FLASH_SRC_CURRENT_DRIVER,
+	.camera_flash				= flashlight_control,
+};
+
+static struct camera_flash_cfg msm_camera_sensor_flash_cfg = {
+	.low_temp_limit		= 10,
+	.low_cap_limit		= 5,
+};
+
+#ifdef CONFIG_S5K3H2YX
+static struct msm_camera_sensor_flash_data flash_s5k3h2yx = {
+	.flash_type		= MSM_CAMERA_FLASH_LED,
+	.flash_src		= &msm_flash_src
+};
+
+static struct msm_camera_sensor_info msm_camera_sensor_s5k3h2yx_data = {
+	.sensor_name	= "s5k3h2yx",
+	.sensor_reset = 0,
+	.sensor_pwd = 107,
+	.vcm_pwd = 58,
+	.vcm_enable = 1,
+	.camera_power_on = Rider_s5k3h2yx_vreg_on,
+	.camera_power_off = Rider_s5k3h2yx_vreg_off,
+	.camera_clk_switch = Rider_maincam_clk_switch,
+	.pdata = &msm_camera_device_data,
+	.resource = msm_camera_resources,
+	.num_resources = ARRAY_SIZE(msm_camera_resources),
+	.flash_data = &flash_s5k3h2yx,
+	.flash_cfg = &msm_camera_sensor_flash_cfg,
+	.mirror_mode = 1,
+	.csi_if			= 1,
+	.dev_node		= 0
+};
+
+static struct platform_device msm_camera_sensor_s5k3h2yx = {
+	.name	= "msm_camera_s5k3h2yx",
+	.dev	= {
+		.platform_data = &msm_camera_sensor_s5k3h2yx_data,
+	},
+};
+#endif
+
+#ifdef CONFIG_OV8830
+static struct msm_camera_sensor_flash_data flash_ov8830 = {
+	.flash_type		= MSM_CAMERA_FLASH_LED,
+	.flash_src		= &msm_flash_src
+};
+
+
+static struct msm_camera_sensor_info msm_camera_sensor_ov8830_data = {
+	.sensor_name	= "ov8830",
+	.sensor_reset	=	0,
+	.sensor_pwd	= 107,
+	.vcm_pwd = 58,
+	.vcm_enable = 1,
+	.camera_power_on = Rider_ov8830_vreg_on,
+	.camera_power_off = Rider_ov8830_vreg_off,
+	.camera_clk_switch	= Rider_maincam_clk_switch,
+	.pdata = &msm_camera_device_data,
+	.resource = msm_camera_resources,
+	.num_resources = ARRAY_SIZE(msm_camera_resources),
+	.flash_data = &flash_ov8830,
+	.flash_cfg	= &msm_camera_sensor_flash_cfg,
+	.mirror_mode = 1,
+	.csi_if			= 1,
+	.dev_node		= 0
+};
+
+static struct platform_device msm_camera_sensor_ov8830 = {
+    .name	= "msm_camera_ov8830",
+    .dev	= {
+			.platform_data = &msm_camera_sensor_ov8830_data,
+    },
+};
+#endif
+
+#ifdef CONFIG_S5K6AAFX
+static struct msm_camera_sensor_flash_data flash_s5k6aafx = {
+	.flash_type		= MSM_CAMERA_FLASH_NONE,
+};
+
+static struct msm_camera_sensor_info msm_camera_sensor_s5k6aafx_data = {
+	.sensor_name	= "s5k6aafx",
+	.sensor_reset = 138,
+	.sensor_pwd = 140,
+	.vcm_enable = 0,
+	.camera_power_on	 = Rider_s5k6aafx_vreg_on,
+	.camera_power_off = Rider_s5k6aafx_vreg_off,
+	.camera_clk_switch = Rider_seccam_clk_switch,
+	.pdata = &msm_camera_device_data_web_cam,
+	.resource = msm_camera_resources,
+	.num_resources = ARRAY_SIZE(msm_camera_resources),
+	.flash_data = &flash_s5k6aafx,
+	.mirror_mode = 0,
+	.csi_if			= 1,
+	.dev_node		= 1,
+};
+
+static void __init msm8x60_init_camera(void)
+{
+	msm_camera_sensor_webcam.name = "msm_camera_webcam";
+	msm_camera_sensor_webcam.dev.platform_data = &msm_camera_sensor_s5k6aafx_data;
+}
+#endif
+
+#ifdef CONFIG_MSM_CAMERA
+static struct i2c_board_info msm_camera_boardinfo[] __initdata = {
+#ifdef CONFIG_S5K3H2YX
+	{
+		I2C_BOARD_INFO("s5k3h2yx", 0x20 >> 1),
+	},
+#endif
+#ifdef CONFIG_S5K6AAFX
+	{
+		I2C_BOARD_INFO("s5k6aafx", 0x78 >> 1),
+	},
+#endif
+	{
+		I2C_BOARD_INFO("s5k6aafx", 0x5a >> 1),
+	},
+};
+#endif
+
+static struct i2c_board_info msm_camera_boardinfo_OV8830[] __initdata = {
+#ifdef CONFIG_OV8830
+	{
+		I2C_BOARD_INFO("ov8830", 0x20 >> 1),
+	},
+#endif
+#ifdef CONFIG_S5K6AAFX
+	{
+		I2C_BOARD_INFO("s5k6aafx", 0x78 >> 1),
+	},
+#endif
+	{
+		I2C_BOARD_INFO("s5k6aafx", 0x5a >> 1),
+	},
+};
+#endif
+
+#ifdef CONFIG_MSM_GEMINI
+static struct resource msm_gemini_resources[] = {
+	{
+		.start  = 0x04600000,
+		.end    = 0x04600000 + SZ_1M - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_JPEG,
+		.end    = INT_JPEG,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device msm_gemini_device = {
+	.name           = "msm_gemini",
+	.resource       = msm_gemini_resources,
+	.num_resources  = ARRAY_SIZE(msm_gemini_resources),
+};
+#endif
+
+#ifdef CONFIG_TPS65200
+static struct tps65200_platform_data tps65200_data = {
+	.charger_check = 1,
+	.gpio_chg_stat = PM8058_GPIO_IRQ(PM8058_IRQ_BASE, RIDER_CHG_STAT),
+	.gpio_chg_int  = MSM_GPIO_TO_INT(RIDER_GPIO_CHG_INT),
+};
+
+#ifdef CONFIG_SUPPORT_DQ_BATTERY
+static int __init check_dq_setup(char *str)
+{
+	if (!strcmp(str, "PASS"))
+		tps65200_data.dq_result = 1;
+	else
+		tps65200_data.dq_result = 0;
+
+	return 1;
+}
+__setup("androidboot.dq=", check_dq_setup);
+#endif
+
+static struct i2c_board_info msm_tps_65200_boardinfo[] __initdata = {
+	{
+		I2C_BOARD_INFO("tps65200", 0xD4 >> 1),
+		.platform_data = &tps65200_data,
+	},
+};
+#endif
+
+#ifdef CONFIG_I2C_QUP
+
+static uint32_t gsbi4_gpio_table[] = {
+	GPIO_CFG(RIDER_CAM_I2C_SDA, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_CAM_I2C_SCL, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static uint32_t gsbi4_gpio_table_gpio[] = {
+	GPIO_CFG(RIDER_CAM_I2C_SDA, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_CAM_I2C_SCL, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static uint32_t gsbi5_gpio_table[] = {
+	GPIO_CFG(RIDER_TP_I2C_SDA, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_TP_I2C_SCL, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static uint32_t gsbi5_gpio_table_gpio[] = {
+	GPIO_CFG(RIDER_TP_I2C_SDA, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_TP_I2C_SCL, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static uint32_t gsbi7_gpio_table[] = {
+	GPIO_CFG(RIDER_GENERAL_I2C_SDA, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_GENERAL_I2C_SCL, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static uint32_t gsbi7_gpio_table_gpio[] = {
+	GPIO_CFG(RIDER_GENERAL_I2C_SDA, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_GENERAL_I2C_SCL, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static uint32_t gsbi10_gpio_table[] = {
+	GPIO_CFG(RIDER_SENSOR_I2C_SDA, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIOMUX_DRV_8MA),
+	GPIO_CFG(RIDER_SENSOR_I2C_SCL, 1, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIOMUX_DRV_8MA),
+};
+
+static uint32_t gsbi10_gpio_table_gpio[] = {
+	GPIO_CFG(RIDER_SENSOR_I2C_SDA, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+	GPIO_CFG(RIDER_SENSOR_I2C_SCL, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_8MA),
+};
+
+static void gsbi_qup_i2c_gpio_config(int adap_id, int config_type)
+{
+	printk(KERN_INFO "%s(): adap_id = %d, config_type = %d \n", __func__, adap_id, config_type);
+
+	if ((adap_id == MSM_GSBI4_QUP_I2C_BUS_ID) && (config_type == 1)) {
+		gpio_tlmm_config(gsbi4_gpio_table[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi4_gpio_table[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI4_QUP_I2C_BUS_ID) && (config_type == 0)) {
+		gpio_tlmm_config(gsbi4_gpio_table_gpio[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi4_gpio_table_gpio[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI5_QUP_I2C_BUS_ID) && (config_type == 1)) {
+		gpio_tlmm_config(gsbi5_gpio_table[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi5_gpio_table[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI5_QUP_I2C_BUS_ID) && (config_type == 0)) {
+		gpio_tlmm_config(gsbi5_gpio_table_gpio[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi5_gpio_table_gpio[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI7_QUP_I2C_BUS_ID) && (config_type == 1)) {
+		gpio_tlmm_config(gsbi7_gpio_table[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi7_gpio_table[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI7_QUP_I2C_BUS_ID) && (config_type == 0)) {
+		gpio_tlmm_config(gsbi7_gpio_table_gpio[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi7_gpio_table_gpio[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI10_QUP_I2C_BUS_ID) && (config_type == 1)) {
+		gpio_tlmm_config(gsbi10_gpio_table[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi10_gpio_table[1], GPIO_CFG_ENABLE);
+	}
+
+	if ((adap_id == MSM_GSBI10_QUP_I2C_BUS_ID) && (config_type == 0)) {
+		gpio_tlmm_config(gsbi10_gpio_table_gpio[0], GPIO_CFG_ENABLE);
+		gpio_tlmm_config(gsbi10_gpio_table_gpio[1], GPIO_CFG_ENABLE);
+	}
+
+}
+
+static struct msm_i2c_platform_data msm_gsbi4_qup_i2c_pdata = {
+	.clk_freq = 384000,
+	.src_clk_rate = 24000000,
+	.clk = "gsbi_qup_clk",
+	.pclk = "gsbi_pclk",
+	.msm_i2c_config_gpio = gsbi_qup_i2c_gpio_config,
+};
+
+static struct msm_i2c_platform_data msm_gsbi5_qup_i2c_pdata = {
+	.clk_freq = 100000,
+	.src_clk_rate = 24000000,
+	.clk = "gsbi_qup_clk",
+	.pclk = "gsbi_pclk",
+	.msm_i2c_config_gpio = gsbi_qup_i2c_gpio_config,
+};
+
+static struct msm_i2c_platform_data msm_gsbi7_qup_i2c_pdata = {
+	.clk_freq = 100000,
+	.src_clk_rate = 24000000,
+	.clk = "gsbi_qup_clk",
+	.pclk = "gsbi_pclk",
+	.msm_i2c_config_gpio = gsbi_qup_i2c_gpio_config,
+};
+
+static struct msm_i2c_platform_data msm_gsbi10_qup_i2c_pdata = {
+	.clk_freq = 384000,
+	.src_clk_rate = 24000000,
+	.clk = "gsbi_qup_clk",
+	.pclk = "gsbi_pclk",
+	.msm_i2c_config_gpio = gsbi_qup_i2c_gpio_config,
+};
+#endif
+
+#if defined(CONFIG_SPI_QUP) || defined(CONFIG_SPI_QUP_MODULE)
+static struct msm_spi_platform_data msm_gsbi1_qup_spi_pdata = {
+	.max_clock_speed = 10800000,
+};
+#endif
+
+#ifdef CONFIG_I2C_SSBI
+
+/* PMIC SSBI */
+static struct msm_i2c_ssbi_platform_data msm_ssbi2_pdata = {
+	.controller_type = MSM_SBI_CTRL_PMIC_ARBITER,
+};
+
+/* CODEC/TSSC SSBI */
+static struct msm_i2c_ssbi_platform_data msm_ssbi3_pdata = {
+	.controller_type = MSM_SBI_CTRL_SSBI,
+};
+#endif
+
+#ifdef CONFIG_BATTERY_MSM
+/* Use basic value for fake MSM battery */
+static struct msm_psy_batt_pdata msm_psy_batt_data = {
+	.avail_chg_sources = AC_CHG,
+};
+
+static struct platform_device msm_batt_device = {
+	.name              = "msm-battery",
+	.id                = -1,
+	.dev.platform_data = &msm_psy_batt_data,
+};
+
+#endif
+/* Sensors DSPS platform data */
+#ifdef CONFIG_MSM_DSPS
+static struct dsps_gpio_info dsps_gpios[] = {
+};
+
+static void __init msm8x60_init_dsps(void)
+{
+	struct msm_dsps_platform_data *pdata =
+		msm_dsps_device.dev.platform_data;
+
+	pdata->gpios = dsps_gpios;
+	pdata->gpios_num = ARRAY_SIZE(dsps_gpios);
+}
+#endif /* CONFIG_MSM_DSPS */
+
+static unsigned fb_size;
+static int __init fb_size_setup(char *p)
+{
+	fb_size = memparse(p, NULL);
+	return 0;
+}
+early_param("fb_size", fb_size_setup);
+
+#ifdef CONFIG_ANDROID_PMEM
+static unsigned pmem_sf_size = MSM_PMEM_SF_SIZE;
+
+static int __init pmem_sf_size_setup(char *p)
+{
+	pmem_sf_size = memparse(p, NULL);
+	return 0;
+}
+early_param("pmem_sf_size", pmem_sf_size_setup);
+
+static unsigned pmem_adsp_size = MSM_PMEM_ADSP_SIZE;
+
+static int __init pmem_adsp_size_setup(char *p)
+{
+	pmem_adsp_size = memparse(p, NULL);
+	return 0;
+}
+early_param("pmem_adsp_size", pmem_adsp_size_setup);
+
+static unsigned pmem_audio_size = MSM_PMEM_AUDIO_SIZE;
+
+static int __init pmem_audio_size_setup(char *p)
+{
+	pmem_audio_size = memparse(p, NULL);
+	return 0;
+}
+early_param("pmem_audio_size", pmem_audio_size_setup);
+#endif
+
+static struct resource msm_fb_resources[] = {
+	{
+		.flags  = IORESOURCE_DMA,
+	},
+	/* for overlay write back operation */
+	{
+		.flags  = IORESOURCE_DMA,
+	},
+};
+
+#ifdef CONFIG_ANDROID_PMEM
+static struct android_pmem_platform_data android_pmem_pdata = {
+	.name = "pmem",
+	.allocator_type = PMEM_ALLOCATORTYPE_ALLORNOTHING,
+	.cached = 1,
+};
+
+static struct platform_device android_pmem_device = {
+	.name = "android_pmem",
+	.id = 0,
+	.dev = {.platform_data = &android_pmem_pdata},
+};
+
+static struct android_pmem_platform_data android_pmem_adsp_pdata = {
+	.name = "pmem_adsp",
+	.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
+	.cached = 1,
+};
+
+static struct platform_device android_pmem_adsp_device = {
+	.name = "android_pmem",
+	.id = 2,
+	.dev = { .platform_data = &android_pmem_adsp_pdata },
+};
+
+static struct android_pmem_platform_data android_pmem_audio_pdata = {
+	.name = "pmem_audio",
+	.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
+	.cached = 0,
+};
+
+static struct platform_device android_pmem_audio_device = {
+	.name = "android_pmem",
+	.id = 4,
+	.dev = { .platform_data = &android_pmem_audio_pdata },
+};
+
+#define PMEM_BUS_WIDTH(_bw) \
+	{ \
+		.vectors = &(struct msm_bus_vectors){ \
+			.src = MSM_BUS_MASTER_AMPSS_M0, \
+			.dst = MSM_BUS_SLAVE_SMI, \
+			.ib = (_bw), \
+			.ab = 0, \
+		}, \
+	.num_paths = 1, \
+	}
+static struct msm_bus_paths pmem_smi_table[] = {
+	[0] = PMEM_BUS_WIDTH(0), /* Off */
+	[1] = PMEM_BUS_WIDTH(1), /* On */
+};
+
+static struct msm_bus_scale_pdata smi_client_pdata = {
+	.usecase = pmem_smi_table,
+	.num_usecases = ARRAY_SIZE(pmem_smi_table),
+	.name = "pmem_smi",
+};
+
+void pmem_request_smi_region(void *data)
+{
+	int bus_id = (int) data;
+
+	msm_bus_scale_client_update_request(bus_id, 1);
+}
+
+void pmem_release_smi_region(void *data)
+{
+	int bus_id = (int) data;
+
+	msm_bus_scale_client_update_request(bus_id, 0);
+}
+
+void *pmem_setup_smi_region(void)
+{
+	return (void *)msm_bus_scale_register_client(&smi_client_pdata);
+}
+
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
+static struct resource hdmi_msm_resources[] = {
+	{
+		.name  = "hdmi_msm_qfprom_addr",
+		.start = 0x00700000,
+		.end   = 0x007060FF,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name  = "hdmi_msm_hdmi_addr",
+		.start = 0x04A00000,
+		.end   = 0x04A00FFF,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name  = "hdmi_msm_irq",
+		.start = HDMI_IRQ,
+		.end   = HDMI_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int hdmi_enable_5v(int on);
+static int hdmi_core_power(int on, int show);
+static int hdmi_cec_power(int on);
+
+static struct msm_hdmi_platform_data hdmi_msm_data = {
+	.irq = HDMI_IRQ,
+	.enable_5v = hdmi_enable_5v,
+	.core_power = hdmi_core_power,
+	.cec_power = hdmi_cec_power,
+};
+
+static struct platform_device hdmi_msm_device = {
+	.name = "hdmi_msm",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(hdmi_msm_resources),
+	.resource = hdmi_msm_resources,
+	.dev.platform_data = &hdmi_msm_data,
+};
+
+static struct platform_device *hdmi_devices[] __initdata = {
+	&hdmi_msm_device,
+};
+#endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
+
+static struct android_pmem_platform_data android_pmem_smipool_pdata = {
+	.name = "pmem_smipool",
+	.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
+	.cached = 1,
+	.memory_type = MEMTYPE_SMI,
+	.request_region = pmem_request_smi_region,
+	.release_region = pmem_release_smi_region,
+	.setup_region = pmem_setup_smi_region,
+	.map_on_demand = 1,
+};
+static struct platform_device android_pmem_smipool_device = {
+	.name = "android_pmem",
+	.id = 7,
+	.dev = { .platform_data = &android_pmem_smipool_pdata },
+};
+#endif
+
+static void __init msm8x60_allocate_memory_regions(void)
+{
+	unsigned long size;
+
+	size = MSM_FB_SIZE;
+	msm_fb_resources[0].start = MSM_FB_BASE;
+	msm_fb_resources[0].end = msm_fb_resources[0].start + size - 1;
+	pr_info("allocating %lu bytes at 0x%p (0x%lx physical) for fb\n",
+		size, __va(MSM_FB_BASE), (unsigned long) MSM_FB_BASE);
+
+	size = MSM_OVERLAY_BLT_SIZE;
+	msm_fb_resources[1].start = MSM_OVERLAY_BLT_BASE;
+	msm_fb_resources[1].end = msm_fb_resources[1].start + size - 1;
+	pr_info("allocating %lu bytes at 0x%p (0x%lx physical) for overlay\n",
+		size, __va(MSM_OVERLAY_BLT_BASE), (unsigned long) MSM_OVERLAY_BLT_BASE);
+}
+
+static int rider_ts_atmel_power(int on)
+{
+	pr_info("[TP] %s: power %d\n", __func__, on);
+
+	gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_TP_RST), 0);
+	msleep(5);
+	gpio_set_value(PM8058_GPIO_PM_TO_SYS(RIDER_TP_RST), 1);
+	msleep(40);
+
+	return 0;
+}
+
+struct atmel_i2c_platform_data rider_ts_atmel_data[] = {
+	{
+		.version = 0x020,
+		.source = 1, /* ALPS, Nissha */
+		.abs_x_min = 5,
+		.abs_x_max = 1018,
+		.abs_y_min = 7,
+		.abs_y_max = 905,
+		.abs_pressure_min = 0,
+		.abs_pressure_max = 255,
+		.abs_width_min = 0,
+		.abs_width_max = 20,
+		.gpio_irq = RIDER_TP_ATT_N,
+		.power = rider_ts_atmel_power,
+		.unlock_attr = 1,
+		.config_T6 = {0, 0, 0, 0, 0, 0},
+		.config_T7 = {16, 8, 50},
+		.config_T8 = {9, 0, 5, 2, 0, 0, 5, 20, 5, 192},
+		.config_T9 = {139, 0, 0, 20, 10, 0, 16, 30, 2, 1, 0, 2, 2, 0, 4, 14, 10, 10, 0, 0, 0, 0, 248, 228, 5, 5, 145, 50, 139, 80, 15, 10},
+		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T18 = {0, 0},
+		.config_T19 = {0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T22 = {15, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 7, 18, 255, 255, 0},
+		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T25 = {3, 0, 16, 39, 124, 21, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T28 = {0, 0, 4, 4, 8, 60},
+		.object_crc = {0x20, 0xCD, 0xC5},
+		.cable_config = {35, 25, 8, 16},
+		.call_tchthr = {45, 50},
+		.locking_config = {20},
+		.noise_config = {45, 2, 35},
+		.GCAF_level = {20, 24, 28, 40, 63},
+	},
+	{
+		.version = 0x020,
+		.source = 0, /* TPK */
+		.abs_x_min = 5,
+		.abs_x_max = 1018,
+		.abs_y_min = 7,
+		.abs_y_max = 905,
+		.abs_pressure_min = 0,
+		.abs_pressure_max = 255,
+		.abs_width_min = 0,
+		.abs_width_max = 20,
+		.gpio_irq = RIDER_TP_ATT_N,
+		.power = rider_ts_atmel_power,
+		.unlock_attr = 1,
+		.config_T6 = {0, 0, 0, 0, 0, 0},
+		.config_T7 = {16, 8, 50},
+		.config_T8 = {8, 0, 5, 2, 0, 0, 5, 20, 5, 192},
+		.config_T9 = {139, 0, 0, 20, 10, 0, 16, 30, 2, 1, 0, 2, 2, 0, 4, 14, 10, 10, 0, 0, 0, 0, 6, 0, 15, 14, 140, 43, 147, 77, 15, 10},
+		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T18 = {0, 0},
+		.config_T19 = {0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T22 = {15, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 7, 18, 255, 255, 0},
+		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T25 = {3, 0, 16, 39, 124, 21, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T28 = {0, 0, 4, 4, 8, 60},
+		.object_crc = {0xA6, 0x13, 0x52},
+		.cable_config = {35, 25, 8, 16},
+		.call_tchthr = {45, 50},
+		.locking_config = {20},
+		.noise_config = {45, 2, 35},
+		.GCAF_level = {20, 24, 28, 40, 63},
+	},
+	{
+		.version = 0x016,
+		.source = 1, /* ALPS, Nissha */
+		.abs_x_min = 5,
+		.abs_x_max = 1018,
+		.abs_y_min = 7,
+		.abs_y_max = 905,
+		.abs_pressure_min = 0,
+		.abs_pressure_max = 255,
+		.abs_width_min = 0,
+		.abs_width_max = 20,
+		.gpio_irq = RIDER_TP_ATT_N,
+		.power = rider_ts_atmel_power,
+		.unlock_attr = 1,
+		.config_T6 = {0, 0, 0, 0, 0, 0},
+		.config_T7 = {16, 8, 50},
+		.config_T8 = {9, 0, 5, 2, 0, 0, 5, 20},
+		.config_T9 = {139, 0, 0, 20, 10, 0, 16, 30, 2, 1, 0, 2, 2, 0, 4, 14, 10, 10, 0, 0, 0, 0, 248, 228, 5, 5, 145, 50, 139, 80, 15},
+		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T18 = {0, 0},
+		.config_T19 = {0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T22 = {15, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 7, 18, 255, 255, 0},
+		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T25 = {3, 0, 16, 39, 124, 21, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
+		.config_T28 = {0, 0, 4, 4, 8, 60},
+		.cable_config = {35, 25, 8, 16},
+		.GCAF_level = {20, 24, 28, 40, 63},
+	},
+	{
+		.version = 0x016,
+		.source = 0, /* TPK */
+		.abs_x_min = 5,
+		.abs_x_max = 1018,
+		.abs_y_min = 7,
+		.abs_y_max = 905,
+		.abs_pressure_min = 0,
+		.abs_pressure_max = 255,
+		.abs_width_min = 0,
+		.abs_width_max = 20,
+		.gpio_irq = RIDER_TP_ATT_N,
+		.power = rider_ts_atmel_power,
+		.unlock_attr = 1,
+		.config_T6 = {0, 0, 0, 0, 0, 0},
+		.config_T7 = {16, 8, 50},
+		.config_T8 = {8, 0, 5, 2, 0, 0, 5, 20},
+		.config_T9 = {139, 0, 0, 20, 10, 0, 16, 30, 2, 1, 0, 2, 2, 0, 4, 14, 10, 10, 0, 0, 0, 0, 6, 0, 15, 14, 140, 43, 147, 77, 15},
+		.config_T15 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T18 = {0, 0},
+		.config_T19 = {0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T20 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T22 = {15, 0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 7, 18, 255, 255, 0},
+		.config_T23 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T24 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T25 = {3, 0, 16, 39, 124, 21, 0, 0, 0, 0, 0, 0, 0, 0},
+		.config_T27 = {0, 0, 0, 0, 0, 0, 0},
+		.config_T28 = {0, 0, 4, 4, 8, 60},
+		.cable_config = {35, 25, 8, 16},
+		.GCAF_level = {20, 24, 28, 40, 63},
+	},
+};
+
+static struct i2c_board_info msm_i2c_gsbi5_info[] = {
+	{
+		I2C_BOARD_INFO(ATMEL_QT602240_NAME, 0x94 >> 1),
+		.platform_data = &rider_ts_atmel_data,
+		.irq = MSM_GPIO_TO_INT(RIDER_TP_ATT_N)
+	},
+};
+
+static ssize_t rider_virtual_keys_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf,
+		__stringify(EV_KEY) ":" __stringify(KEY_HOME)   ":70:1020:90:90"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":190:1020:100:90"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":345:1020:100:90"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":468:1020:90:90"
+		"\n");
+}
+
+static struct kobj_attribute rider_virtual_keys_attr = {
+	.attr = {
+		.name = "virtualkeys.atmel-touchscreen",
+		.mode = S_IRUGO,
+	},
+	.show = &rider_virtual_keys_show,
+};
+
+static struct attribute *rider_properties_attrs[] = {
+	&rider_virtual_keys_attr.attr,
+	NULL
+};
+
+static struct attribute_group rider_properties_attr_group = {
+	.attrs = rider_properties_attrs,
+};
+
+#ifdef CONFIG_SERIAL_MSM_HS
+static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
+	.inject_rx_on_wakeup = 0,
+	.cpu_lock_supported = 1,
+
+	/* for bcm BT */
+	.bt_wakeup_pin_supported = 1,
+	.bt_wakeup_pin = RIDER_GPIO_BT_CHIP_WAKE,
+	.host_wakeup_pin = RIDER_GPIO_BT_HOST_WAKE,
+};
+#endif
+
+#ifdef CONFIG_BT
+static struct platform_device rider_rfkill = {
+	.name = "rider_rfkill",
+	.id = -1,
+};
+
+static struct htc_sleep_clk_platform_data htc_slp_clk_data = {
+	.sleep_clk_pin = RIDER_WIFI_BT_SLEEP_CLK,
+
+};
+
+static struct platform_device wifi_bt_slp_clk = {
+	.name = "htc_slp_clk",
+	.id = -1,
+	.dev = {
+		.platform_data = &htc_slp_clk_data,
+	},
+};
+#endif
+
+#if defined(CONFIG_MSM_RPM_LOG) || defined(CONFIG_MSM_RPM_LOG_MODULE)
+
+static struct msm_rpm_log_platform_data msm_rpm_log_pdata = {
+	.phys_addr_base = 0x00106000,
+	.reg_offsets = {
+		[MSM_RPM_LOG_PAGE_INDICES] = 0x00000C80,
+		[MSM_RPM_LOG_PAGE_BUFFER]  = 0x00000CA0,
+	},
+	.phys_size = SZ_8K,
+	.log_len = 4096,		  /* log's buffer length in bytes */
+	.log_len_mask = (4096 >> 2) - 1,  /* length mask in units of u32 */
+};
+
+static struct platform_device msm_rpm_log_device = {
+	.name	= "msm_rpm_log",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &msm_rpm_log_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_BATTERY_MSM8X60
+static struct msm_charger_platform_data msm_charger_data = {
+	.safety_time = 180,
+	.update_time = 1,
+	.max_voltage = 4200,
+	.min_voltage = 3200,
+	.resume_voltage = 4100,
+};
+
+static struct platform_device msm_charger_device = {
+	.name = "msm-charger",
+	.id = -1,
+	.dev = {
+		.platform_data = &msm_charger_data,
+	}
+};
+#endif
+
+/*
+ * Consumer specific regulator names:
+ *			 regulator name		consumer dev_name
+ */
+static struct regulator_consumer_supply vreg_consumers_PM8058_L0[] = {
+	REGULATOR_SUPPLY("8058_l0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L1[] = {
+	REGULATOR_SUPPLY("8058_l1",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L2[] = {
+	REGULATOR_SUPPLY("8058_l2",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L3[] = {
+	REGULATOR_SUPPLY("8058_l3",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L4[] = {
+	REGULATOR_SUPPLY("8058_l4",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L5[] = {
+	REGULATOR_SUPPLY("8058_l5",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L6[] = {
+	REGULATOR_SUPPLY("8058_l6",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L7[] = {
+	REGULATOR_SUPPLY("8058_l7",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L8[] = {
+	REGULATOR_SUPPLY("8058_l8",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L9[] = {
+	REGULATOR_SUPPLY("8058_l9",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L10[] = {
+	REGULATOR_SUPPLY("8058_l10",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L11[] = {
+	REGULATOR_SUPPLY("8058_l11",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L12[] = {
+	REGULATOR_SUPPLY("8058_l12",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L13[] = {
+	REGULATOR_SUPPLY("8058_l13",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L14[] = {
+	REGULATOR_SUPPLY("8058_l14",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L15[] = {
+	REGULATOR_SUPPLY("8058_l15",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L16[] = {
+	REGULATOR_SUPPLY("8058_l16",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L17[] = {
+	REGULATOR_SUPPLY("8058_l17",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L18[] = {
+	REGULATOR_SUPPLY("8058_l18",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L19[] = {
+	REGULATOR_SUPPLY("8058_l19",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L20[] = {
+	REGULATOR_SUPPLY("8058_l20",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L21[] = {
+	REGULATOR_SUPPLY("8058_l21",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L22[] = {
+	REGULATOR_SUPPLY("8058_l22",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L23[] = {
+	REGULATOR_SUPPLY("8058_l23",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L24[] = {
+	REGULATOR_SUPPLY("8058_l24",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_L25[] = {
+	REGULATOR_SUPPLY("8058_l25",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_S0[] = {
+	REGULATOR_SUPPLY("8058_s0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_S1[] = {
+	REGULATOR_SUPPLY("8058_s1",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_S2[] = {
+	REGULATOR_SUPPLY("8058_s2",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_S3[] = {
+	REGULATOR_SUPPLY("8058_s3",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_S4[] = {
+	REGULATOR_SUPPLY("8058_s4",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_LVS0[] = {
+	REGULATOR_SUPPLY("8058_lvs0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_LVS1[] = {
+	REGULATOR_SUPPLY("8058_lvs1",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8058_NCP[] = {
+	REGULATOR_SUPPLY("8058_ncp",		NULL),
+};
+
+static struct regulator_consumer_supply vreg_consumers_PM8901_L0[] = {
+	REGULATOR_SUPPLY("8901_l0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_L1[] = {
+	REGULATOR_SUPPLY("8901_l1",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_L2[] = {
+	REGULATOR_SUPPLY("8901_l2",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_L3[] = {
+	REGULATOR_SUPPLY("8901_l3",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_L4[] = {
+	REGULATOR_SUPPLY("8901_l4",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_L5[] = {
+	REGULATOR_SUPPLY("8901_l5",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_L6[] = {
+	REGULATOR_SUPPLY("8901_l6",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_S2[] = {
+	REGULATOR_SUPPLY("8901_s2",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_S3[] = {
+	REGULATOR_SUPPLY("8901_s3",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_S4[] = {
+	REGULATOR_SUPPLY("8901_s4",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_LVS0[] = {
+	REGULATOR_SUPPLY("8901_lvs0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_LVS1[] = {
+	REGULATOR_SUPPLY("8901_lvs1",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_LVS2[] = {
+	REGULATOR_SUPPLY("8901_lvs2",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_LVS3[] = {
+	REGULATOR_SUPPLY("8901_lvs3",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_MVS0[] = {
+	REGULATOR_SUPPLY("8901_mvs0",		NULL),
+};
+
+/* Pin control regulators */
+static struct regulator_consumer_supply vreg_consumers_PM8058_S2_PC[] = {
+	REGULATOR_SUPPLY("8058_s2_pc",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_PM8901_S4_PC[] = {
+	REGULATOR_SUPPLY("8901_s4_pc",		NULL),
+};
+
+#define RPM_VREG_INIT(_id, _min_uV, _max_uV, _modes, _ops, _apply_uV, \
+		      _default_uV, _peak_uA, _avg_uA, _pull_down, _pin_ctrl, \
+		      _freq, _pin_fn, _force_mode, _state, _sleep_selectable, \
+		      _always_on) \
+	{ \
+		.init_data = { \
+			.constraints = { \
+				.valid_modes_mask = _modes, \
+				.valid_ops_mask = _ops, \
+				.min_uV = _min_uV, \
+				.max_uV = _max_uV, \
+				.input_uV = _min_uV, \
+				.apply_uV = _apply_uV, \
+				.always_on = _always_on, \
+			}, \
+			.consumer_supplies = vreg_consumers_##_id, \
+			.num_consumer_supplies = \
+				ARRAY_SIZE(vreg_consumers_##_id), \
+		}, \
+		.id			= RPM_VREG_ID_##_id, \
+		.default_uV = _default_uV, \
+		.peak_uA = _peak_uA, \
+		.avg_uA = _avg_uA, \
+		.pull_down_enable = _pull_down, \
+		.pin_ctrl = _pin_ctrl, \
+		.freq			= RPM_VREG_FREQ_##_freq, \
+		.pin_fn = _pin_fn, \
+		.force_mode		= _force_mode, \
+		.state = _state, \
+		.sleep_selectable = _sleep_selectable, \
+	}
+
+/* Pin control initialization */
+#define RPM_PC(_id, _always_on, _pin_fn, _pin_ctrl) \
+	{ \
+		.init_data = { \
+			.constraints = { \
+				.valid_ops_mask	= REGULATOR_CHANGE_STATUS, \
+				.always_on	= _always_on, \
+			}, \
+			.num_consumer_supplies	= \
+					ARRAY_SIZE(vreg_consumers_##_id##_PC), \
+			.consumer_supplies	= vreg_consumers_##_id##_PC, \
+		}, \
+		.id	  = RPM_VREG_ID_##_id##_PC, \
+		.pin_fn	  = RPM_VREG_PIN_FN_8660_##_pin_fn, \
+		.pin_ctrl = _pin_ctrl, \
+	}
+
+/*
+ * The default LPM/HPM state of an RPM controlled regulator can be controlled
+ * via the peak_uA value specified in the table below.  If the value is less
+ * than the high power min threshold for the regulator, then the regulator will
+ * be set to LPM.  Otherwise, it will be set to HPM.
+ *
+ * This value can be further overridden by specifying an initial mode via
+ * .init_data.constraints.initial_mode.
+ */
+
+#define RPM_LDO(_id, _always_on, _pd, _sleep_selectable, _min_uV, _max_uV, \
+		_init_peak_uA) \
+	RPM_VREG_INIT(_id, _min_uV, _max_uV, REGULATOR_MODE_FAST | \
+		      REGULATOR_MODE_NORMAL | REGULATOR_MODE_IDLE | \
+		      REGULATOR_MODE_STANDBY, REGULATOR_CHANGE_VOLTAGE | \
+		      REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_MODE | \
+		      REGULATOR_CHANGE_DRMS, 0, _min_uV, _init_peak_uA, \
+		      _init_peak_uA, _pd, RPM_VREG_PIN_CTRL_NONE, NONE, \
+		      RPM_VREG_PIN_FN_8660_ENABLE, \
+		      RPM_VREG_FORCE_MODE_8660_NONE, RPM_VREG_STATE_OFF, \
+		      _sleep_selectable, _always_on)
+
+#define RPM_SMPS(_id, _always_on, _pd, _sleep_selectable, _min_uV, _max_uV, \
+		 _init_peak_uA, _freq) \
+	RPM_VREG_INIT(_id, _min_uV, _max_uV, REGULATOR_MODE_FAST | \
+		      REGULATOR_MODE_NORMAL | REGULATOR_MODE_IDLE | \
+		      REGULATOR_MODE_STANDBY, REGULATOR_CHANGE_VOLTAGE | \
+		      REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_MODE | \
+		      REGULATOR_CHANGE_DRMS, 0, _min_uV, _init_peak_uA, \
+		      _init_peak_uA, _pd, RPM_VREG_PIN_CTRL_NONE, _freq, \
+		      RPM_VREG_PIN_FN_8660_ENABLE, \
+		      RPM_VREG_FORCE_MODE_8660_NONE, RPM_VREG_STATE_OFF, \
+		      _sleep_selectable, _always_on)
+
+#define RPM_VS(_id, _always_on, _pd, _sleep_selectable) \
+	RPM_VREG_INIT(_id, 0, 0, REGULATOR_MODE_NORMAL | REGULATOR_MODE_IDLE, \
+		      REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_MODE, 0, 0, \
+		      1000, 1000, _pd, RPM_VREG_PIN_CTRL_NONE, NONE, \
+		      RPM_VREG_PIN_FN_8660_ENABLE, \
+		      RPM_VREG_FORCE_MODE_8660_NONE, RPM_VREG_STATE_OFF, \
+		      _sleep_selectable, _always_on)
+
+#define RPM_NCP(_id, _always_on, _pd, _sleep_selectable, _min_uV, _max_uV) \
+	RPM_VREG_INIT(_id, _min_uV, _max_uV, REGULATOR_MODE_NORMAL, \
+		      REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS, 0, \
+		      _min_uV, 1000, 1000, _pd, RPM_VREG_PIN_CTRL_NONE, NONE, \
+		      RPM_VREG_PIN_FN_8660_ENABLE, \
+		      RPM_VREG_FORCE_MODE_8660_NONE, RPM_VREG_STATE_OFF, \
+		      _sleep_selectable, _always_on)
+
+#define LDO50HMIN	RPM_VREG_8660_LDO_50_HPM_MIN_LOAD
+#define LDO150HMIN	RPM_VREG_8660_LDO_150_HPM_MIN_LOAD
+#define LDO300HMIN	RPM_VREG_8660_LDO_300_HPM_MIN_LOAD
+#define SMPS_HMIN	RPM_VREG_8660_SMPS_HPM_MIN_LOAD
+#define FTS_HMIN	RPM_VREG_8660_FTSMPS_HPM_MIN_LOAD
+
+/* RPM early regulator constraints */
+static struct rpm_regulator_init_data rpm_regulator_early_init_data[] = {
+	/*	 ID       a_on pd ss min_uV   max_uV   init_ip    freq */
+	RPM_SMPS(PM8058_S0, 0, 1, 1,  500000, 1350000, SMPS_HMIN, 1p92),
+	RPM_SMPS(PM8058_S1, 0, 1, 1,  500000, 1350000, SMPS_HMIN, 1p92),
+};
+
+/* RPM regulator constraints */
+static struct rpm_regulator_init_data rpm_regulator_init_data[] = {
+	/*	ID        a_on pd ss min_uV   max_uV   init_ip */
+	RPM_LDO(PM8058_L0,  0, 1, 0, 1200000, 1200000, LDO150HMIN),
+	RPM_LDO(PM8058_L1,  0, 1, 0, 1350000, 1350000, LDO300HMIN),
+	RPM_LDO(PM8058_L2,  0, 1, 0, 1800000, 2600000, LDO300HMIN),
+	RPM_LDO(PM8058_L3,  0, 1, 0, 1800000, 3000000, LDO150HMIN),
+	RPM_LDO(PM8058_L4,  0, 1, 0, 2850000, 2850000,  LDO50HMIN),
+	RPM_LDO(PM8058_L5,  0, 1, 0, 2850000, 2850000, LDO300HMIN),
+	RPM_LDO(PM8058_L6,  0, 1, 0, 3000000, 3600000,  LDO50HMIN),
+	RPM_LDO(PM8058_L7,  0, 1, 0, 1800000, 1800000,  LDO50HMIN),
+	RPM_LDO(PM8058_L8,  0, 1, 0, 1800000, 1800000, LDO300HMIN),
+	RPM_LDO(PM8058_L9,  0, 1, 0, 1800000, 1800000, LDO300HMIN),
+	RPM_LDO(PM8058_L10, 0, 1, 0, 2850000, 2850000, LDO300HMIN),
+	RPM_LDO(PM8058_L11, 0, 1, 0, 2850000, 2850000, LDO150HMIN),
+	RPM_LDO(PM8058_L12, 0, 1, 0, 3000000, 3000000, LDO150HMIN),
+	RPM_LDO(PM8058_L13, 0, 1, 0, 2050000, 2050000, LDO300HMIN),
+	RPM_LDO(PM8058_L14, 0, 1, 0, 2850000, 2850000, LDO300HMIN),
+	RPM_LDO(PM8058_L15, 0, 1, 0, 2800000, 2800000, LDO300HMIN),
+	RPM_LDO(PM8058_L16, 1, 1, 1, 1800000, 1800000, LDO300HMIN),
+	RPM_LDO(PM8058_L17, 0, 1, 0, 2600000, 2600000, LDO150HMIN),
+	RPM_LDO(PM8058_L18, 0, 1, 1, 2200000, 2200000, LDO150HMIN),
+	RPM_LDO(PM8058_L19, 0, 1, 0, 1800000, 1800000, LDO150HMIN),
+	RPM_LDO(PM8058_L20, 0, 1, 0, 1800000, 1800000, LDO150HMIN),
+	RPM_LDO(PM8058_L21, 1, 1, 0, 1200000, 1200000, LDO150HMIN),
+	RPM_LDO(PM8058_L22, 0, 0, 0, 1200000, 1200000, LDO300HMIN),
+	RPM_LDO(PM8058_L23, 0, 0, 0, 1200000, 1800000, LDO300HMIN),
+	RPM_LDO(PM8058_L24, 0, 1, 0, 1200000, 1200000, LDO150HMIN),
+	RPM_LDO(PM8058_L25, 0, 1, 0, 1200000, 1200000, LDO150HMIN),
+
+	/*	 ID       a_on pd ss min_uV   max_uV   init_ip    freq */
+	RPM_SMPS(PM8058_S2, 0, 1, 0, 1200000, 1400000, SMPS_HMIN, 1p92),
+	RPM_SMPS(PM8058_S3, 1, 1, 0, 1800000, 1800000, SMPS_HMIN, 1p92),
+	RPM_SMPS(PM8058_S4, 1, 1, 0, 2200000, 2200000, SMPS_HMIN, 1p92),
+
+	/*     ID         a_on pd ss */
+	RPM_VS(PM8058_LVS0, 0, 1, 0),
+	RPM_VS(PM8058_LVS1, 0, 1, 0),
+
+	/*	ID        a_on pd ss min_uV   max_uV */
+	RPM_NCP(PM8058_NCP, 0, 1, 0, 1800000, 1800000),
+
+	/*	ID        a_on pd ss min_uV   max_uV   init_ip */
+	RPM_LDO(PM8901_L0,  0, 1, 0, 1200000, 1200000, LDO300HMIN),
+	RPM_LDO(PM8901_L1,  0, 1, 0, 3200000, 3200000, LDO300HMIN),
+	RPM_LDO(PM8901_L2,  0, 1, 0, 2850000, 3300000, LDO300HMIN),
+	RPM_LDO(PM8901_L3,  0, 1, 0, 3300000, 3300000, LDO300HMIN),
+	RPM_LDO(PM8901_L4,  0, 1, 0, 2850000, 2850000, LDO300HMIN),
+	RPM_LDO(PM8901_L5,  0, 1, 0, 2850000, 2850000, LDO300HMIN),
+	RPM_LDO(PM8901_L6,  0, 0, 0, 2200000, 2200000, LDO300HMIN),
+
+	/*	 ID       a_on pd ss min_uV   max_uV   init_ip   freq */
+	RPM_SMPS(PM8901_S2, 0, 1, 0, 1200000, 1200000, FTS_HMIN, 1p60),
+	RPM_SMPS(PM8901_S3, 0, 1, 0, 1100000, 1100000, FTS_HMIN, 1p60),
+	RPM_SMPS(PM8901_S4, 0, 1, 0, 1200000, 1200000, FTS_HMIN, 1p60),
+
+	/*	ID        a_on pd ss */
+	RPM_VS(PM8901_LVS0, 0, 1, 0),
+	RPM_VS(PM8901_LVS1, 0, 1, 0),
+	RPM_VS(PM8901_LVS2, 0, 0, 0),
+	RPM_VS(PM8901_LVS3, 0, 0, 0),
+	RPM_VS(PM8901_MVS0, 0, 0, 0),
+
+	/*     ID         a_on pin_func pin_ctrl */
+	RPM_PC(PM8058_S2,   0, ENABLE,  RPM_VREG_PIN_CTRL_PM8058_A0),
+	RPM_PC(PM8901_S4,   0, ENABLE,  RPM_VREG_PIN_CTRL_PM8901_A0),
+};
+
+static struct rpm_regulator_platform_data rpm_regulator_early_pdata = {
+	.init_data		= rpm_regulator_early_init_data,
+	.num_regulators		= ARRAY_SIZE(rpm_regulator_early_init_data),
+	.version		= RPM_VREG_VERSION_8660,
+	.vreg_id_vdd_mem	= RPM_VREG_ID_PM8058_S0,
+	.vreg_id_vdd_dig	= RPM_VREG_ID_PM8058_S1,
+};
+
+static struct rpm_regulator_platform_data rpm_regulator_pdata = {
+	.init_data		= rpm_regulator_init_data,
+	.num_regulators		= ARRAY_SIZE(rpm_regulator_init_data),
+	.version		= RPM_VREG_VERSION_8660,
+};
+
+static struct platform_device rpm_regulator_early_device = {
+	.name	= "rpm-regulator",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &rpm_regulator_early_pdata,
+	},
+};
+
+static struct platform_device rpm_regulator_device = {
+	.name	= "rpm-regulator",
+	.id	= 1,
+	.dev	= {
+		.platform_data = &rpm_regulator_pdata,
+	},
+};
+
+static struct platform_device *early_regulators[] __initdata = {
+	&msm_device_saw_s0,
+	&msm_device_saw_s1,
+	&rpm_regulator_early_device,
+};
+
+#ifdef CONFIG_FLASHLIGHT_AAT1277
+static void config_flashlight_gpios(void)
+{
+	static uint32_t flashlight_gpio_table[] = {
+		GPIO_CFG(RIDER_TORCH_EN, 0, GPIO_CFG_OUTPUT,
+			GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+		GPIO_CFG(RIDER_FLASH_EN, 0, GPIO_CFG_OUTPUT,
+			GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+	};
+	static struct pm_gpio flashlight_cfg = {
+			.direction		= PM_GPIO_DIR_OUT,
+			.output_value	= 0,
+			.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+			.pull			= PM_GPIO_PULL_NO,
+			.out_strength	= PM_GPIO_STRENGTH_HIGH,
+			.function		= PM_GPIO_FUNC_NORMAL,
+			.vin_sel		= PM8058_GPIO_VIN_L5,
+			.inv_int_pol	= 0,
+	};
+	config_gpio_table(flashlight_gpio_table,
+		ARRAY_SIZE(flashlight_gpio_table));
+
+	pm8xxx_gpio_config(PM8058_GPIO_PM_TO_SYS(RIDER_TORCH_SET1), &flashlight_cfg);
+	pm8xxx_gpio_config(PM8058_GPIO_PM_TO_SYS(RIDER_TORCH_SET2), &flashlight_cfg);
+}
+
+static struct flashlight_platform_data flashlight_data = {
+	.gpio_init 		= config_flashlight_gpios,
+	.torch 			= RIDER_TORCH_EN,
+	.flash 			= RIDER_FLASH_EN,
+	.torch_set1 		= PM8058_GPIO_PM_TO_SYS(RIDER_TORCH_SET1),
+	.torch_set2 		= PM8058_GPIO_PM_TO_SYS(RIDER_TORCH_SET2),
+	.flash_duration_ms 	= 600,
+};
+
+static struct platform_device flashlight_device = {
+	.name = "FLASHLIGHT_AAT1277",
+	.dev = {
+		.platform_data	= &flashlight_data,
+	},
+};
+#endif
+
+static struct platform_device *early_devices[] __initdata = {
+#ifdef CONFIG_MSM_BUS_SCALING
+	&msm_bus_apps_fabric,
+	&msm_bus_sys_fabric,
+	&msm_bus_mm_fabric,
+	&msm_bus_sys_fpb,
+	&msm_bus_cpss_fpb,
+#endif
+	&msm_device_dmov_adm0,
+	&msm_device_dmov_adm1,
+#ifdef CONFIG_FLASHLIGHT_AAT1277
+	&flashlight_device,
+#endif
+};
+
+static struct tsens_platform_data pyr_tsens_pdata  = {
+                .tsens_factor           = 1000,
+                .hw_type                = MSM_8660,
+                .tsens_num_sensor       = 6,
+                .slope                  = 702,
+};
+
+#ifdef CONFIG_SENSORS_MSM_ADC
+static struct adc_access_fn xoadc_fn = {
+	pm8058_xoadc_select_chan_and_start_conv,
+	pm8058_xoadc_read_adc_code,
+	pm8058_xoadc_get_properties,
+	pm8058_xoadc_slot_request,
+	pm8058_xoadc_restore_slot,
+	pm8058_xoadc_calibrate,
+};
+
+static struct msm_adc_channels msm_adc_channels_data[] = {
+	{"vbatt", CHANNEL_ADC_VBATT, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE3, scale_default},
+	{"vcoin", CHANNEL_ADC_VCOIN, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE2, scale_default},
+	{"vcharger_channel", CHANNEL_ADC_VCHG, 0, &xoadc_fn, CHAN_PATH_TYPE13,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE4, scale_default},
+	{"charger_current_monitor", CHANNEL_ADC_CHG_MONITOR, 0, &xoadc_fn,
+		CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE1, scale_default},
+	{"vph_pwr", CHANNEL_ADC_VPH_PWR, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE3, scale_default},
+	{"usb_vbus", CHANNEL_ADC_USB_VBUS, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE3, scale_default},
+	{"pmic_therm", CHANNEL_ADC_DIE_TEMP, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE1, scale_pmic_therm},
+	{"pmic_therm_4K", CHANNEL_ADC_DIE_TEMP_4K, 0, &xoadc_fn,
+		CHAN_PATH_TYPE12,
+		ADC_CONFIG_TYPE1, ADC_CALIB_CONFIG_TYPE7, scale_pmic_therm},
+	{"xo_therm", CHANNEL_ADC_XOTHERM, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE5, tdkntcgtherm},
+	{"xo_therm_4K", CHANNEL_ADC_XOTHERM_4K, 0, &xoadc_fn,
+		CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE1, ADC_CALIB_CONFIG_TYPE6, tdkntcgtherm},
+	{"hdset_detect", CHANNEL_ADC_HDSET, 0, &xoadc_fn, CHAN_PATH_TYPE6,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE1, scale_default},
+	{"chg_batt_amon", CHANNEL_ADC_BATT_AMON, 0, &xoadc_fn, CHAN_PATH_TYPE7,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE1,
+		scale_default},
+	{"batt_therm", CHANNEL_ADC_BATT_THERM, 0, &xoadc_fn, CHAN_PATH_TYPE6,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE2, scale_default},
+	{"batt_id", CHANNEL_ADC_BATT_ID, 0, &xoadc_fn, CHAN_PATH_TYPE_NONE,
+		ADC_CONFIG_TYPE2, ADC_CALIB_CONFIG_TYPE2, scale_default},
+};
+
+static struct msm_adc_platform_data msm_adc_pdata = {
+	.channel = msm_adc_channels_data,
+	.num_chan_supported = ARRAY_SIZE(msm_adc_channels_data),
+};
+
+static struct platform_device msm_adc_device = {
+	.name   = "msm_adc",
+	.id = -1,
+	.dev = {
+		.platform_data = &msm_adc_pdata,
+	},
+};
+#endif /* CONFIG_SENSORS_MSM_ADC */
+
+/* HTC_HEADSET_GPIO Driver */
+static struct htc_headset_gpio_platform_data htc_headset_gpio_data = {
+	.hpin_gpio		= RIDER_GPIO_AUD_HP_DET,
+	.key_enable_gpio	= 0,
+	.mic_select_gpio	= 0,
+};
+
+static struct platform_device htc_headset_gpio = {
+	.name	= "HTC_HEADSET_GPIO",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &htc_headset_gpio_data,
+	},
+};
+
+/* HTC_HEADSET_PMIC Driver */
+static struct htc_headset_pmic_platform_data htc_headset_pmic_data = {
+	.driver_flag		= 0,
+	.hpin_gpio		= 0,
+	.hpin_irq		= 0,
+	.key_gpio		= PM8058_GPIO_PM_TO_SYS(RIDER_AUD_REMO_PRES),
+	.key_irq		= 0,
+	.key_enable_gpio	= PM8058_GPIO_PM_TO_SYS(RIDER_AUD_REMO_EN),
+	.adc_mic_bias		= {0, 0},
+	.adc_remote		= {0, 0, 0, 0, 0, 0},
+};
+
+static struct platform_device htc_headset_pmic = {
+	.name	= "HTC_HEADSET_PMIC",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &htc_headset_pmic_data,
+	},
+};
+
+/* HTC_HEADSET_8X60 Driver */
+static struct htc_headset_8x60_platform_data htc_headset_8x60_data = {
+	.adc_mpp	= PM8058_MPP_PM_TO_SYS(XOADC_MPP_10),
+	.adc_amux	= PM_MPP_AIN_AMUX_CH5,
+	.adc_mic_bias	= {HS_DEF_MIC_ADC_15_BIT_MIN,
+			   HS_DEF_MIC_ADC_15_BIT_MAX},
+	.adc_remote	= {0, 1251, 1430, 3411, 4543, 6807},
+};
+
+static struct htc_headset_8x60_platform_data htc_headset_8x60_data_xc = {
+	.adc_mpp	= PM8058_MPP_PM_TO_SYS(XOADC_MPP_10),
+	.adc_amux	= PM_MPP_AIN_AMUX_CH5,
+	.adc_mic_bias	= {10410, 26643},
+	.adc_remote	= {0, 1087, 1088, 3730, 3731, 6783},
+};
+
+static struct platform_device htc_headset_8x60 = {
+	.name	= "HTC_HEADSET_8X60",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &htc_headset_8x60_data,
+	},
+};
+
+/* HTC_HEADSET_MGR Driver */
+static struct platform_device *headset_devices[] = {
+	&htc_headset_pmic,
+	&htc_headset_8x60,
+	&htc_headset_gpio,
+	/* Please put the headset detection driver on the last */
+};
+
+static struct headset_adc_config htc_headset_mgr_config[] = {
+	{
+		.type = HEADSET_MIC,
+		.adc_max = 27404,
+		.adc_min = 20538,
+	},
+	{
+		.type = HEADSET_BEATS,
+		.adc_max = 20537,
+		.adc_min = 16755,
+	},
+	{
+		.type = HEADSET_BEATS_SOLO,
+		.adc_max = 16754,
+		.adc_min = 10410,
+	},
+	{
+		.type = HEADSET_NO_MIC,
+		.adc_max = 10409,
+		.adc_min = 0,
+	},
+};
+
+static struct htc_headset_mgr_platform_data htc_headset_mgr_data = {
+	.driver_flag		= 0,
+	.headset_devices_num	= ARRAY_SIZE(headset_devices),
+	.headset_devices	= headset_devices,
+	.headset_config_num	= ARRAY_SIZE(htc_headset_mgr_config),
+	.headset_config		= htc_headset_mgr_config,
+};
+
+static struct platform_device htc_headset_mgr = {
+	.name	= "HTC_HEADSET_MGR",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &htc_headset_mgr_data,
+	},
+};
+
+static void headset_device_register(void)
+{
+	pr_info("[HS_BOARD] (%s) Headset device register\n", __func__);
+	platform_device_register(&htc_headset_mgr);
+}
+/* Configure Vddp used by headset */
+struct vddp_reg {
+	const char *reg_name;
+	unsigned char set_voltage_sup;
+	unsigned int level;
+	struct regulator *reg;
+	bool enabled;
+	bool always_on;
+	bool op_pwr_mode_sup;
+	unsigned int lpm_uA;
+	unsigned int hpm_uA;
+};
+
+struct vddp_reg vddp_reg_headset = {
+	.reg_name = "8058_l5",
+	.set_voltage_sup = 1,
+	.level = 2850000,
+	.always_on = 1,
+	.op_pwr_mode_sup = 1,
+	.lpm_uA = 2000,
+	.hpm_uA = 16000,
+};
+
+struct vddp_reg v_mic_bias_reg_headset = {
+	.reg_name = "8058_l11",
+	.set_voltage_sup = 1,
+	.level = 2850000,
+	.always_on = 0,
+	.op_pwr_mode_sup = 1,
+	.lpm_uA = 16000,
+	.hpm_uA = 16000,
+};
+
+static int headset_vddp_init_reg(struct vddp_reg *vreg)
+{
+	int rc = 0;
+
+	/* Get the regulator handle */
+	vreg->reg = regulator_get(NULL, vreg->reg_name);
+	if (IS_ERR(vreg->reg)) {
+		rc = PTR_ERR(vreg->reg);
+		pr_err("%s: regulator_get(%s) failed. rc=%d\n",
+			__func__, vreg->reg_name, rc);
+		goto out;
+	}
+
+	/* Set the voltage level if required */
+	if (vreg->set_voltage_sup) {
+		rc = regulator_set_voltage(vreg->reg, vreg->level,
+					vreg->level);
+		if (rc) {
+			pr_err("%s: regulator_set_voltage(%s) failed rc=%d\n",
+				__func__, vreg->reg_name, rc);
+			goto vreg_put;
+		}
+	}
+	goto out;
+
+vreg_put:
+	regulator_put(vreg->reg);
+out:
+	return rc;
+}
+
+static int headset_vddp_enable_reg(struct vddp_reg *vreg)
+{
+	int rc;
+
+	if (!vreg->enabled) {
+		rc = regulator_enable(vreg->reg);
+		if (rc) {
+			pr_err("%s: regulator_enable(%s) failed. rc=%d\n",
+				__func__, vreg->reg_name, rc);
+			goto out;
+		}
+		vreg->enabled = 1;
+	}
+
+	/* Put always_on regulator in HPM (high power mode) */
+	if (vreg->always_on && vreg->op_pwr_mode_sup) {
+		rc = regulator_set_optimum_mode(vreg->reg, vreg->hpm_uA);
+		if (rc < 0) {
+			pr_err("%s: reg=%s: HPM setting failed"
+				" hpm_uA=%d, rc=%d\n",
+				__func__, vreg->reg_name,
+				vreg->hpm_uA, rc);
+			goto vreg_disable;
+		}
+		rc = 0;
+	}
+	goto out;
+
+vreg_disable:
+	regulator_disable(vreg->reg);
+	vreg->enabled = 0;
+out:
+	return rc;
+}
+
+static void headset_vddp_disable_reg(struct vddp_reg *vreg)
+{
+	regulator_disable(vreg->reg);
+	vreg->enabled = 0;
+}
+
+static void headset_power(int enable)
+{
+	int ret = 0;
+	if (enable) {
+		pr_info("[HS]Enable headset mic bias\n");
+		ret = headset_vddp_enable_reg(&v_mic_bias_reg_headset);
+		if (ret < 0)
+			pr_err("[HS]Enable Headset MIC bias error\n");
+	} else
+		headset_vddp_disable_reg(&v_mic_bias_reg_headset);
+}
+
+
+static struct platform_device *asoc_devices[] __initdata = {
+	&asoc_msm_pcm,
+	&asoc_msm_dai0,
+	&asoc_msm_dai1,
+};
+
+static struct resource ram_console_resources[] = {
+	{
+		.start	= MSM_RAM_CONSOLE_BASE,
+		.end	= MSM_RAM_CONSOLE_BASE + MSM_RAM_CONSOLE_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ram_console_device = {
+	.name		= "ram_console",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(ram_console_resources),
+	.resource	= ram_console_resources,
+};
+
+#ifdef CONFIG_FB_MSM_HDMI_MHL
+static void mhl_sii9234_1v2_power(bool enable);
+#endif
+
+static uint32_t usb_ID_PIN_input_table[] = {
+	GPIO_CFG(RIDER_GPIO_USB_ID, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+};
+
+static uint32_t usb_ID_PIN_ouput_table[] = {
+	GPIO_CFG(RIDER_GPIO_USB_ID, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+};
+
+static uint32_t mhl_reset_pin_ouput_table[] = {
+	GPIO_CFG(RIDER_GPIO_MHL_RESET, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_4MA),
+};
+
+static uint32_t mhl_usb_switch_ouput_table[] = {
+	GPIO_CFG(RIDER_GPIO_MHL_USB_SW, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_4MA),
+};
+
+void config_rider_mhl_gpios(void)
+{
+	config_gpio_table(mhl_usb_switch_ouput_table,
+			ARRAY_SIZE(mhl_usb_switch_ouput_table));
+	config_gpio_table(mhl_reset_pin_ouput_table,
+			ARRAY_SIZE(mhl_reset_pin_ouput_table));
+}
+
+static struct pm8xxx_mpp_init_info usb_mpp_init_configs[] = {
+	PM8XXX_MPP_INIT(10, D_INPUT, PM8058_MPP_DIG_LEVEL_S3, DIN_TO_INT),
+	PM8XXX_MPP_INIT(11, D_BI_DIR, PM8058_MPP_DIG_LEVEL_S3, BI_PULLUP_10KOHM),
+};
+
+static int mpp_init_setup(struct pm8xxx_mpp_init_info *configs, int length)
+{
+	int ret = 0, i;
+
+	for (i = 0; i < length; i++) {
+		ret = pm8xxx_mpp_config(configs[i].mpp,
+				&configs[i].config);
+		if (ret) {
+			pr_err("%s: Config MPP %d of PM8058 failed\n",
+					__func__, configs[i].mpp);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+static void pm8058_usb_config(void)
+{
+	mpp_init_setup(usb_mpp_init_configs, ARRAY_SIZE(usb_mpp_init_configs));
+}
+
+void config_rider_usb_id_gpios(bool output)
+{
+	if (output) {
+		gpio_tlmm_config(usb_ID_PIN_ouput_table[0], 0);
+		gpio_set_value(RIDER_GPIO_USB_ID, 1);
+		printk(KERN_INFO "%s %d output high\n",  __func__, RIDER_GPIO_USB_ID);
+	} else {
+		gpio_tlmm_config(usb_ID_PIN_input_table[0], 0);
+		printk(KERN_INFO "%s %d input none pull\n",  __func__, RIDER_GPIO_USB_ID);
+	}
+}
+
+static void rider_usb_dpdn_switch(int path)
+{
+	switch (path) {
+	case PATH_USB:
+	case PATH_MHL:
+	{
+		int polarity = 1; /* high = mhl */
+		int mhl = (path == PATH_MHL);
+
+		config_gpio_table(mhl_usb_switch_ouput_table,
+				ARRAY_SIZE(mhl_usb_switch_ouput_table));
+
+		pr_info("[CABLE] %s: Set %s path\n", __func__, mhl ? "MHL" : "USB");
+		gpio_set_value(RIDER_GPIO_MHL_USB_SW, (mhl ^ !polarity) ? 1 : 0);
+		break;
+	}
+	}
+
+	#ifdef CONFIG_FB_MSM_HDMI_MHL
+	sii9234_change_usb_owner((path == PATH_MHL)?1:0);
+	#endif
+}
+
+static struct cable_detect_platform_data cable_detect_pdata = {
+	.vbus_mpp_gpio	= PM8058_MPP_PM_TO_SYS(10),
+	.vbus_mpp_config = pm8058_usb_config,
+	.vbus_mpp_irq  = (PM8058_CBLPWR_IRQ + PM8058_IRQ_BASE),
+	.detect_type = CABLE_TYPE_PMIC_ADC,
+	.usb_id_pin_gpio = RIDER_GPIO_USB_ID,
+	.usb_dpdn_switch = rider_usb_dpdn_switch,
+	.mhl_reset_gpio = RIDER_GPIO_MHL_RESET,
+	.mpp_data = {
+		.usbid_mpp	=  PM8058_MPP_PM_TO_SYS(XOADC_MPP_4),
+		.usbid_amux	= PM_MPP_AIN_AMUX_CH5,
+	},
+	.config_usb_id_gpios = config_rider_usb_id_gpios,
+#ifdef CONFIG_FB_MSM_HDMI_MHL
+	.mhl_1v2_power = mhl_sii9234_1v2_power,
+#endif
+};
+
+static struct platform_device cable_detect_device = {
+	.name	= "cable_detect",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &cable_detect_pdata,
+	},
+};
+
+static struct pm8058_led_config pm_led_config[] = {
+	{
+		.name = "green",
+		.type = PM8058_LED_RGB,
+		.bank = 0,
+		.pwm_size = 9,
+		.clk = PM_PWM_CLK_32KHZ,
+		.pre_div = PM_PWM_PREDIVIDE_2,
+		.pre_div_exp = 1,
+		.pwm_value = 511,
+	},
+	{
+		.name = "amber",
+		.type = PM8058_LED_RGB,
+		.bank = 1,
+		.pwm_size = 9,
+		.clk = PM_PWM_CLK_32KHZ,
+		.pre_div = PM_PWM_PREDIVIDE_2,
+		.pre_div_exp = 1,
+		.pwm_value = 511,
+	},
+	{
+		.name = "button-backlight",
+		.type = PM8058_LED_DRVX,
+		.bank = 6,
+		.flags = PM8058_LED_LTU_EN | PM8058_LED_DYNAMIC_BRIGHTNESS_EN,
+		.period_us = USEC_PER_SEC / 1000,
+		.start_index = 0,
+		.duites_size = 8,
+		.duty_time_ms = 32,
+		.lut_flag = PM_PWM_LUT_RAMP_UP | PM_PWM_LUT_PAUSE_HI_EN,
+		.out_current = 10,
+	},
+
+};
+
+static struct pm8058_led_platform_data pm8058_leds_data = {
+	.led_config = pm_led_config,
+	.num_leds = ARRAY_SIZE(pm_led_config),
+	.duties = {0, 15, 30, 45, 60, 75, 90, 100,
+		   100, 90, 75, 60, 45, 30, 15, 0,
+		   0, 0, 0, 0, 0, 0, 0, 0,
+		   0, 0, 0, 0, 0, 0, 0, 0,
+		   0, 0, 0, 0, 0, 0, 0, 0,
+		   0, 0, 0, 0, 0, 0, 0, 0,
+		   0, 0, 0, 0, 0, 0, 0, 0,
+		   0, 0, 0, 0, 0, 0, 0, 0},
+};
+
+static struct platform_device pm8058_leds = {
+	.name	= "leds-pm8058",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pm8058_leds_data,
+	},
+};
+
+#ifdef CONFIG_FB_MSM_HDMI_MHL
+static int pm8901_mpp_init(void);
+static struct regulator *reg_8901_l0;
+static struct regulator *reg_8058_l19;
+static struct regulator *reg_8901_l3;
+
+static uint32_t msm_hdmi_off_gpio[] = {
+	GPIO_CFG(170,  0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_16MA),
+	GPIO_CFG(171,  0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_16MA),
+	GPIO_CFG(172,  0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+};
+
+static uint32_t msm_hdmi_on_gpio[] = {
+	GPIO_CFG(170,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_16MA),
+	GPIO_CFG(171,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_16MA),
+	GPIO_CFG(172,  1, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+};
+
+void hdmi_hpd_feature(int enable);
+
+static void mhl_sii9234_1v2_power(bool enable)
+{
+	static bool prev_on;
+
+	if (enable == prev_on)
+		return;
+
+	if (enable) {
+		config_gpio_table(msm_hdmi_on_gpio, ARRAY_SIZE(msm_hdmi_on_gpio));
+		hdmi_hpd_feature(1);
+		pr_info("%s(on): success\n", __func__);
+	} else {
+		config_gpio_table(msm_hdmi_off_gpio, ARRAY_SIZE(msm_hdmi_off_gpio));
+		hdmi_hpd_feature(0);
+		pr_info("%s(off): success\n", __func__);
+	}
+
+	prev_on = enable;
+}
+
+static int mhl_sii9234_all_power(bool enable)
+{
+	static bool prev_on;
+	int rc;
+
+	if (enable == prev_on)
+		return 0;
+
+	if (!reg_8058_l19)
+		_GET_REGULATOR(reg_8058_l19, "8058_l19");
+	if (!reg_8901_l3)
+		_GET_REGULATOR(reg_8901_l3, "8901_l3");
+	if (!reg_8901_l0) {
+		if (system_rev >= A01_DEV)
+			_GET_REGULATOR(reg_8901_l0, "8058_l24");
+		else
+			_GET_REGULATOR(reg_8901_l0, "8901_l0");
+	}
+
+	if (enable) {
+		rc = regulator_set_voltage(reg_8058_l19, 1800000, 1800000);
+		if (rc) {
+			pr_err("%s: regulator_set_voltage reg_8058_l19 failed rc=%d\n",
+				__func__, rc);
+			return rc;
+		}
+		rc = regulator_set_voltage(reg_8901_l3, 3300000, 3300000);
+		if (rc) {
+			pr_err("%s: regulator_set_voltage reg_8901_l3 failed rc=%d\n",
+				__func__, rc);
+			return rc;
+		}
+
+		rc = regulator_set_voltage(reg_8901_l0, 1200000, 1200000);
+		if (rc) {
+			pr_err("%s: regulator_set_voltage reg_8901_l0 failed rc=%d\n",
+				__func__, rc);
+			return rc;
+		}	rc = regulator_enable(reg_8058_l19);
+
+		if (rc) {
+			pr_err("'%s' regulator enable failed, rc=%d\n",
+				"reg_8058_l19", rc);
+			return rc;
+		}
+		rc = regulator_enable(reg_8901_l3);
+		if (rc) {
+			pr_err("'%s' regulator enable failed, rc=%d\n",
+				"reg_8901_l3", rc);
+			return rc;
+		}
+
+		rc = regulator_enable(reg_8901_l0);
+		if (rc) {
+			pr_err("'%s' regulator enable failed, rc=%d\n",
+				"reg_8901_l0", rc);
+			return rc;
+		}
+		pr_info("%s(on): success\n", __func__);
+	} else {
+		rc = regulator_disable(reg_8058_l19);
+		if (rc)
+			pr_warning("'%s' regulator disable failed, rc=%d\n",
+				"reg_8058_l19", rc);
+		rc = regulator_disable(reg_8901_l3);
+		if (rc)
+			pr_warning("'%s' regulator disable failed, rc=%d\n",
+				"reg_8901_l3", rc);
+		rc = regulator_disable(reg_8901_l0);
+		if (rc)
+			pr_warning("'%s' regulator disable failed, rc=%d\n",
+				"reg_8901_l0", rc);
+		pr_info("%s(off): success\n", __func__);
+	}
+
+	prev_on = enable;
+
+	return 0;
+}
+
+#ifdef CONFIG_FB_MSM_HDMI_MHL_SII9234
+static uint32_t mhl_gpio_table[] = {
+	GPIO_CFG(RIDER_GPIO_MHL_RESET, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(RIDER_GPIO_MHL_INT, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),
+};
+static int mhl_sii9234_power(int on)
+{
+	int rc = 0;
+
+	switch (on) {
+	case 0:
+		mhl_sii9234_1v2_power(false);
+		break;
+	case 1:
+		mhl_sii9234_all_power(true);
+		pm8901_mpp_init();
+		config_gpio_table(mhl_gpio_table, ARRAY_SIZE(mhl_gpio_table));
+		break;
+	default:
+		pr_warning("%s(%d) got unsupport parameter!!!\n", __func__, on);
+		break;
+	}
+	return rc;
+}
+
+static T_MHL_PLATFORM_DATA mhl_sii9234_device_data = {
+	.gpio_intr = RIDER_GPIO_MHL_INT,
+	.gpio_reset = RIDER_GPIO_MHL_RESET,
+	.ci2ca = 0,
+	#ifdef CONFIG_FB_MSM_HDMI_MHL
+	.mhl_usb_switch		= rider_usb_dpdn_switch,
+	.mhl_1v2_power = mhl_sii9234_1v2_power,
+	#endif
+	.power = mhl_sii9234_power,
+};
+
+static struct i2c_board_info msm_i2c_gsbi7_mhl_sii9234_info[] =
+{
+	{
+		I2C_BOARD_INFO(MHL_SII9234_I2C_NAME, 0x72 >> 1),
+		.platform_data = &mhl_sii9234_device_data,
+		.irq = MSM_GPIO_TO_INT(RIDER_GPIO_MHL_INT)
+	},
+};
+#endif
+#endif
+
+
+static struct platform_device *rider_devices[] __initdata = {
+	&ram_console_device,
+	&msm_device_smd,
+	&msm_device_uart_dm12,
+#ifdef CONFIG_WIMAX_SERIAL_MSM
+	&msm_device_uart3,
+#endif
+#ifdef CONFIG_I2C_QUP
+	&msm_gsbi4_qup_i2c_device,
+	&msm_gsbi5_qup_i2c_device,
+	&msm_gsbi7_qup_i2c_device,
+	&msm_gsbi10_qup_i2c_device,
+#endif
+#ifdef CONFIG_SERIAL_MSM_HS
+	&msm_device_uart_dm1,
+#endif
+#ifdef CONFIG_MSM_SSBI
+	&msm_device_ssbi_pmic1,
+	&msm_device_ssbi_pmic2,
+#endif
+#ifdef CONFIG_I2C_SSBI
+	&msm_device_ssbi2,
+	&msm_device_ssbi3,
+#endif
+#if defined(CONFIG_USB_PEHCI_HCD) || defined(CONFIG_USB_PEHCI_HCD_MODULE)
+	&isp1763_device,
+#endif
+
+#if defined(CONFIG_MSM_8x60_VOIP)
+	&asoc_msm_mvs,
+	&asoc_mvs_dai0,
+	&asoc_mvs_dai1,
+#endif
+
+	&msm_device_otg,
+	&msm_device_hsusb_host,
+#ifdef CONFIG_BATTERY_MSM
+	&msm_batt_device,
+#endif
+#ifdef CONFIG_ANDROID_PMEM
+	&android_pmem_device,
+	&android_pmem_adsp_device,
+	&android_pmem_audio_device,
+	&android_pmem_smipool_device,
+#endif
+#ifdef CONFIG_MSM_ROTATOR
+	&msm_rotator_device,
+#endif
+	&msm_kgsl_3d0,
+	&msm_kgsl_2d0,
+	&msm_kgsl_2d1,
+#ifdef CONFIG_MSM_CAMERA
+#ifdef CONFIG_S5K3H2YX
+	&msm_camera_sensor_s5k3h2yx,
+#endif
+#ifdef CONFIG_S5K6AAFX
+	&msm_camera_sensor_webcam,
+#endif
+#ifdef CONFIG_OV8830
+	&msm_camera_sensor_ov8830,
+#endif
+#endif
+#ifdef CONFIG_MSM_GEMINI
+	&msm_gemini_device,
+#endif
+#ifdef CONFIG_MSM_VPE
+	&msm_vpe_device,
+#endif
+
+#if defined(CONFIG_MSM_RPM_LOG) || defined(CONFIG_MSM_RPM_LOG_MODULE)
+	&msm_rpm_log_device,
+#endif
+#if defined(CONFIG_MSM_RPM_STATS_LOG)
+	&msm_rpm_stat_device,
+#endif
+	&msm_device_vidc,
+#ifdef CONFIG_SENSORS_MSM_ADC
+	&msm_adc_device,
+#endif
+	&rpm_regulator_device,
+
+#if defined(CONFIG_CRYPTO_DEV_QCRYPTO) || \
+		defined(CONFIG_CRYPTO_DEV_QCRYPTO_MODULE)
+	&qcrypto_device,
+#endif
+
+#ifdef CONFIG_HTC_BATT8x60
+	&htc_battery_pdev,
+#endif
+#if defined(CONFIG_CRYPTO_DEV_QCEDEV) || \
+		defined(CONFIG_CRYPTO_DEV_QCEDEV_MODULE)
+	&qcedev_device,
+#endif
+
+
+#if defined(CONFIG_TSIF) || defined(CONFIG_TSIF_MODULE)
+#ifdef CONFIG_MSM_USE_TSIF1
+	&msm_device_tsif[1],
+#else
+	&msm_device_tsif[0],
+#endif /* CONFIG_MSM_USE_TSIF1 */
+#endif /* CONFIG_TSIF */
+
+#ifdef CONFIG_HW_RANDOM_MSM
+	&msm_device_rng,
+#endif
+
+	&msm_rpm_device,
+	&cable_detect_device,
+#ifdef CONFIG_BT
+	&wifi_bt_slp_clk,
+	&rider_rfkill,
+#endif
+	&pm8058_leds,
+	&msm8660_device_watchdog,
+};
+
+static struct memtype_reserve msm8x60_reserve_table[] __initdata = {
+	/* Kernel SMI memory pool for video core, used for firmware */
+	/* and encoder, decoder scratch buffers */
+	/* Kernel SMI memory pool should always precede the user space */
+	/* SMI memory pool, as the video core will use offset address */
+	/* from the Firmware base */
+	[MEMTYPE_SMI_KERNEL] = {
+		.start	=	KERNEL_SMI_BASE,
+		.limit	=	KERNEL_SMI_SIZE,
+		.size	=	KERNEL_SMI_SIZE,
+		.flags	=	MEMTYPE_FLAGS_FIXED,
+	},
+	/* User space SMI memory pool for video core */
+	/* used for encoder, decoder input & output buffers  */
+	[MEMTYPE_SMI] = {
+		.start	=	USER_SMI_BASE,
+		.limit	=	USER_SMI_SIZE,
+		.flags	=	MEMTYPE_FLAGS_FIXED,
+	},
+	[MEMTYPE_EBI0] = {
+		.flags	=	MEMTYPE_FLAGS_1M_ALIGN,
+	},
+};
+
+static void __init size_pmem_device(struct android_pmem_platform_data *pdata, unsigned long start, unsigned long size)
+{
+	pdata->start = start;
+	pdata->size = size;
+	pr_info("%s: allocating %lu bytes at 0x%p (0x%lx physical) for %s\n",
+		__func__, size, __va(start), start, pdata->name);
+}
+static void __init size_pmem_devices(void)
+{
+#ifdef CONFIG_ANDROID_PMEM
+	if (mem_size_mb == 1024) {
+		size_pmem_device(&android_pmem_adsp_pdata, MSM_PMEM_ADSP_BASE+0x10000000, pmem_adsp_size);
+		size_pmem_device(&android_pmem_pdata, MSM_PMEM_SF_BASE+0x10000000, MSM_PMEM_SF_SIZE);
+	} else {
+		size_pmem_device(&android_pmem_adsp_pdata, MSM_PMEM_ADSP_BASE, pmem_adsp_size);
+		size_pmem_device(&android_pmem_pdata, MSM_PMEM_SF_BASE, MSM_PMEM_SF_SIZE);
+	}
+	size_pmem_device(&android_pmem_smipool_pdata, MSM_PMEM_SMIPOOL_BASE, MSM_PMEM_SMIPOOL_SIZE);
+	size_pmem_device(&android_pmem_audio_pdata, MSM_PMEM_AUDIO_BASE, MSM_PMEM_AUDIO_SIZE);
+#endif
+}
+
+static void __init reserve_memory_for(struct android_pmem_platform_data *p)
+{
+	/* If we have set a pre-defined PMEM start base,
+	 * no need to reserve it in system again.
+	 */
+	if (p->start == 0) {
+		pr_info("%s: reserving %lx bytes in memory pool for %s.\n", __func__, p->size, p->name);
+		msm8x60_reserve_table[p->memory_type].size += p->size;
+	}
+}
+
+static void __init reserve_pmem_memory(void)
+{
+#ifdef CONFIG_ANDROID_PMEM
+	reserve_memory_for(&android_pmem_adsp_pdata);
+	reserve_memory_for(&android_pmem_smipool_pdata);
+	reserve_memory_for(&android_pmem_audio_pdata);
+	reserve_memory_for(&android_pmem_pdata);
+#endif
+}
+
+static void __init msm8x60_calculate_reserve_sizes(void)
+{
+	size_pmem_devices();
+	reserve_pmem_memory();
+}
+
+static int msm8x60_paddr_to_memtype(unsigned int paddr)
+{
+	if (paddr >= 0x40000000 && paddr < 0x60000000)
+		return MEMTYPE_EBI1;
+	if (paddr >= 0x38000000 && paddr < 0x40000000)
+		return MEMTYPE_SMI;
+	return MEMTYPE_NONE;
+}
+
+static struct reserve_info msm8x60_reserve_info __initdata = {
+	.memtype_reserve_table = msm8x60_reserve_table,
+	.calculate_reserve_sizes = msm8x60_calculate_reserve_sizes,
+	.paddr_to_memtype = msm8x60_paddr_to_memtype,
+};
+
+static void __init rider_reserve(void)
+{
+	reserve_info = &msm8x60_reserve_info;
+	msm_reserve();
+}
+
+#define EXT_CHG_VALID_MPP 10
+#define EXT_CHG_VALID_MPP_2 11
+
+#ifdef CONFIG_PMIC8058
+
+static int pm8058_gpios_init(void)
+{
+	int i;
+	int rc;
+	struct pm8058_gpio_cfg {
+		int                gpio;
+		struct pm_gpio cfg;
+	};
+
+	struct pm8058_gpio_cfg gpio_cfgs[] = {
+#ifdef CONFIG_MMC_MSM_CARD_HW_DETECTION
+		{
+			PM8058_GPIO_PM_TO_SYS(RIDER_SDC3_DET),
+			{
+				.direction      = PM_GPIO_DIR_IN,
+				.pull           = PM_GPIO_PULL_UP_30,
+				.vin_sel        = 2,
+				.function       = PM_GPIO_FUNC_NORMAL,
+				.inv_int_pol    = 0,
+			},
+		},
+#endif
+		{ /* Audio Microphone Selector */
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_MIC_SEL),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 0,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_NORMAL,
+				.vin_sel	= 2,	/* LDO 1.8 V */
+				.inv_int_pol	= 0,
+			}
+		},
+		{ /* Audio Receiver Amplifier */
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_HANDSET_ENO),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 0,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_NORMAL,
+				.vin_sel	= 6,	/* LDO5 2.85 V */
+				.inv_int_pol	= 0,
+			}
+		},
+		{ /* Audio Speaker Amplifier */
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_SPK_ENO),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 0,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_NORMAL,
+				.vin_sel	= 6,	/* LDO5 2.85 V */
+				.inv_int_pol	= 0,
+			}
+		},
+		{ /* Timpani Reset */
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_QTR_RESET),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 0,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_NORMAL,
+				.vin_sel	= 2,
+				.inv_int_pol	= 0,
+			}
+		},
+		{ /* Green LED */
+			PM8058_GPIO_PM_TO_SYS(RIDER_GREEN_LED),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 1,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_2,
+				.vin_sel	= PM8058_GPIO_VIN_L5,
+				.inv_int_pol	= 0,
+			}
+		},
+		{ /* AMBER */
+			PM8058_GPIO_PM_TO_SYS(RIDER_AMBER_LED),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 1,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_2,
+				.vin_sel	= PM8058_GPIO_VIN_L5,
+				.inv_int_pol	= 0,
+			}
+		},
+		{
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_REMO_EN),
+			{
+				.direction	= PM_GPIO_DIR_OUT,
+				.output_value	= 0,
+				.output_buffer	= PM_GPIO_OUT_BUF_CMOS,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_NORMAL,
+				.vin_sel	= PM8058_GPIO_VIN_S3, /* 1.8 V */
+				.inv_int_pol	= 0,
+			}
+		},
+		{
+			PM8058_GPIO_PM_TO_SYS(RIDER_WIMAX_HOST_WAKEUP),
+			{
+				.direction	= PM_GPIO_DIR_IN,
+				.output_value	= 0,
+				.output_buffer	= 0,
+				.pull		= PM_GPIO_PULL_NO,
+				.out_strength	= PM_GPIO_STRENGTH_HIGH,
+				.function	= PM_GPIO_FUNC_NORMAL,
+				.vin_sel	= PM8058_GPIO_VIN_S3,
+				.inv_int_pol	= 0,
+			}
+		},
+		{
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_REMO_PRES),
+			{
+				.direction      = PM_GPIO_DIR_IN,
+				.pull           = PM_GPIO_PULL_NO,
+				.vin_sel        = PM8058_GPIO_VIN_L5, /* 2.85 V */
+				.function       = PM_GPIO_FUNC_NORMAL,
+				.inv_int_pol    = 0,
+			},
+		},
+	};
+
+	for (i = 0; i < ARRAY_SIZE(gpio_cfgs); ++i) {
+		rc = pm8xxx_gpio_config(gpio_cfgs[i].gpio,
+				&gpio_cfgs[i].cfg);
+		if (rc < 0) {
+			pr_err("%s pmic gpio config failed\n",
+				__func__);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static struct pm8xxx_vibrator_platform_data pm8058_vib_pdata = {
+       .initial_vibrate_ms  = 0,
+       .level_mV = 3000,
+       .max_timeout_ms = 15000,
+};
+
+#define PM8058_LINE_IN_DET_GPIO	PM8058_GPIO_PM_TO_SYS(18)
+
+static struct othc_accessory_info othc_accessories[]  = {
+	{
+		.accessory = OTHC_SVIDEO_OUT,
+		.detect_flags = OTHC_MICBIAS_DETECT | OTHC_SWITCH_DETECT
+							| OTHC_ADC_DETECT,
+		.key_code = SW_VIDEOOUT_INSERT,
+		.enabled = false,
+		.adc_thres = {
+				.min_threshold = 20,
+				.max_threshold = 40,
+			},
+	},
+	{
+		.accessory = OTHC_ANC_HEADPHONE,
+		.detect_flags = OTHC_MICBIAS_DETECT | OTHC_GPIO_DETECT |
+							OTHC_SWITCH_DETECT,
+		.gpio = PM8058_LINE_IN_DET_GPIO,
+		.active_low = 1,
+		.key_code = SW_HEADPHONE_INSERT,
+		.enabled = true,
+	},
+	{
+		.accessory = OTHC_ANC_HEADSET,
+		.detect_flags = OTHC_MICBIAS_DETECT | OTHC_GPIO_DETECT,
+		.gpio = PM8058_LINE_IN_DET_GPIO,
+		.active_low = 1,
+		.key_code = SW_HEADPHONE_INSERT,
+		.enabled = true,
+	},
+	{
+		.accessory = OTHC_HEADPHONE,
+		.detect_flags = OTHC_MICBIAS_DETECT | OTHC_SWITCH_DETECT,
+		.key_code = SW_HEADPHONE_INSERT,
+		.enabled = true,
+	},
+	{
+		.accessory = OTHC_MICROPHONE,
+		.detect_flags = OTHC_GPIO_DETECT,
+		.gpio = PM8058_LINE_IN_DET_GPIO,
+		.active_low = 1,
+		.key_code = SW_MICROPHONE_INSERT,
+		.enabled = true,
+	},
+	{
+		.accessory = OTHC_HEADSET,
+		.detect_flags = OTHC_MICBIAS_DETECT,
+		.key_code = SW_HEADPHONE_INSERT,
+		.enabled = true,
+	},
+};
+
+
+static struct othc_switch_info switch_info[] = {
+	{
+		.min_adc_threshold = 0,
+		.max_adc_threshold = 100,
+		.key_code = KEY_PLAYPAUSE,
+	},
+	{
+		.min_adc_threshold = 100,
+		.max_adc_threshold = 200,
+		.key_code = KEY_REWIND,
+	},
+	{
+		.min_adc_threshold = 200,
+		.max_adc_threshold = 500,
+		.key_code = KEY_FASTFORWARD,
+	},
+};
+
+static struct othc_n_switch_config switch_config = {
+	.voltage_settling_time_ms = 0,
+	.num_adc_samples = 3,
+	.adc_channel = CHANNEL_ADC_HDSET,
+	.switch_info = switch_info,
+	.num_keys = ARRAY_SIZE(switch_info),
+	.default_sw_en = true,
+	.default_sw_idx = 0,
+};
+
+static struct hsed_bias_config hsed_bias_config = {
+	/* HSED mic bias config info */
+	.othc_headset = OTHC_HEADSET_NO,
+	.othc_lowcurr_thresh_uA = 100,
+	.othc_highcurr_thresh_uA = 600,
+	.othc_hyst_prediv_us = 7800,
+	.othc_period_clkdiv_us = 62500,
+	.othc_hyst_clk_us = 121000,
+	.othc_period_clk_us = 312500,
+	.othc_wakeup = 1,
+};
+
+static struct othc_hsed_config hsed_config_1 = {
+	.hsed_bias_config = &hsed_bias_config,
+	/*
+	 * The detection delay and switch reporting delay are
+	 * required to encounter a hardware bug (spurious switch
+	 * interrupts on slow insertion/removal of the headset).
+	 * This will introduce a delay in reporting the accessory
+	 * insertion and removal to the userspace.
+	 */
+	.detection_delay_ms = 1500,
+	/* Switch info */
+	.switch_debounce_ms = 1500,
+	.othc_support_n_switch = false,
+	.switch_config = &switch_config,
+	.ir_gpio = -1,
+	/* Accessory info */
+	.accessories_support = true,
+	.accessories = othc_accessories,
+	.othc_num_accessories = ARRAY_SIZE(othc_accessories),
+};
+
+static struct othc_regulator_config othc_reg = {
+	.regulator	 = "8058_l5",
+	.max_uV		 = 2850000,
+	.min_uV		 = 2850000,
+};
+
+/* MIC_BIAS0 is configured as normal MIC BIAS */
+static struct pmic8058_othc_config_pdata othc_config_pdata_0 = {
+	.micbias_select = OTHC_MICBIAS_0,
+	.micbias_capability = OTHC_MICBIAS,
+	.micbias_enable = OTHC_SIGNAL_OFF,
+	.micbias_regulator = &othc_reg,
+};
+
+/* MIC_BIAS1 is configured as back mic BIAS for OTHC */
+static struct pmic8058_othc_config_pdata othc_config_pdata_1 = {
+	.micbias_select = OTHC_MICBIAS_1,
+	.micbias_capability = OTHC_MICBIAS,
+	.micbias_enable = OTHC_SIGNAL_OFF,
+	.micbias_regulator = &othc_reg,
+};
+
+/* MIC_BIAS2 is configured as headset BIAS for OTHC */
+static struct pmic8058_othc_config_pdata othc_config_pdata_2 = {
+	.micbias_select = OTHC_MICBIAS_2,
+	.micbias_capability = OTHC_MICBIAS,
+	.micbias_enable = OTHC_SIGNAL_OFF,
+	.micbias_regulator = &othc_reg,
+};
+
+static void __init msm8x60_init_pm8058_othc(void)
+{
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 2) {
+		/* 3-switch headset supported only by V2 FFA and FLUID */
+		hsed_config_1.accessories_adc_support = true,
+		/* ADC based accessory detection works only on V2 and FLUID */
+		hsed_config_1.accessories_adc_channel = CHANNEL_ADC_HDSET,
+		hsed_config_1.othc_support_n_switch = true;
+	}
+}
+
+static int pm8058_pwm_config(struct pwm_device *pwm, int ch, int on)
+{
+	struct pm_gpio pwm_gpio_config = {
+		.direction      = PM_GPIO_DIR_OUT,
+		.output_buffer  = PM_GPIO_OUT_BUF_CMOS,
+		.output_value   = 0,
+		.pull           = PM_GPIO_PULL_NO,
+		.vin_sel        = PM8058_GPIO_VIN_VPH,
+		.out_strength   = PM_GPIO_STRENGTH_HIGH,
+		.function       = PM_GPIO_FUNC_2,
+	};
+
+	int rc = -EINVAL;
+	int id, mode, max_mA;
+
+	id = mode = max_mA = 0;
+	switch (ch) {
+	case 0:
+	case 1:
+	case 2:
+		if (on) {
+			id = 24 + ch;
+			rc = pm8xxx_gpio_config(PM8058_GPIO_PM_TO_SYS(id - 1), &pwm_gpio_config);
+			if (rc)
+				pr_err("%s: pm8xxx_gpio_config(%d): rc=%d\n",
+					__func__, id, rc);
+		}
+		break;
+
+	case 6:
+		id = PM_PWM_LED_FLASH;
+		mode = PM_PWM_CONF_PWM1;
+		max_mA = 300;
+		break;
+
+	case 7:
+		id = PM_PWM_LED_FLASH1;
+		mode = PM_PWM_CONF_PWM1;
+		max_mA = 300;
+		break;
+
+	default:
+		break;
+	}
+
+	if (ch >= 6 && ch <= 7) {
+		if (!on) {
+			mode = PM_PWM_CONF_NONE;
+			max_mA = 0;
+		}
+		rc = pm8058_pwm_config_led(pwm, id, mode, max_mA);
+		if (rc)
+			pr_err("%s: pm8058_pwm_config_led(ch=%d): rc=%d\n",
+			       __func__, ch, rc);
+	}
+	return rc;
+
+}
+
+static struct pm8058_pwm_pdata pm8058_pwm_data = {
+	.config		= pm8058_pwm_config,
+};
+
+static struct pm8xxx_rtc_platform_data pm8058_rtc_pdata = {
+	.rtc_write_enable	= true,
+	.rtc_alarm_powerup	= false,
+};
+
+static struct pm8xxx_pwrkey_platform_data pm8058_pwrkey_pdata = {
+	.pull_up		= 1,
+	.kpd_trigger_delay_us	= 970,
+	.wakeup			= 1,
+};
+
+#define PM8058_GPIO_INT           88
+
+static struct pmic8058_led pmic8058_flash_leds[] = {
+	[0] = {
+		.name		= "camera:flash0",
+		.max_brightness = 15,
+		.id		= PMIC8058_ID_FLASH_LED_0,
+	},
+	[1] = {
+		.name		= "camera:flash1",
+		.max_brightness = 15,
+		.id		= PMIC8058_ID_FLASH_LED_1,
+	},
+};
+
+static struct pmic8058_leds_platform_data pm8058_flash_leds_data = {
+	.num_leds = ARRAY_SIZE(pmic8058_flash_leds),
+	.leds	= pmic8058_flash_leds,
+};
+
+static struct pm8xxx_misc_platform_data pm8058_misc_pdata = {
+	.priority		= 0,
+};
+
+static struct pm8xxx_irq_platform_data pm8058_irq_pdata = {
+	.irq_base		= PM8058_IRQ_BASE,
+	.devirq			= MSM_GPIO_TO_INT(PM8058_GPIO_INT),
+	.irq_trigger_flag	= IRQF_TRIGGER_LOW,
+};
+
+static struct pm8xxx_gpio_platform_data pm8058_gpio_pdata = {
+	.gpio_base	= PM8058_GPIO_PM_TO_SYS(0),
+};
+
+static struct pm8xxx_mpp_platform_data pm8058_mpp_pdata = {
+	.mpp_base	= PM8058_MPP_PM_TO_SYS(0),
+};
+
+static struct pm8058_platform_data pm8058_platform_data = {
+	.irq_pdata		= &pm8058_irq_pdata,
+	.gpio_pdata		= &pm8058_gpio_pdata,
+	.mpp_pdata		= &pm8058_mpp_pdata,
+	.rtc_pdata		= &pm8058_rtc_pdata,
+	.pwrkey_pdata		= &pm8058_pwrkey_pdata,
+	.othc0_pdata		= &othc_config_pdata_0,
+	.othc1_pdata		= &othc_config_pdata_1,
+	.othc2_pdata		= &othc_config_pdata_2,
+	.pwm_pdata		= &pm8058_pwm_data,
+	.misc_pdata		= &pm8058_misc_pdata,
+#ifdef CONFIG_SENSORS_MSM_ADC
+	.xoadc_pdata		= &pm8058_xoadc_pdata,
+#endif
+	.keypad_pdata		= NULL, /* No keypad pdata */
+	.charger_pdata		= NULL, /* No charger pdata */
+	.leds_pdata		= &pm8058_flash_leds_data,
+	.vibrator_pdata		= &pm8058_vib_pdata,
+
+	.regulator_pdatas	= NULL,
+	.num_regulators		= 0,
+
+	.xo_buffer_pdata	= NULL,
+	.num_xo_buffers		= 0,
+};
+
+#ifdef CONFIG_MSM_SSBI
+static struct msm_ssbi_platform_data msm8x60_ssbi_pm8058_pdata __devinitdata = {
+	.controller_type = MSM_SBI_CTRL_PMIC_ARBITER,
+	.slave	= {
+		.name			= "pm8058-core",
+		.platform_data		= &pm8058_platform_data,
+	},
+};
+#endif
+#endif  /* CONFIG_PMIC8058 */
+
+#if defined(CONFIG_TOUCHDISC_VTD518_SHINETSU) || \
+		defined(CONFIG_TOUCHDISC_VTD518_SHINETSU_MODULE)
+#define TDISC_I2C_SLAVE_ADDR	0x67
+#define PMIC_GPIO_TDISC		PM8058_GPIO_PM_TO_SYS(5)
+#define TDISC_INT		PM8058_GPIO_IRQ(PM8058_IRQ_BASE, 5)
+
+static const char *vregs_tdisc_name[] = {
+	"8058_l5",
+	"8058_s3",
+};
+
+static const int vregs_tdisc_val[] = {
+	2850000,/* uV */
+	1800000,
+};
+static struct regulator *vregs_tdisc[ARRAY_SIZE(vregs_tdisc_name)];
+
+static int tdisc_shinetsu_setup(void)
+{
+	int rc, i;
+
+	rc = gpio_request(PMIC_GPIO_TDISC, "tdisc_interrupt");
+	if (rc) {
+		pr_err("%s: gpio_request failed for PMIC_GPIO_TDISC\n",
+								__func__);
+		return rc;
+	}
+
+	rc = gpio_request(GPIO_JOYSTICK_EN, "tdisc_oe");
+	if (rc) {
+		pr_err("%s: gpio_request failed for GPIO_JOYSTICK_EN\n",
+							__func__);
+		goto fail_gpio_oe;
+	}
+
+	rc = gpio_direction_output(GPIO_JOYSTICK_EN, 1);
+	if (rc) {
+		pr_err("%s: gpio_direction_output failed for GPIO_JOYSTICK_EN\n",
+								__func__);
+		gpio_free(GPIO_JOYSTICK_EN);
+		goto fail_gpio_oe;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(vregs_tdisc_name); i++) {
+		vregs_tdisc[i] = regulator_get(NULL, vregs_tdisc_name[i]);
+		if (IS_ERR(vregs_tdisc[i])) {
+			printk(KERN_ERR "%s: regulator get %s failed (%ld)\n",
+				__func__, vregs_tdisc_name[i],
+				PTR_ERR(vregs_tdisc[i]));
+			rc = PTR_ERR(vregs_tdisc[i]);
+			goto vreg_get_fail;
+		}
+
+		rc = regulator_set_voltage(vregs_tdisc[i],
+				vregs_tdisc_val[i], vregs_tdisc_val[i]);
+		if (rc) {
+			printk(KERN_ERR "%s: regulator_set_voltage() = %d\n",
+				__func__, rc);
+			goto vreg_set_voltage_fail;
+		}
+	}
+
+	return rc;
+vreg_set_voltage_fail:
+	i++;
+vreg_get_fail:
+	while (i)
+		regulator_put(vregs_tdisc[--i]);
+fail_gpio_oe:
+	gpio_free(PMIC_GPIO_TDISC);
+	return rc;
+}
+
+static void tdisc_shinetsu_release(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vregs_tdisc_name); i++)
+		regulator_put(vregs_tdisc[i]);
+
+	gpio_free(PMIC_GPIO_TDISC);
+	gpio_free(GPIO_JOYSTICK_EN);
+}
+
+static int tdisc_shinetsu_enable(void)
+{
+	int i, rc = -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(vregs_tdisc_name); i++) {
+		rc = regulator_enable(vregs_tdisc[i]);
+		if (rc < 0) {
+			printk(KERN_ERR "%s: vreg %s enable failed (%d)\n",
+				__func__, vregs_tdisc_name[i], rc);
+			goto vreg_fail;
+		}
+	}
+
+	/* Enable the OE (output enable) gpio */
+	gpio_set_value_cansleep(GPIO_JOYSTICK_EN, 1);
+	/* voltage and gpio stabilization delay */
+	msleep(50);
+
+	return 0;
+vreg_fail:
+	while (i)
+		regulator_disable(vregs_tdisc[--i]);
+	return rc;
+}
+
+static int tdisc_shinetsu_disable(void)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(vregs_tdisc_name); i++) {
+		rc = regulator_disable(vregs_tdisc[i]);
+		if (rc < 0) {
+			printk(KERN_ERR "%s: vreg %s disable failed (%d)\n",
+				__func__, vregs_tdisc_name[i], rc);
+			goto tdisc_reg_fail;
+		}
+	}
+
+	/* Disable the OE (output enable) gpio */
+	gpio_set_value_cansleep(GPIO_JOYSTICK_EN, 0);
+
+	return 0;
+
+tdisc_reg_fail:
+	while (i)
+		regulator_enable(vregs_tdisc[--i]);
+	return rc;
+}
+
+static struct tdisc_abs_values tdisc_abs = {
+	.x_max = 32,
+	.y_max = 32,
+	.x_min = -32,
+	.y_min = -32,
+	.pressure_max = 32,
+	.pressure_min = 0,
+};
+
+static struct tdisc_platform_data tdisc_data = {
+	.tdisc_setup = tdisc_shinetsu_setup,
+	.tdisc_release = tdisc_shinetsu_release,
+	.tdisc_enable = tdisc_shinetsu_enable,
+	.tdisc_disable = tdisc_shinetsu_disable,
+	.tdisc_wakeup  = 0,
+	.tdisc_gpio = PMIC_GPIO_TDISC,
+	.tdisc_report_keys = true,
+	.tdisc_report_relative = true,
+	.tdisc_report_absolute = false,
+	.tdisc_report_wheel = false,
+	.tdisc_reverse_x = false,
+	.tdisc_reverse_y = true,
+	.tdisc_abs  = &tdisc_abs,
+};
+
+static struct i2c_board_info msm_i2c_gsbi3_tdisc_info[] = {
+	{
+		I2C_BOARD_INFO("vtd518", TDISC_I2C_SLAVE_ADDR),
+		.irq =  TDISC_INT,
+		.platform_data = &tdisc_data,
+	},
+};
+#endif
+
+#define PM_GPIO_CDC_RST_N 20
+#define GPIO_CDC_RST_N PM8058_GPIO_PM_TO_SYS(PM_GPIO_CDC_RST_N)
+
+#if HASTIMPANI
+static struct regulator *vreg_timpani_1;
+static struct regulator *vreg_timpani_2;
+
+static unsigned int msm_timpani_setup_power(void)
+{
+	int rc;
+
+	vreg_timpani_1 = regulator_get(NULL, "8058_l0");
+	if (IS_ERR(vreg_timpani_1)) {
+		pr_err("%s: Unable to get 8058_l0\n", __func__);
+		return -ENODEV;
+	}
+
+	vreg_timpani_2 = regulator_get(NULL, "8058_s3");
+	if (IS_ERR(vreg_timpani_2)) {
+		pr_err("%s: Unable to get 8058_s3\n", __func__);
+		regulator_put(vreg_timpani_1);
+		return -ENODEV;
+	}
+
+	rc = regulator_set_voltage(vreg_timpani_1, 1200000, 1200000);
+	if (rc) {
+		pr_err("%s: unable to set L0 voltage to 1.2V\n", __func__);
+		goto fail;
+	}
+
+	rc = regulator_set_voltage(vreg_timpani_2, 1800000, 1800000);
+	if (rc) {
+		pr_err("%s: unable to set S3 voltage to 1.8V\n", __func__);
+		goto fail;
+	}
+
+	rc = regulator_enable(vreg_timpani_1);
+	if (rc) {
+		pr_err("%s: Enable regulator 8058_l0 failed\n", __func__);
+		goto fail;
+	}
+
+	/* The settings for LDO0 should be set such that
+	*  it doesn't require to reset the timpani. */
+	rc = regulator_set_optimum_mode(vreg_timpani_1, 5000);
+	if (rc < 0) {
+		pr_err("Timpani regulator optimum mode setting failed\n");
+		goto fail;
+	}
+
+	rc = regulator_enable(vreg_timpani_2);
+	if (rc) {
+		pr_err("%s: Enable regulator 8058_s3 failed\n", __func__);
+		regulator_disable(vreg_timpani_1);
+		goto fail;
+	}
+
+	rc = gpio_request(GPIO_CDC_RST_N, "CDC_RST_N");
+	if (rc) {
+		pr_err("%s: GPIO Request %d failed\n", __func__,
+			GPIO_CDC_RST_N);
+		regulator_disable(vreg_timpani_1);
+		regulator_disable(vreg_timpani_2);
+		goto fail;
+	} else {
+		gpio_direction_output(GPIO_CDC_RST_N, 1);
+		usleep_range(1000, 1050);
+		gpio_direction_output(GPIO_CDC_RST_N, 0);
+		usleep_range(1000, 1050);
+		gpio_direction_output(GPIO_CDC_RST_N, 1);
+		gpio_free(GPIO_CDC_RST_N);
+	}
+	return rc;
+
+fail:
+	regulator_put(vreg_timpani_1);
+	regulator_put(vreg_timpani_2);
+	return rc;
+}
+
+static void msm_timpani_shutdown_power(void)
+{
+	int rc;
+
+	rc = regulator_disable(vreg_timpani_1);
+	if (rc)
+		pr_err("%s: Disable regulator 8058_l0 failed\n", __func__);
+
+	regulator_put(vreg_timpani_1);
+
+	rc = regulator_disable(vreg_timpani_2);
+	if (rc)
+		pr_err("%s: Disable regulator 8058_s3 failed\n", __func__);
+
+	regulator_put(vreg_timpani_2);
+}
+
+/* Power analog function of codec */
+static struct regulator *vreg_timpani_cdc_apwr;
+static int msm_timpani_codec_power(int vreg_on)
+{
+	int rc = 0;
+
+	if (!vreg_timpani_cdc_apwr) {
+
+		vreg_timpani_cdc_apwr = regulator_get(NULL, "8058_s4");
+
+		if (IS_ERR(vreg_timpani_cdc_apwr)) {
+			pr_err("%s: vreg_get failed (%ld)\n",
+			__func__, PTR_ERR(vreg_timpani_cdc_apwr));
+			rc = PTR_ERR(vreg_timpani_cdc_apwr);
+			return rc;
+		}
+	}
+
+	if (vreg_on) {
+
+		rc = regulator_set_voltage(vreg_timpani_cdc_apwr,
+				2200000, 2200000);
+		if (rc) {
+			pr_err("%s: unable to set 8058_s4 voltage to 2.2 V\n",
+					__func__);
+			goto vreg_fail;
+		}
+
+		rc = regulator_enable(vreg_timpani_cdc_apwr);
+		if (rc) {
+			pr_err("%s: vreg_enable failed %d\n", __func__, rc);
+			goto vreg_fail;
+		}
+	} else {
+		rc = regulator_disable(vreg_timpani_cdc_apwr);
+		if (rc) {
+			pr_err("%s: vreg_disable failed %d\n",
+			__func__, rc);
+			goto vreg_fail;
+		}
+	}
+
+	return 0;
+
+vreg_fail:
+	regulator_put(vreg_timpani_cdc_apwr);
+	vreg_timpani_cdc_apwr = NULL;
+	return rc;
+}
+
+static struct marimba_codec_platform_data timpani_codec_pdata = {
+	.marimba_codec_power =  msm_timpani_codec_power,
+};
+
+#define TIMPANI_SLAVE_ID_CDC_ADDR		0X77
+#define TIMPANI_SLAVE_ID_QMEMBIST_ADDR		0X66
+
+static struct marimba_platform_data timpani_pdata = {
+	.slave_id[MARIMBA_SLAVE_ID_CDC] = TIMPANI_SLAVE_ID_CDC_ADDR,
+	.slave_id[MARIMBA_SLAVE_ID_QMEMBIST] = TIMPANI_SLAVE_ID_QMEMBIST_ADDR,
+	.marimba_setup = msm_timpani_setup_power,
+	.marimba_shutdown = msm_timpani_shutdown_power,
+	.codec = &timpani_codec_pdata,
+	.tsadc_ssbi_adap = MARIMBA_SSBI_ADAP,
+};
+
+#define TIMPANI_I2C_SLAVE_ADDR	0xD
+
+static struct i2c_board_info msm_i2c_gsbi7_timpani_info[] = {
+	{
+		I2C_BOARD_INFO("timpani", TIMPANI_I2C_SLAVE_ADDR),
+		.platform_data = &timpani_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_SND_SOC_WM8903
+static struct wm8903_platform_data wm8903_pdata = {
+	.gpio_cfg[2] = 0x3A8,
+};
+
+#define WM8903_I2C_SLAVE_ADDR 0x34
+static struct i2c_board_info wm8903_codec_i2c_info[] = {
+	{
+		I2C_BOARD_INFO("wm8903", WM8903_I2C_SLAVE_ADDR >> 1),
+		.platform_data = &wm8903_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_MSM8X60_AUDIO
+static uint32_t msm_spi_gpio[] = {
+	GPIO_CFG(RIDER_SPI_DO,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(RIDER_SPI_DI,  1, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+	GPIO_CFG(RIDER_SPI_CS,  1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(RIDER_SPI_CLK, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+};
+
+static uint32_t auxpcm_gpio_table[] = {
+	GPIO_CFG(111, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(112, 1, GPIO_CFG_INPUT,  GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
+	GPIO_CFG(113, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+	GPIO_CFG(114, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),
+};
+
+static void msm_auxpcm_init(void)
+{
+	gpio_tlmm_config(auxpcm_gpio_table[0], GPIO_CFG_ENABLE);
+	gpio_tlmm_config(auxpcm_gpio_table[1], GPIO_CFG_ENABLE);
+	gpio_tlmm_config(auxpcm_gpio_table[2], GPIO_CFG_ENABLE);
+	gpio_tlmm_config(auxpcm_gpio_table[3], GPIO_CFG_ENABLE);
+}
+
+static struct tpa2051d3_platform_data tpa2051d3_pdata = {
+	.gpio_tpa2051_spk_en = PM8058_GPIO_PM_TO_SYS(RIDER_AUD_SPK_ENO),
+	.spkr_cmd = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	.hsed_cmd = {0x00, 0x0C, 0x25, 0x57, 0x6D, 0x4D, 0x0D},
+	.rece_cmd = {0x00, 0x02, 0x25, 0x57, 0x0D, 0x4D, 0x0D},
+};
+#define TPA2051D3_I2C_SLAVE_ADDR	(0xE0 >> 1)
+
+static struct i2c_board_info msm_i2c_gsbi7_tpa2051d3_info[] = {
+	{
+		I2C_BOARD_INFO(TPA2051D3_I2C_NAME, TPA2051D3_I2C_SLAVE_ADDR),
+		.platform_data = &tpa2051d3_pdata,
+	},
+};
+
+void msm_snddev_voltage_on(void)
+{
+}
+
+void __init rider_audio_init(void);
+
+void msm_snddev_voltage_off(void)
+{
+}
+static struct spi_board_info msm_spi_board_info[] __initdata = {
+	{
+		.modalias	= "spi_aic3254",
+		.mode           = SPI_MODE_1,
+		.bus_num        = 0,
+		.chip_select    = 0,
+		.max_speed_hz   = 10800000,
+	}
+};
+#endif /* CONFIG_MSM8X60_AUDIO */
+
+#ifdef CONFIG_PMIC8901
+
+#define PM8901_GPIO_INT           91
+
+#ifdef CONFIG_FB_MSM_HDMI_MHL
+static int pm8901_mpp_init(void)
+{
+	int rc;
+	pr_err("%s\n", __func__);
+
+	rc = pm8901_mpp_config(0, PM_MPP_TYPE_D_BI_DIR,
+			PM8901_MPP_DIG_LEVEL_MSMIO,
+			PM_MPP_BI_PULLUP_10KOHM);
+	if (rc)
+		pr_err("%s: pm8901_mpp_config failed with %d\n", __func__, rc);
+
+
+	rc = pm8901_mpp_config(1, PM_MPP_TYPE_D_BI_DIR,
+			PM8901_MPP_DIG_LEVEL_L5,
+			PM_MPP_BI_PULLUP_10KOHM);
+	if (rc)
+		pr_err("%s: pm8901_mpp_config failed with %d\n", __func__, rc);
+
+
+	rc = pm8901_mpp_config(2, PM_MPP_TYPE_D_BI_DIR,
+			PM8901_MPP_DIG_LEVEL_MSMIO,
+			PM_MPP_BI_PULLUP_10KOHM);
+	if (rc)
+		pr_err("%s: pm8901_mpp_config failed with %d\n", __func__, rc);
+
+
+	rc = pm8901_mpp_config(3, PM_MPP_TYPE_D_BI_DIR,
+			PM8901_MPP_DIG_LEVEL_L5,
+			PM_MPP_BI_PULLUP_10KOHM);
+	if (rc)
+		pr_err("%s: pm8901_mpp_config failed with %d\n", __func__, rc);
+
+	return rc;
+}
+#endif
+
+static struct pm8901_gpio_platform_data pm8901_mpp_data = {
+	.gpio_base	= PM8901_GPIO_PM_TO_SYS(0),
+	.irq_base	= PM8901_MPP_IRQ(PM8901_IRQ_BASE, 0),
+};
+
+static struct resource pm8901_temp_alarm[] = {
+	{
+		.start = PM8901_TEMP_ALARM_IRQ(PM8901_IRQ_BASE),
+		.end = PM8901_TEMP_ALARM_IRQ(PM8901_IRQ_BASE),
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = PM8901_TEMP_HI_ALARM_IRQ(PM8901_IRQ_BASE),
+		.end = PM8901_TEMP_HI_ALARM_IRQ(PM8901_IRQ_BASE),
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*
+ * Consumer specific regulator names:
+ *			 regulator name		consumer dev_name
+ */
+static struct regulator_consumer_supply vreg_consumers_8901_MPP0[] = {
+	REGULATOR_SUPPLY("8901_mpp0",		NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_8901_USB_OTG[] = {
+	REGULATOR_SUPPLY("8901_usb_otg",	NULL),
+};
+static struct regulator_consumer_supply vreg_consumers_8901_HDMI_MVS[] = {
+	REGULATOR_SUPPLY("8901_hdmi_mvs",	NULL),
+};
+
+#define PM8901_VREG_INIT(_id, _min_uV, _max_uV, _modes, _ops, _apply_uV, \
+			 _always_on, _active_high) \
+	[PM8901_VREG_ID_##_id] = { \
+		.init_data = { \
+			.constraints = { \
+				.valid_modes_mask = _modes, \
+				.valid_ops_mask = _ops, \
+				.min_uV = _min_uV, \
+				.max_uV = _max_uV, \
+				.input_uV = _min_uV, \
+				.apply_uV = _apply_uV, \
+				.always_on = _always_on, \
+			}, \
+			.consumer_supplies = vreg_consumers_8901_##_id, \
+			.num_consumer_supplies = \
+				ARRAY_SIZE(vreg_consumers_8901_##_id), \
+		}, \
+		.active_high = _active_high, \
+	}
+
+#define PM8901_VREG_INIT_MPP(_id, _active_high) \
+	PM8901_VREG_INIT(_id, 0, 0, REGULATOR_MODE_NORMAL, \
+			REGULATOR_CHANGE_STATUS, 0, 0, _active_high)
+
+#define PM8901_VREG_INIT_VS(_id) \
+	PM8901_VREG_INIT(_id, 0, 0, REGULATOR_MODE_NORMAL, \
+			REGULATOR_CHANGE_STATUS, 0, 0, 0)
+
+static struct pm8901_vreg_pdata pm8901_vreg_init_pdata[PM8901_VREG_MAX] = {
+	PM8901_VREG_INIT_MPP(MPP0, 1),
+
+	PM8901_VREG_INIT_VS(USB_OTG),
+	PM8901_VREG_INIT_VS(HDMI_MVS),
+};
+
+#define PM8901_VREG(_id) { \
+	.name = "pm8901-regulator", \
+	.id = _id, \
+	.platform_data = &pm8901_vreg_init_pdata[_id], \
+	.pdata_size = sizeof(pm8901_vreg_init_pdata[_id]), \
+}
+
+static struct mfd_cell pm8901_subdevs[] = {
+	{	.name = "pm8901-mpp",
+		.id		= -1,
+		.platform_data	= &pm8901_mpp_data,
+		.pdata_size      = sizeof(pm8901_mpp_data),
+	},
+	{	.name = "pm8901-tm",
+		.id		= -1,
+		.num_resources  = ARRAY_SIZE(pm8901_temp_alarm),
+		.resources      = pm8901_temp_alarm,
+	},
+	PM8901_VREG(PM8901_VREG_ID_MPP0),
+	PM8901_VREG(PM8901_VREG_ID_USB_OTG),
+	PM8901_VREG(PM8901_VREG_ID_HDMI_MVS),
+};
+
+#ifdef CONFIG_MSM_SSBI
+static struct pm8901_platform_data pm8901_platform_data = {
+        .irq_base = PM8901_IRQ_BASE,
+        .irq = MSM_GPIO_TO_INT(PM8901_GPIO_INT),
+        .num_subdevs = ARRAY_SIZE(pm8901_subdevs),
+        .sub_devices = pm8901_subdevs,
+        .irq_trigger_flags = IRQF_TRIGGER_LOW,
+};
+static struct msm_ssbi_platform_data msm8x60_ssbi_pm8901_pdata __devinitdata = {
+	.controller_type = MSM_SBI_CTRL_PMIC_ARBITER,
+	.slave	= {
+		.name			= "pm8901-core",
+		.platform_data		= &pm8901_platform_data,
+	},
+};
+#else
+static struct pm8901_platform_data pm8901_platform_data = {
+	.irq_base = PM8901_IRQ_BASE,
+	.num_subdevs = ARRAY_SIZE(pm8901_subdevs),
+	.sub_devices = pm8901_subdevs,
+	.irq_trigger_flags = IRQF_TRIGGER_LOW,
+};
+
+static struct i2c_board_info pm8901_boardinfo[] __initdata = {
+	{
+		I2C_BOARD_INFO("pm8901-core", 0x55),
+		.irq = MSM_GPIO_TO_INT(PM8901_GPIO_INT),
+		.platform_data = &pm8901_platform_data,
+	},
+};
+#endif
+
+#endif /* CONFIG_PMIC8901 */
+
+#if defined(CONFIG_MARIMBA_CORE) && (defined(CONFIG_GPIO_SX150X) \
+	|| defined(CONFIG_GPIO_SX150X_MODULE))
+
+struct bahama_config_register{
+	u8 reg;
+	u8 value;
+	u8 mask;
+};
+
+enum version{
+	VER_1_0,
+	VER_2_0,
+	VER_UNSUPPORTED = 0xFF
+};
+#endif /* CONFIG_MAIMBA_CORE */
+
+
+static int isl29028_power(int pwr_device, uint8_t enable)
+{
+	return 0;
+}
+
+static struct isl29028_platform_data isl29028_pdata = {
+	.intr = PM8058_GPIO_PM_TO_SYS(RIDER_PS_VOUT),
+	.levels = { 0xD, 0x3D, 0xC8, 0x1C8, 0x2C9, 0x3CA,
+			0x5F3, 0x81C, 0xA44, 0xFFF},
+	.golden_adc = 0x372,
+	.power = isl29028_power,
+	.lt = 0x15,
+	.ht = 0x16,
+};
+
+static struct i2c_board_info i2c_isl29028_devices[] = {
+	{
+		I2C_BOARD_INFO(ISL29028_I2C_NAME, 0x88 >> 1),
+		.platform_data = &isl29028_pdata,
+		.irq = PM8058_GPIO_IRQ(PM8058_IRQ_BASE, RIDER_PS_VOUT),
+	},
+};
+
+static int isl29029_power(int pwr_device, uint8_t enable)
+{
+	return 0;
+}
+
+static struct isl29029_platform_data isl29029_pdata = {
+	.intr = PM8058_GPIO_PM_TO_SYS(RIDER_PS_VOUT),
+	.levels = { 0xD, 0x3D, 0xC8, 0x1C8, 0x2C9, 0x3CA,
+			0x5F3, 0x81C, 0xA44, 0xFFF},
+	.golden_adc = 0x372,
+	.power = isl29029_power,
+	.lt = 0x15,
+	.ht = 0x16,
+};
+
+static struct i2c_board_info i2c_isl29029_devices[] = {
+	{
+		I2C_BOARD_INFO(ISL29029_I2C_NAME, 0x88 >> 1),
+		.platform_data = &isl29029_pdata,
+		.irq = PM8058_GPIO_IRQ(PM8058_IRQ_BASE, RIDER_PS_VOUT),
+	},
+};
+
+static struct mpu3050_platform_data mpu3050_data = {
+	.int_config = 0x10,
+	.orientation = { -1, 0, 0,
+					0, 1, 0,
+					0, 0, -1 },
+	.level_shifter = 0,
+
+	.accel = {
+		.get_slave_descr = get_accel_slave_descr,
+		.adapt_num = MSM_GSBI10_QUP_I2C_BUS_ID, /* The i2c bus to which the mpu device is connected */
+		.bus = EXT_SLAVE_BUS_SECONDARY,
+		.address = 0x30 >> 1,
+			.orientation = { -1, 0, 0,
+							0, 1, 0,
+							0, 0, -1 },
+
+	},
+
+	.compass = {
+		.get_slave_descr = get_compass_slave_descr,
+		.adapt_num = MSM_GSBI10_QUP_I2C_BUS_ID, /* The i2c bus to which the mpu device is connected */
+		.bus = EXT_SLAVE_BUS_PRIMARY,
+		.address = 0x1A >> 1,
+			.orientation = { 1, 0, 0,
+							0, 1, 0,
+							0, 0, 1 },
+	},
+};
+
+static struct i2c_board_info __initdata mpu3050_GSBI10_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("mpu3050", 0xD0 >> 1),
+		.irq = MSM_GPIO_TO_INT(RIDER_GYRO_INT),
+		.platform_data = &mpu3050_data,
+	},
+};
+
+#ifdef CONFIG_I2C
+#define I2C_SURF 1
+#define I2C_FFA  (1 << 1)
+#define I2C_RUMI (1 << 2)
+#define I2C_SIM  (1 << 3)
+#define I2C_FLUID (1 << 4)
+#define I2C_DRAGON (1 << 5)
+
+struct i2c_registry {
+	u8                     machs;
+	int                    bus;
+	struct i2c_board_info *info;
+	int                    len;
+};
+
+static struct i2c_registry msm8x60_i2c_devices[] __initdata = {
+#ifndef CONFIG_MSM_SSBI
+#ifdef CONFIG_PMIC8901
+	{
+		I2C_SURF | I2C_FFA,
+		MSM_SSBI2_I2C_BUS_ID,
+		pm8901_boardinfo,
+		ARRAY_SIZE(pm8901_boardinfo),
+	},
+#endif
+#endif /*CONFIG_MSM_SSBI */
+#if HASTIMPANI
+	{
+		I2C_SURF | I2C_FFA | I2C_FLUID,
+		MSM_GSBI7_QUP_I2C_BUS_ID,
+		msm_i2c_gsbi7_timpani_info,
+		ARRAY_SIZE(msm_i2c_gsbi7_timpani_info),
+	},
+#endif
+#ifdef CONFIG_TPS65200
+	{
+		I2C_SURF | I2C_FFA,
+		MSM_GSBI7_QUP_I2C_BUS_ID,
+		msm_tps_65200_boardinfo,
+		ARRAY_SIZE(msm_tps_65200_boardinfo),
+	},
+#endif
+#if defined(CONFIG_MSM8X60_AUDIO)
+	{
+		I2C_SURF | I2C_FFA | I2C_FLUID | I2C_DRAGON,
+		MSM_GSBI7_QUP_I2C_BUS_ID,
+		msm_i2c_gsbi7_tpa2051d3_info,
+		ARRAY_SIZE(msm_i2c_gsbi7_tpa2051d3_info),
+	},
+#endif
+#ifdef CONFIG_FB_MSM_HDMI_MHL
+#ifdef CONFIG_FB_MSM_HDMI_MHL_SII9234
+
+	{
+		I2C_SURF | I2C_FFA,
+		MSM_GSBI7_QUP_I2C_BUS_ID,
+		msm_i2c_gsbi7_mhl_sii9234_info,
+		ARRAY_SIZE(msm_i2c_gsbi7_mhl_sii9234_info),
+	},
+#endif
+#endif
+	{
+		I2C_SURF | I2C_FFA,
+		MSM_GSBI10_QUP_I2C_BUS_ID,
+		mpu3050_GSBI10_boardinfo,
+		ARRAY_SIZE(mpu3050_GSBI10_boardinfo),
+	},
+};
+
+#ifdef CONFIG_MSM_CAMERA
+static struct i2c_registry msm8x60_i2c_devices_cam_s5k3h2yx[] __initdata = {
+	{
+		I2C_SURF | I2C_FFA,
+		MSM_GSBI4_QUP_I2C_BUS_ID,
+		msm_camera_boardinfo,
+		ARRAY_SIZE(msm_camera_boardinfo),
+	},
+};
+
+static struct i2c_registry msm8x60_i2c_devices_cam_ov8830[] __initdata = {
+	{
+		I2C_SURF | I2C_FFA,
+		MSM_GSBI4_QUP_I2C_BUS_ID,
+		msm_camera_boardinfo_OV8830,
+		ARRAY_SIZE(msm_camera_boardinfo_OV8830),
+	},
+};
+#endif
+#endif /* CONFIG_I2C */
+
+static void fixup_i2c_configs(void)
+{
+#ifdef CONFIG_I2C
+	pm8901_vreg_init_pdata[PM8901_VREG_ID_MPP0].active_high = 1;
+#endif
+}
+
+static void register_i2c_devices(void)
+{
+#ifdef CONFIG_I2C
+	u8 mach_mask = 0;
+	int i;
+
+	/* Build the matching 'supported_machs' bitmask */
+	mach_mask = I2C_SURF;
+
+	/* Run the array and install devices as appropriate */
+	for (i = 0; i < ARRAY_SIZE(msm8x60_i2c_devices); ++i) {
+		if (msm8x60_i2c_devices[i].machs & mach_mask)
+			i2c_register_board_info(msm8x60_i2c_devices[i].bus,
+					msm8x60_i2c_devices[i].info,
+					msm8x60_i2c_devices[i].len);
+	}
+
+#ifdef CONFIG_MSM_CAMERA
+	if (gpio_get_value(RIDER_CAM_ID) == 0) {
+		i2c_register_board_info(msm8x60_i2c_devices_cam_s5k3h2yx[0].bus,
+				msm8x60_i2c_devices_cam_s5k3h2yx[0].info,
+				msm8x60_i2c_devices_cam_s5k3h2yx[0].len);
+	} else {
+		i2c_register_board_info(msm8x60_i2c_devices_cam_ov8830[0].bus,
+				msm8x60_i2c_devices_cam_ov8830[0].info,
+				msm8x60_i2c_devices_cam_ov8830[0].len);
+	}
+#endif
+
+	if (system_rev == 0)
+		i2c_register_board_info(MSM_GSBI10_QUP_I2C_BUS_ID,
+				i2c_isl29028_devices,
+				ARRAY_SIZE(i2c_isl29028_devices));
+	else
+		i2c_register_board_info(MSM_GSBI10_QUP_I2C_BUS_ID,
+				i2c_isl29029_devices,
+				ARRAY_SIZE(i2c_isl29029_devices));
+
+
+	if (system_rev >= 1) {
+		struct atmel_i2c_platform_data *pdata;
+
+		pdata = msm_i2c_gsbi5_info[0].platform_data;
+		pdata[0].gpio_irq = RIDER_TP_ATT_N_XB;
+		pdata[1].gpio_irq = RIDER_TP_ATT_N_XB;
+		msm_i2c_gsbi5_info[0].irq = MSM_GPIO_TO_INT(RIDER_TP_ATT_N_XB);
+	}
+	i2c_register_board_info(MSM_GSBI5_QUP_I2C_BUS_ID,
+			msm_i2c_gsbi5_info, ARRAY_SIZE(msm_i2c_gsbi5_info));
+#endif
+}
+
+static void __init msm8x60_init_uart12dm(void)
+{
+#if !defined(CONFIG_USB_PEHCI_HCD) && !defined(CONFIG_USB_PEHCI_HCD_MODULE)
+	/* 0x1D000000 now belongs to EBI2:CS3 i.e. USB ISP Controller */
+	void *fpga_mem = ioremap_nocache(0x1D000000, SZ_4K);
+
+	if (!fpga_mem)
+		pr_err("%s(): Error getting memory\n", __func__);
+
+	/* Advanced mode */
+	writew(0xFFFF, fpga_mem + 0x15C);
+	/* FPGA_UART_SEL */
+	writew(0, fpga_mem + 0x172);
+	/* FPGA_GPIO_CONFIG_117 */
+	writew(1, fpga_mem + 0xEA);
+	/* FPGA_GPIO_CONFIG_118 */
+	writew(1, fpga_mem + 0xEC);
+	mb();
+	iounmap(fpga_mem);
+#endif
+}
+
+static void __init msm8x60_init_buses(void)
+{
+#ifdef CONFIG_I2C_QUP
+	void *gsbi_mem = ioremap_nocache(0x19C00000, 4);
+	/* Setting protocol code to 0x60 for dual UART/I2C in GSBI12 */
+	writel_relaxed(0x6 << 4, gsbi_mem);
+	/* Ensure protocol code is written before proceeding further */
+	mb();
+	iounmap(gsbi_mem);
+
+	msm_gsbi4_qup_i2c_device.dev.platform_data = &msm_gsbi4_qup_i2c_pdata;
+	msm_gsbi5_qup_i2c_device.dev.platform_data = &msm_gsbi5_qup_i2c_pdata;
+	msm_gsbi7_qup_i2c_device.dev.platform_data = &msm_gsbi7_qup_i2c_pdata;
+	msm_gsbi10_qup_i2c_device.dev.platform_data = &msm_gsbi10_qup_i2c_pdata;
+#endif
+#if defined(CONFIG_SPI_QUP) || defined(CONFIG_SPI_QUP_MODULE)
+	msm_gsbi1_qup_spi_device.dev.platform_data = &msm_gsbi1_qup_spi_pdata;
+#endif
+#ifdef CONFIG_I2C_SSBI
+	msm_device_ssbi2.dev.platform_data = &msm_ssbi2_pdata;
+	msm_device_ssbi3.dev.platform_data = &msm_ssbi3_pdata;
+#endif
+#ifdef CONFIG_MSM_SSBI
+	msm_device_ssbi_pmic1.dev.platform_data =
+				&msm8x60_ssbi_pm8058_pdata;
+	msm_device_ssbi_pmic2.dev.platform_data =
+				&msm8x60_ssbi_pm8901_pdata;
+#endif
+
+#if defined(CONFIG_USB_GADGET_MSM_72K) || defined(CONFIG_USB_EHCI_HCD)
+	msm_otg_pdata.swfi_latency = msm_rpmrs_levels[0].latency_us;
+	/*
+	 * We can not put USB regulators (8058_l6 and 8058_l7) in LPM
+	 * when we depend on USB PHY for VBUS/ID notifications. VBUS
+	 * and ID notifications are available only on V2 surf and FFA
+	 * with a hardware workaround.
+	 */
+	msm_device_otg.dev.platform_data = &msm_otg_pdata;
+#endif
+
+#ifdef CONFIG_USB_GADGET_MSM_72K
+	msm_device_gadget_peripheral.dev.platform_data = &msm_gadget_pdata;
+#endif
+
+#ifdef CONFIG_BT
+	bt_export_bd_address();
+#endif
+
+#ifdef CONFIG_SERIAL_MSM_HS
+	msm_uart_dm1_pdata.rx_wakeup_irq = gpio_to_irq(RIDER_GPIO_BT_HOST_WAKE);
+	msm_device_uart_dm1.name = "msm_serial_hs_brcm";
+	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
+#endif
+
+#ifdef CONFIG_WIMAX_SERIAL_MSM_HS
+	msm_uart3_pdata.rx_wakeup_irq = gpio_to_irq(RIDER_GPIO_WIMAX_UART_SOUT);
+	msm_device_uart3.name = "msm_serial_hsl_wimax";
+	msm_device_uart3.dev.platform_data = &msm_uart3_pdata;
+#endif
+
+#ifdef CONFIG_MSM_BUS_SCALING
+
+	/* RPM calls are only enabled on V2 */
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 2) {
+		msm_bus_apps_fabric_pdata.rpm_enabled = 1;
+		msm_bus_sys_fabric_pdata.rpm_enabled = 1;
+		msm_bus_mm_fabric_pdata.rpm_enabled = 1;
+		msm_bus_sys_fpb_pdata.rpm_enabled = 1;
+		msm_bus_cpss_fpb_pdata.rpm_enabled = 1;
+	}
+
+	msm_bus_apps_fabric.dev.platform_data = &msm_bus_apps_fabric_pdata;
+	msm_bus_sys_fabric.dev.platform_data = &msm_bus_sys_fabric_pdata;
+	msm_bus_mm_fabric.dev.platform_data = &msm_bus_mm_fabric_pdata;
+	msm_bus_sys_fpb.dev.platform_data = &msm_bus_sys_fpb_pdata;
+	msm_bus_cpss_fpb.dev.platform_data = &msm_bus_cpss_fpb_pdata;
+#endif
+}
+
+static void __init rider_map_io(void)
+{
+	msm_shared_ram_phys = MSM_SHARED_RAM_PHYS;
+	msm_map_msm8x60_io();
+}
+
+static void __init msm8x60_init_tlmm(void)
+{
+}
+
+#if (defined(CONFIG_MMC_MSM_SDC1_SUPPORT)\
+	|| defined(CONFIG_MMC_MSM_SDC2_SUPPORT)\
+	|| defined(CONFIG_MMC_MSM_SDC3_SUPPORT)\
+	|| defined(CONFIG_MMC_MSM_SDC4_SUPPORT)\
+	|| defined(CONFIG_MMC_MSM_SDC5_SUPPORT))
+
+/* 8x60 is having 5 SDCC controllers */
+#define MAX_SDCC_CONTROLLER	5
+
+struct msm_sdcc_gpio {
+	/* maximum 10 GPIOs per SDCC controller */
+	s16 no;
+	/* name of this GPIO */
+	const char *name;
+	bool always_on;
+	bool is_enabled;
+};
+
+#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT
+static struct msm_sdcc_gpio sdc1_gpio_cfg[] = {
+	{159, "sdc1_dat_0"},
+	{160, "sdc1_dat_1"},
+	{161, "sdc1_dat_2"},
+	{162, "sdc1_dat_3"},
+#ifdef CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT
+	{163, "sdc1_dat_4"},
+	{164, "sdc1_dat_5"},
+	{165, "sdc1_dat_6"},
+	{166, "sdc1_dat_7"},
+#endif
+	{167, "sdc1_clk"},
+	{168, "sdc1_cmd"}
+};
+
+static uint32_t sdc1_on_gpio_table[] = {
+	GPIO_CFG(159, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT0 */
+	GPIO_CFG(160, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT1 */
+	GPIO_CFG(161, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT2 */
+	GPIO_CFG(162, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT3 */
+#ifdef CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT
+	GPIO_CFG(163, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT4 */
+	GPIO_CFG(164, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT5 */
+	GPIO_CFG(165, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT6 */
+	GPIO_CFG(166, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA), /* DAT7 */
+#endif
+	GPIO_CFG(167, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_10MA), /* CLK */
+	GPIO_CFG(168, 1, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_10MA), /* CMD */
+};
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT
+static struct msm_sdcc_gpio sdc2_gpio_cfg[] = {
+	{143, "sdc2_dat_0"},
+	{144, "sdc2_dat_1", 1},
+	{145, "sdc2_dat_2"},
+	{146, "sdc2_dat_3"},
+#ifdef CONFIG_MMC_MSM_SDC2_8_BIT_SUPPORT
+	{147, "sdc2_dat_4"},
+	{148, "sdc2_dat_5"},
+	{149, "sdc2_dat_6"},
+	{150, "sdc2_dat_7"},
+#endif
+	{151, "sdc2_cmd"},
+	{152, "sdc2_clk", 1}
+};
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+static struct msm_sdcc_gpio sdc5_gpio_cfg[] = {
+	{95, "sdc5_cmd"},
+	{96, "sdc5_dat_3"},
+	{97, "sdc5_clk", 1},
+	{98, "sdc5_dat_2"},
+	{99, "sdc5_dat_1", 1},
+	{100, "sdc5_dat_0"}
+};
+#endif
+
+struct msm_sdcc_pad_pull_cfg {
+	enum msm_tlmm_pull_tgt pull;
+	u32 pull_val;
+};
+
+struct msm_sdcc_pad_drv_cfg {
+	enum msm_tlmm_hdrive_tgt drv;
+	u32 drv_val;
+};
+
+#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT
+static struct msm_sdcc_pad_drv_cfg sdc3_pad_on_drv_cfg[] = {
+	{TLMM_HDRV_SDC3_CLK, GPIO_CFG_8MA},
+	{TLMM_HDRV_SDC3_CMD, GPIO_CFG_8MA},
+	{TLMM_HDRV_SDC3_DATA, GPIO_CFG_8MA}
+};
+
+static struct msm_sdcc_pad_pull_cfg sdc3_pad_on_pull_cfg[] = {
+	{TLMM_PULL_SDC3_CMD, GPIO_CFG_PULL_UP},
+	{TLMM_PULL_SDC3_DATA, GPIO_CFG_PULL_UP}
+};
+
+static struct msm_sdcc_pad_drv_cfg sdc3_pad_off_drv_cfg[] = {
+	{TLMM_HDRV_SDC3_CLK, GPIO_CFG_2MA},
+	{TLMM_HDRV_SDC3_CMD, GPIO_CFG_2MA},
+	{TLMM_HDRV_SDC3_DATA, GPIO_CFG_2MA}
+};
+
+static struct msm_sdcc_pad_pull_cfg sdc3_pad_off_pull_cfg[] = {
+	{TLMM_PULL_SDC3_CMD, GPIO_CFG_PULL_DOWN},
+	{TLMM_PULL_SDC3_DATA, GPIO_CFG_PULL_DOWN}
+};
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC4_SUPPORT
+static struct msm_sdcc_pad_drv_cfg sdc4_pad_on_drv_cfg[] = {
+	{TLMM_HDRV_SDC4_CLK, GPIO_CFG_8MA},
+	{TLMM_HDRV_SDC4_CMD, GPIO_CFG_8MA},
+	{TLMM_HDRV_SDC4_DATA, GPIO_CFG_8MA}
+};
+
+static struct msm_sdcc_pad_pull_cfg sdc4_pad_on_pull_cfg[] = {
+	{TLMM_PULL_SDC4_CMD, GPIO_CFG_PULL_UP},
+	{TLMM_PULL_SDC4_DATA, GPIO_CFG_PULL_UP}
+};
+
+static struct msm_sdcc_pad_drv_cfg sdc4_pad_off_drv_cfg[] = {
+	{TLMM_HDRV_SDC4_CLK, GPIO_CFG_2MA},
+	{TLMM_HDRV_SDC4_CMD, GPIO_CFG_2MA},
+	{TLMM_HDRV_SDC4_DATA, GPIO_CFG_2MA}
+};
+
+static struct msm_sdcc_pad_pull_cfg sdc4_pad_off_pull_cfg[] = {
+	{TLMM_PULL_SDC4_CMD, GPIO_CFG_PULL_DOWN},
+	{TLMM_PULL_SDC4_DATA, GPIO_CFG_PULL_DOWN}
+};
+#endif
+
+struct msm_sdcc_pin_cfg {
+	/*
+	 * = 1 if controller pins are using gpios
+	 * = 0 if controller has dedicated MSM pins
+	 */
+	u8 is_gpio;
+	u8 cfg_sts;
+	u8 gpio_data_size;
+	struct msm_sdcc_gpio *gpio_data;
+	struct msm_sdcc_pad_drv_cfg *pad_drv_on_data;
+	struct msm_sdcc_pad_drv_cfg *pad_drv_off_data;
+	struct msm_sdcc_pad_pull_cfg *pad_pull_on_data;
+	struct msm_sdcc_pad_pull_cfg *pad_pull_off_data;
+	u8 pad_drv_data_size;
+	u8 pad_pull_data_size;
+	u8 sdio_lpm_gpio_cfg;
+};
+
+
+static struct msm_sdcc_pin_cfg sdcc_pin_cfg_data[MAX_SDCC_CONTROLLER] = {
+#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT
+	[0] = {
+		.is_gpio = 1,
+		.gpio_data_size = ARRAY_SIZE(sdc1_gpio_cfg),
+		.gpio_data = sdc1_gpio_cfg,
+	},
+#endif
+#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT
+	[1] = {
+		.is_gpio = 1,
+		.gpio_data_size = ARRAY_SIZE(sdc2_gpio_cfg),
+		.gpio_data = sdc2_gpio_cfg
+	},
+#endif
+#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT
+	[2] = {
+		.is_gpio = 0,
+		.pad_drv_on_data = sdc3_pad_on_drv_cfg,
+		.pad_drv_off_data = sdc3_pad_off_drv_cfg,
+		.pad_pull_on_data = sdc3_pad_on_pull_cfg,
+		.pad_pull_off_data = sdc3_pad_off_pull_cfg,
+		.pad_drv_data_size = ARRAY_SIZE(sdc3_pad_on_drv_cfg),
+		.pad_pull_data_size = ARRAY_SIZE(sdc3_pad_on_pull_cfg)
+	},
+#endif
+#ifdef CONFIG_MMC_MSM_SDC4_SUPPORT
+	[3] = {
+		.is_gpio = 0,
+		.pad_drv_on_data = sdc4_pad_on_drv_cfg,
+		.pad_drv_off_data = sdc4_pad_off_drv_cfg,
+		.pad_pull_on_data = sdc4_pad_on_pull_cfg,
+		.pad_pull_off_data = sdc4_pad_off_pull_cfg,
+		.pad_drv_data_size = ARRAY_SIZE(sdc4_pad_on_drv_cfg),
+		.pad_pull_data_size = ARRAY_SIZE(sdc4_pad_on_pull_cfg)
+	},
+#endif
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+	[4] = {
+		.is_gpio = 1,
+		.gpio_data_size = ARRAY_SIZE(sdc5_gpio_cfg),
+		.gpio_data = sdc5_gpio_cfg
+	}
+#endif
+};
+
+static int msm_sdcc_setup_gpio(int dev_id, unsigned int enable)
+{
+	int rc = 0;
+	struct msm_sdcc_pin_cfg *curr;
+	int n;
+
+	curr = &sdcc_pin_cfg_data[dev_id - 1];
+	if (!curr->gpio_data)
+		goto out;
+
+	for (n = 0; n < curr->gpio_data_size; n++) {
+		if (enable) {
+
+			if (curr->gpio_data[n].always_on &&
+				curr->gpio_data[n].is_enabled)
+				continue;
+			pr_debug("%s: enable: %s\n", __func__,
+					curr->gpio_data[n].name);
+			rc = gpio_request(curr->gpio_data[n].no,
+				curr->gpio_data[n].name);
+			if (rc) {
+				pr_err("%s: gpio_request(%d, %s)"
+					"failed", __func__,
+					curr->gpio_data[n].no,
+					curr->gpio_data[n].name);
+				goto free_gpios;
+			}
+			/* set direction as output for all GPIOs */
+			rc = gpio_direction_output(
+				curr->gpio_data[n].no, 1);
+			if (rc) {
+				pr_err("%s: gpio_direction_output"
+					"(%d, 1) failed\n", __func__,
+					curr->gpio_data[n].no);
+				goto free_gpios;
+			}
+			curr->gpio_data[n].is_enabled = 1;
+		} else {
+			/*
+			 * now free this GPIO which will put GPIO
+			 * in low power mode and will also put GPIO
+			 * in input mode
+			 */
+			if (curr->gpio_data[n].always_on)
+				continue;
+			pr_debug("%s: disable: %s\n", __func__,
+					curr->gpio_data[n].name);
+			gpio_free(curr->gpio_data[n].no);
+			curr->gpio_data[n].is_enabled = 0;
+		}
+	}
+	curr->cfg_sts = enable;
+	goto out;
+
+free_gpios:
+	for (; n >= 0; n--)
+		gpio_free(curr->gpio_data[n].no);
+out:
+	return rc;
+}
+
+static int msm_sdcc_setup_pad(int dev_id, unsigned int enable)
+{
+	int rc = 0;
+	struct msm_sdcc_pin_cfg *curr;
+	int n;
+
+	curr = &sdcc_pin_cfg_data[dev_id - 1];
+	if (!curr->pad_drv_on_data || !curr->pad_pull_on_data)
+		goto out;
+
+	if (enable) {
+		/*
+		 * set up the normal driver strength and
+		 * pull config for pads
+		 */
+		for (n = 0; n < curr->pad_drv_data_size; n++) {
+			if (curr->sdio_lpm_gpio_cfg) {
+				if (curr->pad_drv_on_data[n].drv ==
+						TLMM_HDRV_SDC4_DATA)
+					continue;
+			}
+			msm_tlmm_set_hdrive(curr->pad_drv_on_data[n].drv,
+				curr->pad_drv_on_data[n].drv_val);
+		}
+		for (n = 0; n < curr->pad_pull_data_size; n++) {
+			if (curr->sdio_lpm_gpio_cfg) {
+				if (curr->pad_pull_on_data[n].pull ==
+						TLMM_PULL_SDC4_DATA)
+					continue;
+			}
+			msm_tlmm_set_pull(curr->pad_pull_on_data[n].pull,
+				curr->pad_pull_on_data[n].pull_val);
+		}
+	} else {
+		/* set the low power config for pads */
+		for (n = 0; n < curr->pad_drv_data_size; n++) {
+			if (curr->sdio_lpm_gpio_cfg) {
+				if (curr->pad_drv_off_data[n].drv ==
+						TLMM_HDRV_SDC4_DATA)
+					continue;
+			}
+			msm_tlmm_set_hdrive(
+				curr->pad_drv_off_data[n].drv,
+				curr->pad_drv_off_data[n].drv_val);
+		}
+		for (n = 0; n < curr->pad_pull_data_size; n++) {
+			if (curr->sdio_lpm_gpio_cfg) {
+				if (curr->pad_pull_off_data[n].pull ==
+						TLMM_PULL_SDC4_DATA)
+					continue;
+			}
+			msm_tlmm_set_pull(
+				curr->pad_pull_off_data[n].pull,
+				curr->pad_pull_off_data[n].pull_val);
+		}
+	}
+	curr->cfg_sts = enable;
+out:
+	return rc;
+}
+
+struct sdcc_reg {
+	/* VDD/VCC/VCCQ regulator name on PMIC8058/PMIC8089*/
+	const char *reg_name;
+	/*
+	 * is set voltage supported for this regulator?
+	 * 0 = not supported, 1 = supported
+	 */
+	unsigned char set_voltage_sup;
+	/* voltage level to be set */
+	unsigned int level;
+	/* VDD/VCC/VCCQ voltage regulator handle */
+	struct regulator *reg;
+	/* is this regulator enabled? */
+	bool enabled;
+	/* is this regulator needs to be always on? */
+	bool always_on;
+	/* is operating power mode setting required for this regulator? */
+	bool op_pwr_mode_sup;
+	/* Load values for low power and high power mode */
+	unsigned int lpm_uA;
+	unsigned int hpm_uA;
+};
+/* all SDCC controllers requires VDD/VCC voltage */
+static struct sdcc_reg sdcc_vdd_reg_data[MAX_SDCC_CONTROLLER];
+/* only SDCC1 requires VCCQ voltage */
+static struct sdcc_reg sdcc_vccq_reg_data[1];
+/* all SDCC controllers may require voting for VDD PAD voltage */
+static struct sdcc_reg sdcc_vddp_reg_data[MAX_SDCC_CONTROLLER];
+
+struct sdcc_reg_data {
+	struct sdcc_reg *vdd_data; /* keeps VDD/VCC regulator info */
+	struct sdcc_reg *vccq_data; /* keeps VCCQ regulator info */
+	struct sdcc_reg *vddp_data; /* keeps VDD Pad regulator info */
+	unsigned char sts; /* regulator enable/disable status */
+};
+/* msm8x60 have 5 SDCC controllers */
+static struct sdcc_reg_data sdcc_vreg_data[MAX_SDCC_CONTROLLER];
+
+static int msm_sdcc_vreg_init_reg(struct sdcc_reg *vreg)
+{
+	int rc = 0;
+
+	/* Get the regulator handle */
+	vreg->reg = regulator_get(NULL, vreg->reg_name);
+	if (IS_ERR(vreg->reg)) {
+		rc = PTR_ERR(vreg->reg);
+		pr_err("%s: regulator_get(%s) failed. rc=%d\n",
+			__func__, vreg->reg_name, rc);
+		goto out;
+	}
+
+	/* Set the voltage level if required */
+	if (vreg->set_voltage_sup) {
+		rc = regulator_set_voltage(vreg->reg, vreg->level,
+					vreg->level);
+		if (rc) {
+			pr_err("%s: regulator_set_voltage(%s) failed rc=%d\n",
+				__func__, vreg->reg_name, rc);
+			goto vreg_put;
+		}
+	}
+	goto out;
+
+vreg_put:
+	regulator_put(vreg->reg);
+out:
+	return rc;
+}
+
+static inline void msm_sdcc_vreg_deinit_reg(struct sdcc_reg *vreg)
+{
+	regulator_put(vreg->reg);
+}
+
+/* this init function should be called only once for each SDCC */
+static int msm_sdcc_vreg_init(int dev_id, unsigned char init)
+{
+	int rc = 0;
+	struct sdcc_reg *curr_vdd_reg, *curr_vccq_reg, *curr_vddp_reg;
+	struct sdcc_reg_data *curr;
+
+	curr = &sdcc_vreg_data[dev_id - 1];
+	curr_vdd_reg = curr->vdd_data;
+	curr_vccq_reg = curr->vccq_data;
+	curr_vddp_reg = curr->vddp_data;
+
+	if (init) {
+		/*
+		 * get the regulator handle from voltage regulator framework
+		 * and then try to set the voltage level for the regulator
+		 */
+		if (curr_vdd_reg) {
+			rc = msm_sdcc_vreg_init_reg(curr_vdd_reg);
+			if (rc)
+				goto out;
+		}
+		if (curr_vccq_reg) {
+			rc = msm_sdcc_vreg_init_reg(curr_vccq_reg);
+			if (rc)
+				goto vdd_reg_deinit;
+		}
+		if (curr_vddp_reg) {
+			rc = msm_sdcc_vreg_init_reg(curr_vddp_reg);
+			if (rc)
+				goto vccq_reg_deinit;
+		}
+		goto out;
+	} else
+		/* deregister with all regulators from regulator framework */
+		goto vddp_reg_deinit;
+
+vddp_reg_deinit:
+	if (curr_vddp_reg)
+		msm_sdcc_vreg_deinit_reg(curr_vddp_reg);
+vccq_reg_deinit:
+	if (curr_vccq_reg)
+		msm_sdcc_vreg_deinit_reg(curr_vccq_reg);
+vdd_reg_deinit:
+	if (curr_vdd_reg)
+		msm_sdcc_vreg_deinit_reg(curr_vdd_reg);
+out:
+	return rc;
+}
+
+static int msm_sdcc_vreg_enable(struct sdcc_reg *vreg)
+{
+	int rc;
+
+	if (!vreg->enabled) {
+		rc = regulator_enable(vreg->reg);
+		if (rc) {
+			pr_err("%s: regulator_enable(%s) failed. rc=%d\n",
+				__func__, vreg->reg_name, rc);
+			goto out;
+		}
+		vreg->enabled = 1;
+	}
+
+	/* Put always_on regulator in HPM (high power mode) */
+	if (vreg->always_on && vreg->op_pwr_mode_sup) {
+		rc = regulator_set_optimum_mode(vreg->reg, vreg->hpm_uA);
+		if (rc < 0) {
+			pr_err("%s: reg=%s: HPM setting failed"
+				" hpm_uA=%d, rc=%d\n",
+				__func__, vreg->reg_name,
+				vreg->hpm_uA, rc);
+			goto vreg_disable;
+		}
+		rc = 0;
+	}
+	goto out;
+
+vreg_disable:
+	regulator_disable(vreg->reg);
+	vreg->enabled = 0;
+out:
+	return rc;
+}
+
+static int msm_sdcc_vreg_disable(struct sdcc_reg *vreg)
+{
+	int rc;
+
+	/* Never disable always_on regulator */
+	if (!vreg->always_on) {
+		rc = regulator_disable(vreg->reg);
+		if (rc) {
+			pr_err("%s: regulator_disable(%s) failed. rc=%d\n",
+				__func__, vreg->reg_name, rc);
+			goto out;
+		}
+		vreg->enabled = 0;
+	}
+
+	/* Put always_on regulator in LPM (low power mode) */
+	if (vreg->always_on && vreg->op_pwr_mode_sup) {
+		rc = regulator_set_optimum_mode(vreg->reg, vreg->lpm_uA);
+		if (rc < 0) {
+			pr_err("%s: reg=%s: LPM setting failed"
+				" lpm_uA=%d, rc=%d\n",
+				__func__,
+				vreg->reg_name,
+				vreg->lpm_uA, rc);
+			goto out;
+		}
+		rc = 0;
+	}
+
+out:
+	return rc;
+}
+
+static int msm_sdcc_setup_vreg(int dev_id, unsigned char enable)
+{
+	int rc = 0;
+	struct sdcc_reg *curr_vdd_reg, *curr_vccq_reg, *curr_vddp_reg;
+	struct sdcc_reg_data *curr;
+
+	curr = &sdcc_vreg_data[dev_id - 1];
+	curr_vdd_reg = curr->vdd_data;
+	curr_vccq_reg = curr->vccq_data;
+	curr_vddp_reg = curr->vddp_data;
+
+	/* check if regulators are initialized or not? */
+	if ((curr_vdd_reg && !curr_vdd_reg->reg) ||
+		(curr_vccq_reg && !curr_vccq_reg->reg) ||
+		(curr_vddp_reg && !curr_vddp_reg->reg)) {
+		/* initialize voltage regulators required for this SDCC */
+		rc = msm_sdcc_vreg_init(dev_id, 1);
+		if (rc) {
+			pr_err("%s: regulator init failed = %d\n",
+				__func__, rc);
+			goto out;
+		}
+	}
+
+	if (curr->sts == enable)
+		goto out;
+	mdelay(5);
+	if (curr_vdd_reg) {
+		if (enable) {
+			if (dev_id == 3)
+				printk(KERN_INFO "%s: Enabling SD slot power\n", __func__);
+			rc = msm_sdcc_vreg_enable(curr_vdd_reg);
+		} else {
+			if (dev_id == 3)
+				printk(KERN_INFO "%s: Disabling SD slot power\n", __func__);
+			rc = msm_sdcc_vreg_disable(curr_vdd_reg);
+		}
+		if (rc)
+			goto out;
+	}
+
+	if (curr_vccq_reg) {
+		if (enable)
+			rc = msm_sdcc_vreg_enable(curr_vccq_reg);
+		else
+			rc = msm_sdcc_vreg_disable(curr_vccq_reg);
+		if (rc)
+			goto out;
+	}
+
+	if (curr_vddp_reg) {
+		if (enable)
+			rc = msm_sdcc_vreg_enable(curr_vddp_reg);
+		else
+			rc = msm_sdcc_vreg_disable(curr_vddp_reg);
+		if (rc)
+			goto out;
+	}
+	curr->sts = enable;
+
+out:
+	return rc;
+}
+
+static u32 msm_sdcc_setup_power(struct device *dv, unsigned int vdd)
+{
+	u32 rc_pin_cfg = 0;
+	u32 rc_vreg_cfg = 0;
+	u32 rc = 0;
+	struct platform_device *pdev;
+	struct msm_sdcc_pin_cfg *curr_pin_cfg;
+
+	pdev = container_of(dv, struct platform_device, dev);
+
+	/* setup gpio/pad */
+	curr_pin_cfg = &sdcc_pin_cfg_data[pdev->id - 1];
+	if (curr_pin_cfg->cfg_sts == !!vdd)
+		goto setup_vreg;
+
+	if (curr_pin_cfg->is_gpio)
+		rc_pin_cfg = msm_sdcc_setup_gpio(pdev->id, !!vdd);
+	else
+		rc_pin_cfg = msm_sdcc_setup_pad(pdev->id, !!vdd);
+
+setup_vreg:
+	/* setup voltage regulators */
+	rc_vreg_cfg = msm_sdcc_setup_vreg(pdev->id, !!vdd);
+
+	if (rc_pin_cfg || rc_vreg_cfg)
+		rc = rc_pin_cfg ? rc_pin_cfg : rc_vreg_cfg;
+
+	return rc;
+}
+
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+#ifdef CONFIG_MMC_MSM_SDC3_WP_SUPPORT
+static int msm_sdc3_get_wpswitch(struct device *dev)
+{
+	struct platform_device *pdev;
+	int status;
+	pdev = container_of(dev, struct platform_device, dev);
+
+	status = gpio_request(GPIO_SDC_WP, "SD_WP_Switch");
+	if (status) {
+		pr_err("%s:Failed to request GPIO %d\n",
+					__func__, GPIO_SDC_WP);
+	} else {
+		status = gpio_direction_input(GPIO_SDC_WP);
+		if (!status) {
+			status = gpio_get_value_cansleep(GPIO_SDC_WP);
+			pr_info("%s: WP Status for Slot %d = %d\n",
+				 __func__, pdev->id, status);
+		}
+		gpio_free(GPIO_SDC_WP);
+	}
+	return status;
+}
+#endif
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+int sdc5_register_status_notify(void (*callback)(int, void *),
+	void *dev_id)
+{
+	sdc5_status_notify_cb = callback;
+	sdc5_status_notify_cb_devid = dev_id;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT
+int sdc2_register_status_notify(void (*callback)(int, void *),
+	void *dev_id)
+{
+	sdc2_status_notify_cb = callback;
+	sdc2_status_notify_cb_devid = dev_id;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT
+#ifdef CONFIG_MMC_MSM_CARD_HW_DETECTION
+static unsigned int msm8x60_sdcc_slot_status(struct device *dev)
+{
+	int status;
+
+	status = gpio_request(PM8058_GPIO_PM_TO_SYS(RIDER_SDC3_DET)
+				, "SD_HW_Detect");
+	if (status) {
+		pr_err("%s:Failed to request GPIO %d\n", __func__,
+				PM8058_GPIO_PM_TO_SYS(RIDER_SDC3_DET));
+	} else {
+		status = gpio_direction_input(
+				PM8058_GPIO_PM_TO_SYS(RIDER_SDC3_DET));
+		if (!status)
+			status = !(gpio_get_value_cansleep(
+				PM8058_GPIO_PM_TO_SYS(RIDER_SDC3_DET)));
+		gpio_free(PM8058_GPIO_PM_TO_SYS(RIDER_SDC3_DET));
+	}
+	return (unsigned int) status;
+}
+#endif
+#endif
+
+#endif
+
+
+static uint32_t msm_rpm_get_swfi_latency(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(msm_rpmrs_levels); i++) {
+		if (msm_rpmrs_levels[i].sleep_mode ==
+			MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT)
+			return msm_rpmrs_levels[i].latency_us;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT
+static unsigned int rider_emmcslot_type = MMC_TYPE_MMC;
+static struct mmc_platform_data msm8x60_sdc1_data = {
+	.ocr_mask       = MMC_VDD_27_28 | MMC_VDD_28_29,
+#ifdef CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT
+	.mmc_bus_width  = MMC_CAP_8_BIT_DATA,
+#else
+	.mmc_bus_width  = MMC_CAP_4_BIT_DATA,
+#endif
+	.slot_type	= &rider_emmcslot_type,
+	.msmsdcc_fmin	= 400000,
+	.msmsdcc_fmid	= 24000000,
+	.msmsdcc_fmax	= 48000000,
+	.nonremovable	= 1,
+	.pclk_src_dfab	= 1,
+};
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT
+static unsigned int rider_sdslot_type = MMC_TYPE_SD;
+static struct mmc_platform_data msm8x60_sdc3_data = {
+	.ocr_mask       = MMC_VDD_27_28 | MMC_VDD_28_29,
+	.translate_vdd  = msm_sdcc_setup_power,
+	.mmc_bus_width  = MMC_CAP_4_BIT_DATA,
+#ifdef CONFIG_MMC_MSM_SDC3_WP_SUPPORT
+	.wpswitch  	= msm_sdc3_get_wpswitch,
+#endif
+#ifdef CONFIG_MMC_MSM_CARD_HW_DETECTION
+	.status      = msm8x60_sdcc_slot_status,
+	.status_irq  = PM8058_GPIO_IRQ(PM8058_IRQ_BASE,
+				       RIDER_SDC3_DET),
+	.irq_flags   = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+#endif
+	.slot_type	= &rider_sdslot_type,
+	.msmsdcc_fmin	= 400000,
+	.msmsdcc_fmid	= 24000000,
+	.msmsdcc_fmax	= 48000000,
+	.nonremovable	= 0,
+	.pclk_src_dfab  = 1,
+};
+#endif
+
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+static struct mmc_platform_data msm8x60_sdc5_data = {
+	.ocr_mask       = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_165_195,
+	.translate_vdd  = msm_sdcc_setup_power,
+	.sdio_lpm_gpio_setup = msm_sdcc_sdio_lpm_gpio,
+	.mmc_bus_width  = MMC_CAP_4_BIT_DATA,
+	.msmsdcc_fmin	= 400000,
+	.msmsdcc_fmid	= 24000000,
+	.msmsdcc_fmax	= 48000000,
+	.nonremovable	= 0,
+	.pclk_src_dfab  = 1,
+	.register_status_notify = sdc5_register_status_notify,
+};
+#endif
+
+static void __init msm8x60_init_mmc(void)
+{
+	int ret = 0;
+#ifdef CONFIG_MMC_MSM_SDC1_SUPPORT
+	config_gpio_table(sdc1_on_gpio_table, ARRAY_SIZE(sdc1_on_gpio_table));
+	/* SDCC1 : eMMC card connected */
+	sdcc_vreg_data[0].vdd_data = &sdcc_vdd_reg_data[0];
+	sdcc_vreg_data[0].vdd_data->reg_name = "8901_l5";
+	sdcc_vreg_data[0].vdd_data->set_voltage_sup = 1;
+	sdcc_vreg_data[0].vdd_data->level = 2850000;
+	sdcc_vreg_data[0].vdd_data->always_on = 1;
+	sdcc_vreg_data[0].vdd_data->op_pwr_mode_sup = 1;
+	sdcc_vreg_data[0].vdd_data->lpm_uA = 9000;
+	sdcc_vreg_data[0].vdd_data->hpm_uA = 200000;
+
+	sdcc_vreg_data[0].vccq_data = &sdcc_vccq_reg_data[0];
+	sdcc_vreg_data[0].vccq_data->reg_name = "8901_lvs0";
+	sdcc_vreg_data[0].vccq_data->set_voltage_sup = 0;
+	sdcc_vreg_data[0].vccq_data->always_on = 1;
+
+    msm8x60_sdc1_data.swfi_latency = msm_rpm_get_swfi_latency();
+	msm_add_sdcc(1, &msm8x60_sdc1_data);
+#endif
+#ifdef CONFIG_MMC_MSM_SDC2_SUPPORT
+	/*
+	 * MDM SDIO client is connected to SDC2 on charm SURF/FFA
+	 * and no card is connected on 8660 SURF/FFA/FLUID.
+	 */
+	/* SDCC2 : WiMAX SQN1210 is connected */
+	/*
+	sdcc_vreg_data[1].vdd_data = &sdcc_vdd_reg_data[1];
+	sdcc_vreg_data[1].vdd_data->reg_name = "8058_s3";
+	sdcc_vreg_data[1].vdd_data->set_voltage_sup = 1;
+	sdcc_vreg_data[1].vdd_data->level = 1800000;
+
+	sdcc_vreg_data[1].vccq_data = NULL;
+	*/
+#endif
+#ifdef CONFIG_MMC_MSM_SDC3_SUPPORT
+	/* SDCC3 : External card slot connected */
+	sdcc_vreg_data[2].vdd_data = &sdcc_vdd_reg_data[2];
+	sdcc_vreg_data[2].vdd_data->reg_name = "8058_l14";
+	sdcc_vreg_data[2].vdd_data->set_voltage_sup = 1;
+	sdcc_vreg_data[2].vdd_data->level = 2850000;
+	sdcc_vreg_data[2].vdd_data->always_on = 0;
+	sdcc_vreg_data[2].vdd_data->op_pwr_mode_sup = 0;
+	sdcc_vreg_data[2].vdd_data->lpm_uA = 9000;
+	sdcc_vreg_data[2].vdd_data->hpm_uA = 200000;
+
+	sdcc_vreg_data[2].vccq_data = NULL;
+
+	sdcc_vreg_data[2].vddp_data = &sdcc_vddp_reg_data[2];
+	sdcc_vreg_data[2].vddp_data->reg_name = "8058_l5";
+	sdcc_vreg_data[2].vddp_data->set_voltage_sup = 1;
+	sdcc_vreg_data[2].vddp_data->level = 2850000;
+	sdcc_vreg_data[2].vddp_data->always_on = 1;
+	sdcc_vreg_data[2].vddp_data->op_pwr_mode_sup = 1;
+	/* Sleep current required is ~300 uA. But min. RPM
+	 * vote can be in terms of mA (min. 1 mA).
+	 * So let's vote for 2 mA during sleep.
+	 */
+	sdcc_vreg_data[2].vddp_data->lpm_uA = 2000;
+	/* Max. Active current required is 16 mA */
+	sdcc_vreg_data[2].vddp_data->hpm_uA = 16000;
+
+    msm8x60_sdc3_data.swfi_latency = msm_rpm_get_swfi_latency();
+	msm_add_sdcc(3, &msm8x60_sdc3_data);
+#endif
+#ifdef CONFIG_MMC_MSM_SDC4_SUPPORT
+	/* SDCC4 : WLAN WCN1314 chip is connected */
+	ret = rider_init_mmc();
+	if (ret != 0)
+		printk(KERN_ERR "%s: Unable to initialize MMC (SDCC4)\n", __func__);
+#endif
+/* HTC_WIFI_END */
+#ifdef CONFIG_MMC_MSM_SDC5_SUPPORT
+	/* SDCC5 : NC (no card connected)*/
+	sdcc_vreg_data[4].vdd_data = &sdcc_vdd_reg_data[4];
+	sdcc_vreg_data[4].vdd_data->reg_name = "8058_s3";
+	sdcc_vreg_data[4].vdd_data->set_voltage_sup = 1;
+	sdcc_vreg_data[4].vdd_data->level = 1800000;
+
+	sdcc_vreg_data[4].vccq_data = NULL;
+#endif
+}
+
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
+static int hdmi_enable_5v(int on)
+{
+	static struct regulator *reg_8901_hdmi_mvs;	/* HDMI_5V */
+	static int prev_on;
+	int rc;
+
+	if (on == prev_on)
+		return 0;
+
+	if (!reg_8901_hdmi_mvs)
+		_GET_REGULATOR(reg_8901_hdmi_mvs, "8901_hdmi_mvs");
+
+	if (on) {
+		rc = regulator_enable(reg_8901_hdmi_mvs);
+		if (rc) {
+			pr_err("'%s' regulator enable failed, rc=%d\n",
+				"8901_hdmi_mvs", rc);
+			return rc;
+		}
+		pr_info("%s(on): success\n", __func__);
+	} else {
+		rc = regulator_disable(reg_8901_hdmi_mvs);
+		if (rc)
+			pr_warning("'%s' regulator disable failed, rc=%d\n",
+				"8901_hdmi_mvs", rc);
+		pr_info("%s(off): success\n", __func__);
+	}
+
+	prev_on = on;
+
+	return 0;
+}
+
+static int hdmi_core_power(int on, int show)
+{
+	static struct regulator *reg_8058_l16;		/* VDD_HDMI */
+	static int prev_on;
+	int rc;
+
+	if (on == prev_on)
+		return 0;
+
+	if (!reg_8058_l16)
+		_GET_REGULATOR(reg_8058_l16, "8058_l16");
+
+	if (on) {
+		rc = regulator_set_voltage(reg_8058_l16, 1800000, 1800000);
+		if (!rc)
+			rc = regulator_enable(reg_8058_l16);
+		if (rc) {
+			pr_err("'%s' regulator enable failed, rc=%d\n",
+				"8058_l16", rc);
+			return rc;
+		}
+
+		pr_info("%s(on): success\n", __func__);
+	} else {
+		rc = regulator_disable(reg_8058_l16);
+		if (rc)
+			pr_warning("'%s' regulator disable failed, rc=%d\n",
+				"8058_l16", rc);
+		pr_info("%s(off): success\n", __func__);
+	}
+
+	prev_on = on;
+
+	return 0;
+}
+
+static int hdmi_cec_power(int on)
+{
+	static struct regulator *reg_8901_l3;		/* HDMI_CEC */
+	static int prev_on;
+	int rc;
+
+	if (on == prev_on)
+		return 0;
+
+	if (!reg_8901_l3)
+		_GET_REGULATOR(reg_8901_l3, "8901_l3");
+
+	if (on) {
+		rc = regulator_set_voltage(reg_8901_l3, 3300000, 3300000);
+		if (!rc)
+			rc = regulator_enable(reg_8901_l3);
+		if (rc) {
+			pr_err("'%s' regulator enable failed, rc=%d\n",
+				"8901_l3", rc);
+			return rc;
+		}
+
+		pr_info("%s(on): success\n", __func__);
+	} else {
+		rc = regulator_disable(reg_8901_l3);
+		if (rc)
+			pr_warning("'%s' regulator disable failed, rc=%d\n",
+				"8901_l3", rc);
+		pr_info("%s(off): success\n", __func__);
+	}
+
+	prev_on = on;
+
+	return 0;
+}
+
+#endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
+
+#ifdef CONFIG_FB_MSM_TVOUT
+static struct regulator *reg_8058_l13;
+
+static int atv_dac_power(int on)
+{
+	int rc = 0;
+	#define _GET_REGULATOR(var, name) do {				\
+		var = regulator_get(NULL, name);			\
+		if (IS_ERR(var)) {					\
+			pr_info("'%s' regulator not found, rc=%ld\n",	\
+				name, IS_ERR(var));			\
+			var = NULL;					\
+			return -ENODEV;					\
+		}							\
+	} while (0)
+
+	if (!reg_8058_l13)
+		_GET_REGULATOR(reg_8058_l13, "8058_l13");
+	#undef _GET_REGULATOR
+
+	if (on) {
+		rc = regulator_set_voltage(reg_8058_l13, 2050000, 2050000);
+		if (rc) {
+			pr_info("%s: '%s' regulator set voltage failed,\
+				rc=%d\n", __func__, "8058_l13", rc);
+			return rc;
+		}
+
+		rc = regulator_enable(reg_8058_l13);
+		if (rc) {
+			pr_err("%s: '%s' regulator enable failed,\
+				rc=%d\n", __func__, "8058_l13", rc);
+			return rc;
+		}
+	} else {
+		rc = regulator_force_disable(reg_8058_l13);
+		if (rc)
+			pr_warning("%s: '%s' regulator disable failed, rc=%d\n",
+				__func__, "8058_l13", rc);
+	}
+	return rc;
+
+}
+#endif
+
+#ifdef CONFIG_FB_MSM_TVOUT
+
+#ifdef CONFIG_MSM_BUS_SCALING
+static struct msm_bus_vectors atv_bus_init_vectors[] = {
+	/* For now, 0th array entry is reserved.
+	 * Please leave 0 as is and don't use it
+	 */
+	{
+		.src = MSM_BUS_MASTER_MDP_PORT0,
+		.dst = MSM_BUS_SLAVE_SMI,
+		.ab = 0,
+		.ib = 0,
+	},
+	/* Master and slaves can be from different fabrics */
+	{
+		.src = MSM_BUS_MASTER_MDP_PORT0,
+		.dst = MSM_BUS_SLAVE_EBI_CH0,
+		.ab = 0,
+		.ib = 0,
+	},
+};
+static struct msm_bus_vectors atv_bus_def_vectors[] = {
+	/* For now, 0th array entry is reserved.
+	 * Please leave 0 as is and don't use it
+	 */
+	{
+		.src = MSM_BUS_MASTER_MDP_PORT0,
+		.dst = MSM_BUS_SLAVE_SMI,
+		.ab = 236390400,
+		.ib = 265939200,
+	},
+	/* Master and slaves can be from different fabrics */
+	{
+		.src = MSM_BUS_MASTER_MDP_PORT0,
+		.dst = MSM_BUS_SLAVE_EBI_CH0,
+		.ab = 236390400,
+		.ib = 265939200,
+	},
+};
+static struct msm_bus_paths atv_bus_scale_usecases[] = {
+	{
+		ARRAY_SIZE(atv_bus_init_vectors),
+		atv_bus_init_vectors,
+	},
+	{
+		ARRAY_SIZE(atv_bus_def_vectors),
+		atv_bus_def_vectors,
+	},
+};
+static struct msm_bus_scale_pdata atv_bus_scale_pdata = {
+	atv_bus_scale_usecases,
+	ARRAY_SIZE(atv_bus_scale_usecases),
+	.name = "atv",
+};
+#endif
+
+static struct tvenc_platform_data atv_pdata = {
+	.poll		 = 0,
+	.pm_vid_en	 = atv_dac_power,
+#ifdef CONFIG_MSM_BUS_SCALING
+	.bus_scale_table = &atv_bus_scale_pdata,
+#endif
+};
+#endif
+
+static void __init msm8x60_cfg_smsc911x(void)
+{
+	smsc911x_resources[1].start =
+		PM8058_GPIO_IRQ(PM8058_IRQ_BASE, 6);
+	smsc911x_resources[1].end =
+		PM8058_GPIO_IRQ(PM8058_IRQ_BASE, 6);
+}
+
+#ifdef CONFIG_MSM_RPM
+static struct msm_rpm_platform_data msm_rpm_data = {
+	.reg_base_addrs = {
+		[MSM_RPM_PAGE_STATUS] = MSM_RPM_BASE,
+		[MSM_RPM_PAGE_CTRL] = MSM_RPM_BASE + 0x400,
+		[MSM_RPM_PAGE_REQ] = MSM_RPM_BASE + 0x600,
+		[MSM_RPM_PAGE_ACK] = MSM_RPM_BASE + 0xa00,
+		[MSM_RPM_PAGE_STAT] = MSM_RPM_BASE + 0x3E04,
+	},
+
+	.irq_ack = RPM_SCSS_CPU0_GP_HIGH_IRQ,
+	.irq_err = RPM_SCSS_CPU0_GP_LOW_IRQ,
+	.irq_vmpm = RPM_SCSS_CPU0_GP_MEDIUM_IRQ,
+	.msm_apps_ipc_rpm_reg = MSM_GCC_BASE + 0x008,
+	.msm_apps_ipc_rpm_val = 4,
+};
+#endif
+
+void msm_fusion_setup_pinctrl(void)
+{
+	struct msm_xo_voter *a1;
+
+	if (socinfo_get_platform_subtype() == 0x3) {
+		/*
+		 * Vote for the A1 clock to be in pin control mode before
+		* the external images are loaded.
+		*/
+		a1 = msm_xo_get(MSM_XO_TCXO_A1, "mdm");
+		BUG_ON(!a1);
+		msm_xo_mode_vote(a1, MSM_XO_MODE_PIN_CTRL);
+	}
+}
+
+struct msm_board_data {
+	struct msm_gpiomux_configs *gpiomux_cfgs;
+};
+
+static struct msm_board_data rider_board_data __initdata = {
+	.gpiomux_cfgs = msm8x60_rider_gpiomux_cfgs,
+};
+
+void rider_add_usb_devices(void)
+{
+	printk(KERN_INFO "%s rev: %d\n", __func__, system_rev);
+	android_usb_pdata.products[0].product_id =
+			android_usb_pdata.product_id;
+
+	config_rider_mhl_gpios();
+
+	/* diag bit set */
+	if (get_radio_flag() & 0x20000)
+		android_usb_pdata.diag_init = 1;
+
+	msm_device_gadget_peripheral.dev.parent = &msm_device_otg.dev;
+	platform_device_register(&msm_device_gadget_peripheral);
+	platform_device_register(&usb_mass_storage_device);
+	platform_device_register(&android_usb_device);
+}
+
+static int __init board_serialno_setup(char *serialno)
+{
+	android_usb_pdata.serial_number = serialno;
+	return 1;
+}
+__setup("androidboot.serialno=", board_serialno_setup);
+
+static int __initdata rider_irq_ignore_tbl[] =
+{
+	MSM_GPIO_TO_INT(RIDER_GPIO_CAPTURE_MODE_KEY),
+};
+
+#define PM8058_LPM_SET(id)	(1 << RPM_VREG_ID_##id)
+#define PM8901_LPM_SET(id)	(1 << (RPM_VREG_ID_##id - RPM_VREG_ID_PM8901_L0))
+
+static uint32_t __initdata rider_regulator_lpm_set[] =
+{
+	PM8058_LPM_SET(PM8058_L0) | PM8058_LPM_SET(PM8058_L1) | PM8058_LPM_SET(PM8058_L2) |
+	PM8058_LPM_SET(PM8058_L5) | PM8058_LPM_SET(PM8058_L6) | PM8058_LPM_SET(PM8058_L7) |
+	PM8058_LPM_SET(PM8058_L8) | PM8058_LPM_SET(PM8058_L9) | PM8058_LPM_SET(PM8058_L10) |
+	PM8058_LPM_SET(PM8058_L11) | PM8058_LPM_SET(PM8058_L13) |
+	PM8058_LPM_SET(PM8058_L15) | PM8058_LPM_SET(PM8058_L16) | PM8058_LPM_SET(PM8058_L17) |
+	PM8058_LPM_SET(PM8058_L18) | PM8058_LPM_SET(PM8058_L19) | PM8058_LPM_SET(PM8058_L20) |
+	PM8058_LPM_SET(PM8058_L21) | PM8058_LPM_SET(PM8058_L22) | PM8058_LPM_SET(PM8058_L23) |
+	PM8058_LPM_SET(PM8058_L24) | PM8058_LPM_SET(PM8058_L25),
+	PM8901_LPM_SET(PM8901_L0) | PM8901_LPM_SET(PM8901_L1) | PM8901_LPM_SET(PM8901_L2) |
+	PM8901_LPM_SET(PM8901_L3) | PM8901_LPM_SET(PM8901_L5),
+};
+
+static void __init msm8x60_init(struct msm_board_data *board_data)
+{
+	int ret = 0;
+	struct kobject *properties_kobj;
+	uint32_t raw_speed_bin, speed_bin;
+
+	raw_speed_bin = readl(QFPROM_SPEED_BIN_ADDR);
+	speed_bin = raw_speed_bin & 0xF;
+
+	msm_tsens_early_init(&pyr_tsens_pdata);
+
+	/*
+	 * Initialize RPM first as other drivers and devices may need
+	 * it for their initialization.
+	 */
+#ifdef CONFIG_MSM_RPM
+	BUG_ON(msm_rpm_init(&msm_rpm_data));
+#endif
+	BUG_ON(msm_rpmrs_levels_init(msm_rpmrs_levels,
+				ARRAY_SIZE(msm_rpmrs_levels)));
+
+	/*
+	* Set low power mode of rpm resources:
+	*    PXO	= OFF
+	*    L2_cache	= OFF
+	*    Vdd_min	= 0.5v
+	*    Vdd_dig	= 0.5v
+	*/
+	msm_rpmrs_lpm_init(1, 1, 2, 2);
+	msm_rpm_lpm_init(rider_regulator_lpm_set, ARRAY_SIZE(rider_regulator_lpm_set));
+
+	if (msm_xo_init())
+		pr_err("Failed to initialize XO votes\n");
+
+	if (socinfo_init() < 0)
+		printk(KERN_ERR "%s: socinfo_init() failed!\n",
+		       __func__);
+	msm8x60_check_2d_hardware();
+
+	/* initialize SPM before acpuclock as the latter calls into SPM
+	 * driver to set ACPU voltages.
+	 */
+
+	if (SOCINFO_VERSION_MINOR(socinfo_get_version()) != 1) {
+		/* Change SPM handling of core 1 for PMM 8160. */
+		msm_spm_data[1].reg_init_values[MSM_SPM_REG_SAW_CFG] &= ~0x0F00UL;
+		msm_spm_data[1].reg_init_values[MSM_SPM_REG_SAW_CFG] |= 0x0100UL;
+		msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
+	 } else {
+		/* Change SPM handling of core 1 for PMM 8160. */
+		msm_spm_data_v1[1].reg_init_values[MSM_SPM_REG_SAW_CFG] &= ~0x0F00UL;
+		msm_spm_data_v1[1].reg_init_values[MSM_SPM_REG_SAW_CFG] |= 0x0100UL;
+		msm_spm_init(msm_spm_data_v1, ARRAY_SIZE(msm_spm_data_v1));
+	 }
+
+	/*
+	 * Disable regulator info printing so that regulator registration
+	 * messages do not enter the kmsg log.
+	 */
+	regulator_suppress_info_printing();
+
+	/* Initialize regulators needed for clock_init. */
+	platform_add_devices(early_regulators, ARRAY_SIZE(early_regulators));
+
+	/*added by htc for clock debugging*/
+	clk_ignor_list_add("msm_serial_hsl.0", "core_clk");
+	clk_ignor_list_add("msm_sdcc.4", "core_clk");
+	clk_ignor_list_add("msm_sdcc.4", "iface_clk");
+
+	msm_clock_init(&msm8x60_clock_init_data);
+
+	/* Buses need to be initialized before early-device registration
+	 * to get the platform data for fabrics.
+	 */
+	msm8x60_init_buses();
+	platform_add_devices(early_devices, ARRAY_SIZE(early_devices));
+	/* CPU frequency control is not supported on simulated targets. */
+	acpuclk_init(&acpuclk_8x60_soc_data);
+
+#ifdef CONFIG_PERFLOCK
+	perflock_init(&rider_perflock_data);
+#endif
+
+#ifdef CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE
+	set_two_phase_freq(1134000);
+#endif
+
+#ifdef CONFIG_CPU_FREQ_GOV_BADASS_2_PHASE
+	set_two_phase_freq_badass(CONFIG_CPU_FREQ_GOV_BADASS_2_PHASE_FREQ);
+#endif
+#ifdef CONFIG_CPU_FREQ_GOV_BADASS_3_PHASE
+	set_three_phase_freq_badass(CONFIG_CPU_FREQ_GOV_BADASS_3_PHASE_FREQ);
+#endif
+
+	msm8x60_init_tlmm();
+	msm8x60_init_gpiomux(board_data->gpiomux_cfgs);
+	msm8x60_init_uart12dm();
+	msm8x60_init_mmc();
+#ifdef CONFIG_MSM_DSPS
+	msm8x60_init_dsps();
+#endif
+#ifdef CONFIG_MSM_CAMERA
+	msm8x60_init_camera();
+#endif
+
+#if defined(CONFIG_PMIC8058_OTHC) || defined(CONFIG_PMIC8058_OTHC_MODULE)
+	msm8x60_init_pm8058_othc();
+#endif
+
+	/* Accessory */
+	printk(KERN_INFO "[HS_BOARD] (%s) system_rev = %d\n", __func__,
+	       system_rev);
+	if (system_rev >= 2) {
+		htc_headset_pmic_data.key_gpio =
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_REMO_PRES);
+		htc_headset_pmic_data.key_enable_gpio =
+			PM8058_GPIO_PM_TO_SYS(RIDER_AUD_REMO_EN);
+		htc_headset_8x60.dev.platform_data =
+			&htc_headset_8x60_data_xc;
+		htc_headset_mgr_data.headset_config_num =
+			ARRAY_SIZE(htc_headset_mgr_config);
+		htc_headset_mgr_data.headset_config = htc_headset_mgr_config;
+		htc_headset_mgr_data.headset_power = headset_power;
+		printk(KERN_INFO "[HS_BOARD] (%s) Set MEMS config\n", __func__);
+	}
+
+	msm8x60_cfg_smsc911x();
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) != 1)
+		platform_add_devices(msm_footswitch_devices,
+				     msm_num_footswitch_devices);
+	platform_add_devices(rider_devices,
+			     ARRAY_SIZE(rider_devices));
+
+	/* usb driver won't be loaded in MFG 58 station */
+	if (board_mfg_mode() != 6)
+		rider_add_usb_devices();
+
+#ifdef CONFIG_USB_EHCI_MSM_72K
+		msm_add_host(0, &msm_usb_host_pdata);
+#endif
+
+	platform_add_devices(asoc_devices,
+			ARRAY_SIZE(asoc_devices));
+
+#ifdef CONFIG_BATTERY_MSM8X60
+		platform_device_register(&msm_charger_device);
+#endif
+
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
+		platform_add_devices(hdmi_devices, 1);
+#endif
+
+#if defined(CONFIG_SPI_QUP) || defined(CONFIG_SPI_QUP_MODULE)
+	platform_device_register(&msm_gsbi1_qup_spi_device);
+#endif
+
+	rider_init_panel(msm_fb_resources, ARRAY_SIZE(msm_fb_resources));
+
+	fixup_i2c_configs();
+	register_i2c_devices();
+
+	platform_device_register(&smsc911x_device);
+
+	msm_pm_set_platform_data(msm_pm_data, ARRAY_SIZE(msm_pm_data));
+	msm_pm_set_rpm_wakeup_irq(RPM_SCSS_CPU0_WAKE_UP_IRQ);
+	msm_cpuidle_set_states(msm_cstates, ARRAY_SIZE(msm_cstates),
+				msm_pm_data);
+	BUG_ON(msm_pm_boot_init(MSM_PM_BOOT_CONFIG_TZ, NULL));
+
+	pm8058_gpios_init();
+
+#ifdef CONFIG_SENSORS_MSM_ADC
+	msm_adc_pdata.target_hw = MSM_8x60;
+#endif
+#ifdef CONFIG_MSM8X60_AUDIO
+	msm_auxpcm_init();
+	msm_snddev_init();
+
+	spi_register_board_info(msm_spi_board_info, ARRAY_SIZE(msm_spi_board_info));
+	gpio_tlmm_config(msm_spi_gpio[0], GPIO_CFG_ENABLE);
+	gpio_tlmm_config(msm_spi_gpio[1], GPIO_CFG_ENABLE);
+	gpio_tlmm_config(msm_spi_gpio[2], GPIO_CFG_ENABLE);
+	gpio_tlmm_config(msm_spi_gpio[3], GPIO_CFG_ENABLE);
+
+	rider_audio_init();
+#endif
+
+	sysinfo_proc_init();
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				&rider_properties_attr_group);
+
+	rider_init_keypad();
+	rider_wifi_init();
+	ret = headset_vddp_init_reg(&vddp_reg_headset);
+	if (ret < 0)
+		printk(KERN_ERR "[HS_BOARD]Init sddc vddp power failed\n");
+	ret = headset_vddp_enable_reg(&vddp_reg_headset);	/*Turn on Vddp 2.85V for remote control*/
+	if (ret < 0)
+		printk(KERN_ERR "[HS_BOARD]Enable sddc vddp power failed\n");
+	ret = headset_vddp_init_reg(&v_mic_bias_reg_headset);
+	if (ret < 0)
+		printk(KERN_ERR "[HS_BOARD]Init Headset MIC bias power failed\n");
+
+	headset_device_register();
+
+	msm_mpm_set_irq_ignore_list(rider_irq_ignore_tbl, ARRAY_SIZE(rider_irq_ignore_tbl));
+}
+
+static void __init rider_init(void)
+{
+	msm8x60_init(&rider_board_data);
+	printk(KERN_INFO "%s revision=%d engineerid=%d\n", __func__, system_rev, engineerid);
+}
+
+static void __init rider_charm_init_early(void)
+{
+	msm8x60_allocate_memory_regions();
+}
+
+static void __init rider_fixup(struct machine_desc *desc, struct tag *tags,
+		char **cmdline, struct meminfo *mi)
+{
+	mem_size_mb = parse_tag_memsize((const struct tag *)tags);
+	printk(KERN_DEBUG "%s: mem_size_mb=%u\n", __func__, mem_size_mb);
+
+	engineerid = parse_tag_engineerid(tags);
+	mi->nr_banks = 1;
+	mi->bank[0].start = PHY_BASE_ADDR1;
+	mi->bank[0].size = SIZE_ADDR1;
+	if (mem_size_mb == 1024)
+		mi->bank[0].size += 0x10000000;
+}
+
+MACHINE_START(RIDER, "rider")
+	.fixup = rider_fixup,
+	.map_io = rider_map_io,
+	.reserve = rider_reserve,
+	.init_irq = msm8x60_init_irq,
+	.init_machine = rider_init,
+	.timer = &msm_timer,
+	.init_early = rider_charm_init_early,
+MACHINE_END
diff --git a/arch/arm/mach-msm/board-rider.h b/arch/arm/mach-msm/board-rider.h
new file mode 100644
index 0000000..0c987e9
--- /dev/null
+++ b/arch/arm/mach-msm/board-rider.h
@@ -0,0 +1,234 @@
+/* linux/arch/arm/mach-msm/board-rider.h
+ *
+ * Copyright (C) 2010-2011 HTC Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ARCH_ARM_MACH_MSM_BOARD_RIDER_H
+#define __ARCH_ARM_MACH_MSM_BOARD_RIDER_H
+
+#include <mach/board.h>
+
+#define RIDER_PROJECT_NAME	"rider"
+
+#define MSM_RAM_CONSOLE_BASE	MSM_HTC_RAM_CONSOLE_PHYS
+#define MSM_RAM_CONSOLE_SIZE	MSM_HTC_RAM_CONSOLE_SIZE
+
+/* Memory map */
+
+#if defined(CONFIG_CRYPTO_DEV_QCRYPTO) || \
+		defined(CONFIG_CRYPTO_DEV_QCRYPTO_MODULE) || \
+		defined(CONFIG_CRYPTO_DEV_QCEDEV) || \
+		defined(CONFIG_CRYPTO_DEV_QCEDEV_MODULE)
+#define QCE_SIZE		0x10000
+#define QCE_0_BASE		0x18500000
+#endif
+
+#ifdef CONFIG_FB_MSM_LCDC_DSUB
+/* VGA = 1440 x 900 x 4(bpp) x 2(pages)
+   prim = 1024 x 600 x 4(bpp) x 2(pages)
+   This is the difference. */
+#define MSM_FB_DSUB_PMEM_ADDER (0x9E3400-0x4B0000)
+#else
+#define MSM_FB_DSUB_PMEM_ADDER (0)
+#endif
+
+#ifdef CONFIG_FB_MSM_TRIPLE_BUFFER
+/* prim = 960 x 540 x 4(bpp) x 3(pages) */
+#define MSM_FB_PRIM_BUF_SIZE (960 * ALIGN(540, 32) * 4 * 3)
+#else
+/* prim = 960 x 540 x 4(bpp) x 2(pages) */
+#define MSM_FB_PRIM_BUF_SIZE (960 * ALIGN(540, 32) * 4 * 2)
+#endif
+
+
+#ifdef CONFIG_FB_MSM_OVERLAY_WRITEBACK
+/* width x height x 3 bpp x 2 frame buffer */
+#define MSM_FB_WRITEBACK_SIZE roundup(960 * ALIGN(540, 32) * 3 * 2, 4096)
+#else
+#define MSM_FB_WRITEBACK_SIZE 0
+#endif
+
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
+/* prim = 1024 x 600 x 4(bpp) x 2(pages)
+ * hdmi = 1920 x 1080 x 2(bpp) x 1(page)
+ * Note: must be multiple of 4096 */
+#define MSM_FB_SIZE roundup(MSM_FB_PRIM_BUF_SIZE + 0x3F4800 + MSM_FB_DSUB_PMEM_ADDER, 4096)
+#elif defined(CONFIG_FB_MSM_TVOUT)
+/* prim = 1024 x 600 x 4(bpp) x 2(pages)
+ * tvout = 720 x 576 x 2(bpp) x 2(pages)
+ * Note: must be multiple of 4096 */
+#define MSM_FB_SIZE roundup(MSM_FB_PRIM_BUF_SIZE + 0x195000 + MSM_FB_DSUB_PMEM_ADDER, 4096)
+#else /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
+#define MSM_FB_SIZE roundup(MSM_FB_PRIM_BUF_SIZE + MSM_FB_DSUB_PMEM_ADDER, 4096)
+#endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
+#define MSM_PMEM_SF_SIZE 0x4000000 /* 64 Mbytes */
+#define MSM_OVERLAY_BLT_SIZE   roundup(960 * ALIGN(540, 32) * 3 * 2, 4096)
+
+#define MSM_PMEM_ADSP_SIZE	0x2F00000
+#define MSM_PMEM_AUDIO_SIZE	0x239000
+
+#define MSM_PMEM_SF_BASE		(0x70000000 - MSM_PMEM_SF_SIZE)
+#define MSM_PMEM_ADSP_BASE	(MSM_PMEM_SF_BASE - MSM_PMEM_ADSP_SIZE)
+#define MSM_OVERLAY_BLT_BASE	(0x40400000)
+#define MSM_FB_BASE		(MSM_OVERLAY_BLT_BASE + MSM_OVERLAY_BLT_SIZE)
+#define MSM_PMEM_AUDIO_BASE	(MSM_FB_BASE + MSM_FB_SIZE)
+
+
+#define MSM_SMI_BASE          0x38000000
+#define MSM_SMI_SIZE          0x4000000
+
+/* Kernel SMI PMEM Region for video core, used for Firmware */
+/* and encoder,decoder scratch buffers */
+/* Kernel SMI PMEM Region Should always precede the user space */
+/* SMI PMEM Region, as the video core will use offset address */
+/* from the Firmware base */
+#define KERNEL_SMI_BASE       (MSM_SMI_BASE)
+#define KERNEL_SMI_SIZE       0x400000
+
+/* User space SMI PMEM Region for video core*/
+/* used for encoder, decoder input & output buffers  */
+#define USER_SMI_BASE         (KERNEL_SMI_BASE + KERNEL_SMI_SIZE)
+#define USER_SMI_SIZE         (MSM_SMI_SIZE - KERNEL_SMI_SIZE)
+#define MSM_PMEM_SMIPOOL_BASE USER_SMI_BASE
+#define MSM_PMEM_SMIPOOL_SIZE USER_SMI_SIZE
+
+#define PHY_BASE_ADDR1  0x48000000
+#define SIZE_ADDR1      0x21100000
+
+/* GPIO definition */
+
+/* Direct Keys */
+#define RIDER_GPIO_KEY_CAM_STEP1   (123)
+#define RIDER_GPIO_KEY_VOL_DOWN    (103)
+#define RIDER_GPIO_KEY_VOL_UP      (104)
+#define RIDER_GPIO_KEY_CAM_STEP2   (115)
+#define RIDER_GPIO_KEY_POWER       (125)
+
+#define RIDER_GPIO_CAPTURE_MODE_KEY       (64)
+#define RIDER_GPIO_VIDEO_MODE_KEY       (68)
+
+/* Battery */
+#define RIDER_GPIO_MBAT_IN		   (61)
+#define RIDER_GPIO_CHG_INT		   (126)
+
+/* Wifi */
+#define RIDER_GPIO_WIFI_IRQ              (46)
+#define RIDER_GPIO_WIFI_SHUTDOWN_N       (96)
+
+/* WiMax */
+#define RIDER_GPIO_WIMAX_UART_SIN        (41)
+#define RIDER_GPIO_WIMAX_UART_SOUT       (42)
+#define RIDER_GPIO_V_WIMAX_1V2_RF_EN     (43)
+#define RIDER_GPIO_WIMAX_EXT_RST         (49)
+#define RIDER_GPIO_V_WIMAX_DVDD_EN       (94)
+#define RIDER_GPIO_V_WIMAX_PVDD_EN       (105)
+#define RIDER_GPIO_WIMAX_SDIO_D0         (143)
+#define RIDER_GPIO_WIMAX_SDIO_D1         (144)
+#define RIDER_GPIO_WIMAX_SDIO_D2         (145)
+#define RIDER_GPIO_WIMAX_SDIO_D3         (146)
+#define RIDER_GPIO_WIMAX_SDIO_CMD        (151)
+#define RIDER_GPIO_WIMAX_SDIO_CLK_CPU    (152)
+#define RIDER_GPIO_CPU_WIMAX_SW          (156)
+#define RIDER_GPIO_CPU_WIMAX_UART_EN     (157)
+
+/* Sensors */
+#define RIDER_SENSOR_I2C_SDA		(72)
+#define RIDER_SENSOR_I2C_SCL		(73)
+#define RIDER_GYRO_INT               (127)
+
+/* General */
+#define RIDER_GENERAL_I2C_SDA		(59)
+#define RIDER_GENERAL_I2C_SCL		(60)
+
+/* Microp */
+
+/* TP */
+#define RIDER_TP_I2C_SDA           (51)
+#define RIDER_TP_I2C_SCL           (52)
+#define RIDER_TP_ATT_N             (65)
+#define RIDER_TP_ATT_N_XB          (57)
+
+/* LCD */
+#define GPIO_LCM_ID	50
+#define GPIO_LCM_RST_N	66
+
+/* Audio */
+#define RIDER_AUD_CODEC_RST        (67)
+#define RIDER_AUD_CDC_LDO_SEL      (116)
+/* BT */
+#define RIDER_GPIO_BT_HOST_WAKE      (45)
+#define RIDER_GPIO_BT_UART1_TX       (53)
+#define RIDER_GPIO_BT_UART1_RX       (54)
+#define RIDER_GPIO_BT_UART1_CTS      (55)
+#define RIDER_GPIO_BT_UART1_RTS      (56)
+#define RIDER_GPIO_BT_SHUTDOWN_N     (100)
+#define RIDER_GPIO_BT_CHIP_WAKE      (130)
+#define RIDER_GPIO_BT_RESET_N        (142)
+
+/* USB */
+#define RIDER_GPIO_USB_ID        (63)
+#define RIDER_GPIO_MHL_RESET        (70)
+#define RIDER_GPIO_MHL_INT		(71)
+#define RIDER_GPIO_MHL_USB_EN         (139)
+#define RIDER_GPIO_MHL_USB_SW        (99)
+
+/* Camera */
+#define RIDER_CAM_I2C_SDA           (47)
+#define RIDER_CAM_I2C_SCL           (48)
+#define RIDER_CAM_ID           (135)
+
+
+/* Flashlight */
+#define RIDER_FLASH_EN             (29)
+#define RIDER_TORCH_EN             (30)
+
+/* Accessory */
+#define RIDER_GPIO_AUD_HP_DET        (31)
+
+/* SPI */
+#define RIDER_SPI_DO                 (33)
+#define RIDER_SPI_DI                 (34)
+#define RIDER_SPI_CS                 (35)
+#define RIDER_SPI_CLK                (36)
+
+/* PMIC */
+
+/* PMIC GPIO definition */
+#define PMGPIO(x) (x-1)
+#define RIDER_VOL_UP             (104)
+#define RIDER_VOL_DN             (103)
+#define RIDER_AUD_QTR_RESET      PMGPIO(21)
+#define RIDER_AUD_HANDSET_ENO    PMGPIO(18)
+#define RIDER_AUD_SPK_ENO        PMGPIO(19)
+#define RIDER_PS_VOUT            PMGPIO(22)
+#define RIDER_GREEN_LED          PMGPIO(24)
+#define RIDER_AMBER_LED          PMGPIO(25)
+#define RIDER_AUD_MIC_SEL        PMGPIO(14)
+#define RIDER_SDC3_DET           PMGPIO(34)
+#define RIDER_WIFI_BT_SLEEP_CLK  PMGPIO(38)
+#define RIDER_WIMAX_HOST_WAKEUP  PMGPIO(17)
+#define RIDER_TP_RST             PMGPIO(23)
+#define RIDER_TORCH_SET1         PMGPIO(40)
+#define RIDER_TORCH_SET2         PMGPIO(31)
+#define RIDER_CHG_STAT		 PMGPIO(33)
+#define RIDER_AUD_REMO_EN        PMGPIO(15)
+#define RIDER_AUD_REMO_PRES      PMGPIO(37)
+
+extern int panel_type;
+
+int __init rider_init_mmc(void);
+void __init rider_audio_init(void);
+int __init rider_init_keypad(void);
+int __init rider_wifi_init(void);
+int __init rider_init_panel(struct resource *res, size_t size);
+
+#endif /* __ARCH_ARM_MACH_MSM_BOARD_RIDER_H */
diff --git a/arch/arm/mach-msm/cp14.S b/arch/arm/mach-msm/cp14.S
new file mode 100644
index 0000000..94c74d3
--- /dev/null
+++ b/arch/arm/mach-msm/cp14.S
@@ -0,0 +1,669 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/threads.h>
+
+#if (NR_CPUS > 2)
+#error code only tested for 1 or 2 CPUs.
+#endif
+
+/* Add 1 slot to store the register count for ETM state */
+#define MAX_ETM_REGS (56 + 1)
+#define MAX_ETM_STATE_SIZE (MAX_ETM_REGS * 4)
+
+.global etm_read_reg
+etm_read_reg:
+    cmp     r0, #0x7F
+    bhi     read_high
+    ldr     r2, =read_table
+    add     r2, r2, r0, lsl #3
+    mov     pc, r2
+
+read_high:
+    cmp     r0, #0xC1
+    beq     read_c1
+    cmp     r0, #0xC4
+    beq     read_c4
+    cmp     r0, #0xC5
+    beq     read_c5
+    mov     r0, #0
+    bx      lr
+
+read_c1:
+    mrc     p14, 1, r0, c1,  c1, 4  // register 0xC1 (OS Lock Status Reg)
+    bx      lr
+
+read_c4:
+    mrc     p14, 1, r0, c1,  c4, 4  // register 0xC4 (Powerdown Ctl Reg)
+    bx      lr
+
+read_c5:
+    mrc     p14, 1, r0, c1,  c5, 4  // register 0xC5 (Powerdown Status Reg)
+    bx      lr
+
+read_table:
+    mrc     p14, 1, r0, c0,  c0, 0  // register 0x00
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 0  // register 0x01
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 0  // register 0x02
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 0  // register 0x03
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 0  // register 0x04
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 0  // register 0x05
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 0  // register 0x06
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 0  // register 0x07
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 0  // register 0x08
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 0  // register 0x09
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 0  // register 0x0A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 0  // register 0x0B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 0  // register 0x0C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 0  // register 0x0D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 0  // register 0x0E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 0  // register 0x0F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 1  // register 0x10
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 1  // register 0x11
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 1  // register 0x12
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 1  // register 0x13
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 1  // register 0x14
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 1  // register 0x15
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 1  // register 0x16
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 1  // register 0x17
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 1  // register 0x18
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 1  // register 0x19
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 1  // register 0x1A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 1  // register 0x1B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 1  // register 0x1C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 1  // register 0x1D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 1  // register 0x1E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 1  // register 0x1F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 2  // register 0x20
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 2  // register 0x21
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 2  // register 0x22
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 2  // register 0x23
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 2  // register 0x24
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 2  // register 0x25
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 2  // register 0x26
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 2  // register 0x27
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 2  // register 0x28
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 2  // register 0x29
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 2  // register 0x2A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 2  // register 0x2B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 2  // register 0x2C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 2  // register 0x2D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 2  // register 0x2E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 2  // register 0x2F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 3  // register 0x30
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 3  // register 0x31
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 3  // register 0x32
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 3  // register 0x33
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 3  // register 0x34
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 3  // register 0x35
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 3  // register 0x36
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 3  // register 0x37
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 3  // register 0x38
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 3  // register 0x39
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 3  // register 0x3A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 3  // register 0x3B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 3  // register 0x3C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 3  // register 0x3D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 3  // register 0x3E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 3  // register 0x3F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 4  // register 0x40
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 4  // register 0x41
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 4  // register 0x42
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 4  // register 0x43
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 4  // register 0x44
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 4  // register 0x45
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 4  // register 0x46
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 4  // register 0x47
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 4  // register 0x48
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 4  // register 0x49
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 4  // register 0x4A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 4  // register 0x4B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 4  // register 0x4C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 4  // register 0x4D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 4  // register 0x4E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 4  // register 0x4F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 5  // register 0x50
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 5  // register 0x51
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 5  // register 0x52
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 5  // register 0x53
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 5  // register 0x54
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 5  // register 0x55
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 5  // register 0x56
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 5  // register 0x57
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 5  // register 0x58
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 5  // register 0x59
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 5  // register 0x5A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 5  // register 0x5B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 5  // register 0x5C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 5  // register 0x5D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 5  // register 0x5E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 5  // register 0x5F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 6  // register 0x60
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 6  // register 0x61
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 6  // register 0x62
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 6  // register 0x63
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 6  // register 0x64
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 6  // register 0x65
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 6  // register 0x66
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 6  // register 0x67
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 6  // register 0x68
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 6  // register 0x69
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 6  // register 0x6A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 6  // register 0x6B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 6  // register 0x6C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 6  // register 0x6D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 6  // register 0x6E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 6  // register 0x6F
+    bx      lr
+    mrc     p14, 1, r0, c0,  c0, 7  // register 0x70
+    bx      lr
+    mrc     p14, 1, r0, c0,  c1, 7  // register 0x71
+    bx      lr
+    mrc     p14, 1, r0, c0,  c2, 7  // register 0x72
+    bx      lr
+    mrc     p14, 1, r0, c0,  c3, 7  // register 0x73
+    bx      lr
+    mrc     p14, 1, r0, c0,  c4, 7  // register 0x74
+    bx      lr
+    mrc     p14, 1, r0, c0,  c5, 7  // register 0x75
+    bx      lr
+    mrc     p14, 1, r0, c0,  c6, 7  // register 0x76
+    bx      lr
+    mrc     p14, 1, r0, c0,  c7, 7  // register 0x77
+    bx      lr
+    mrc     p14, 1, r0, c0,  c8, 7  // register 0x78
+    bx      lr
+    mrc     p14, 1, r0, c0,  c9, 7  // register 0x79
+    bx      lr
+    mrc     p14, 1, r0, c0, c10, 7  // register 0x7A
+    bx      lr
+    mrc     p14, 1, r0, c0, c11, 7  // register 0x7B
+    bx      lr
+    mrc     p14, 1, r0, c0, c12, 7  // register 0x7C
+    bx      lr
+    mrc     p14, 1, r0, c0, c13, 7  // register 0x7D
+    bx      lr
+    mrc     p14, 1, r0, c0, c14, 7  // register 0x7E
+    bx      lr
+    mrc     p14, 1, r0, c0, c15, 7  // register 0x7F
+    bx      lr
+
+.global etm_write_reg
+etm_write_reg:
+    cmp     r0, #0x7F
+    bhi     write_high
+    ldr     r2, =write_table
+    add     r2, r2, r0, lsl #3
+    mov     pc, r2
+
+write_high:
+    cmp     r0, #0xC0
+    beq     write_c0
+    cmp     r0, #0xC4
+    beq     write_c4
+    bx      lr
+
+write_c0:
+    mcr     p14, 1, r1, c1,  c0, 4  // register 0xC0 (OS Lock Access Reg)
+    bx      lr
+
+write_c4:
+    mcr     p14, 1, r1, c1,  c4, 4  // register 0xC4 (Powerdown Ctl Reg)
+    bx      lr
+
+write_table:
+    mcr     p14, 1, r1, c0,  c0, 0  // register 0x00
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 0  // register 0x01
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 0  // register 0x02
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 0  // register 0x03
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 0  // register 0x04
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 0  // register 0x05
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 0  // register 0x06
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 0  // register 0x07
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 0  // register 0x08
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 0  // register 0x09
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 0  // register 0x0A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 0  // register 0x0B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 0  // register 0x0C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 0  // register 0x0D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 0  // register 0x0E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 0  // register 0x0F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 1  // register 0x10
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 1  // register 0x11
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 1  // register 0x12
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 1  // register 0x13
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 1  // register 0x14
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 1  // register 0x15
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 1  // register 0x16
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 1  // register 0x17
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 1  // register 0x18
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 1  // register 0x19
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 1  // register 0x1A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 1  // register 0x1B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 1  // register 0x1C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 1  // register 0x1D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 1  // register 0x1E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 1  // register 0x1F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 2  // register 0x20
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 2  // register 0x21
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 2  // register 0x22
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 2  // register 0x23
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 2  // register 0x24
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 2  // register 0x25
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 2  // register 0x26
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 2  // register 0x27
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 2  // register 0x28
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 2  // register 0x29
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 2  // register 0x2A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 2  // register 0x2B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 2  // register 0x2C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 2  // register 0x2D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 2  // register 0x2E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 2  // register 0x2F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 3  // register 0x30
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 3  // register 0x31
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 3  // register 0x32
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 3  // register 0x33
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 3  // register 0x34
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 3  // register 0x35
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 3  // register 0x36
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 3  // register 0x37
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 3  // register 0x38
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 3  // register 0x39
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 3  // register 0x3A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 3  // register 0x3B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 3  // register 0x3C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 3  // register 0x3D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 3  // register 0x3E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 3  // register 0x3F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 4  // register 0x40
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 4  // register 0x41
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 4  // register 0x42
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 4  // register 0x43
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 4  // register 0x44
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 4  // register 0x45
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 4  // register 0x46
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 4  // register 0x47
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 4  // register 0x48
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 4  // register 0x49
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 4  // register 0x4A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 4  // register 0x4B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 4  // register 0x4C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 4  // register 0x4D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 4  // register 0x4E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 4  // register 0x4F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 5  // register 0x50
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 5  // register 0x51
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 5  // register 0x52
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 5  // register 0x53
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 5  // register 0x54
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 5  // register 0x55
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 5  // register 0x56
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 5  // register 0x57
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 5  // register 0x58
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 5  // register 0x59
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 5  // register 0x5A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 5  // register 0x5B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 5  // register 0x5C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 5  // register 0x5D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 5  // register 0x5E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 5  // register 0x5F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 6  // register 0x60
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 6  // register 0x61
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 6  // register 0x62
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 6  // register 0x63
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 6  // register 0x64
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 6  // register 0x65
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 6  // register 0x66
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 6  // register 0x67
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 6  // register 0x68
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 6  // register 0x69
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 6  // register 0x6A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 6  // register 0x6B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 6  // register 0x6C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 6  // register 0x6D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 6  // register 0x6E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 6  // register 0x6F
+    bx      lr
+    mcr     p14, 1, r1, c0,  c0, 7  // register 0x70
+    bx      lr
+    mcr     p14, 1, r1, c0,  c1, 7  // register 0x71
+    bx      lr
+    mcr     p14, 1, r1, c0,  c2, 7  // register 0x72
+    bx      lr
+    mcr     p14, 1, r1, c0,  c3, 7  // register 0x73
+    bx      lr
+    mcr     p14, 1, r1, c0,  c4, 7  // register 0x74
+    bx      lr
+    mcr     p14, 1, r1, c0,  c5, 7  // register 0x75
+    bx      lr
+    mcr     p14, 1, r1, c0,  c6, 7  // register 0x76
+    bx      lr
+    mcr     p14, 1, r1, c0,  c7, 7  // register 0x77
+    bx      lr
+    mcr     p14, 1, r1, c0,  c8, 7  // register 0x78
+    bx      lr
+    mcr     p14, 1, r1, c0,  c9, 7  // register 0x79
+    bx      lr
+    mcr     p14, 1, r1, c0, c10, 7  // register 0x7A
+    bx      lr
+    mcr     p14, 1, r1, c0, c11, 7  // register 0x7B
+    bx      lr
+    mcr     p14, 1, r1, c0, c12, 7  // register 0x7C
+    bx      lr
+    mcr     p14, 1, r1, c0, c13, 7  // register 0x7D
+    bx      lr
+    mcr     p14, 1, r1, c0, c14, 7  // register 0x7E
+    bx      lr
+    mcr     p14, 1, r1, c0, c15, 7  // register 0x7F
+    bx      lr
+
+.global l2tevselr0_write
+l2tevselr0_write:
+    mcr     p15, 3, r0, c15, c5, 2
+    bx      lr
+
+.global etm_save_reg
+etm_save_reg:
+	ldr     r3, =etm_state        /* store state at etm_state */
+#if (NR_CPUS >= 2)
+	mrc	p15, 0, r2, c0, c0, 5 /* MPIDR */
+	and	r2, r2, #15	      /* What CPU am I */
+	ldr     r1, =MAX_ETM_STATE_SIZE
+	mul     r2, r2, r1
+	add	r3, r3, r2
+#endif
+
+	/* save etm state */
+	mrc	p14, 1, r0, c1, c5, 4 /* read ETM PDSR to clear sticky bit */
+	isb
+	ldr     r1, =0xc5ACCE55       /* set ETMOSLAR lock */
+	mcr     p14, 1, r1, c1, c0, 4
+	isb
+
+	mrc     p14, 1, r1, c1, c2, 4 /* ETMOSSRR state register count */
+	cmp     r1, #(MAX_ETM_REGS)   /* check for state overflow */
+	movgt   r1, #0                /* if not enough space, don't save */
+	str     r1,[r3],#4            /* save count for restore */
+
+1:	cmp     r1, #0
+	mrcne   p14, 1, r2, c1, c2, 4 /* ETMOSSRR state value */
+	strne   r2, [r3], #4          /* push value */
+	subne   r1, r1, #1
+	bne     1b
+
+	mcr     p14, 1, r1, c1, c0, 4 /* r1 = 0, unlock ETMOSLAR */
+	isb
+
+	bx      lr
+
+.global etm_restore_reg
+etm_restore_reg:
+	/* restore debug registers after power collapse  */
+	ldr     r3, =etm_state        /* load state from etm_state */
+#if (NR_CPUS >= 2)
+	mrc	p15, 0, r2, c0, c0, 5 /* MPIDR */
+	and	r2, r2, #15	      /* What CPU am I */
+	ldr     r1, =MAX_ETM_STATE_SIZE
+	mul     r2, r2, r1
+	add	r3, r3, r2
+#endif
+
+	/* restore etm state */
+	mrc	p14, 1, r0, c1, c5, 4 /* read ETM PDSR to clear sticky bit */
+	isb
+	ldr     r1, =0xc5ACCE55       /* set ETMOSLAR lock */
+	mcr     p14, 1, r1, c1, c0, 4
+	isb
+
+	mrc     p14, 1, r1, c1, c2, 4 /* ETMOSSRR dummy read (required)*/
+	ldr     r1, [r3], #4          /* load saved count */
+	cmp     r1, #0                /* skip if none stored */
+	beq     end_etm_restore_reg
+
+1:	ldr     r2,[r3],#4
+	mcr     p14, 1, r2, c1, c2, 4 /* ETMOSSRR write state value */
+	subs    r1, r1, #1
+	bne     1b
+end_etm_restore_reg:
+	mcr     p14, 1, r1, c1, c0, 4 /* r1 = 0, unlock ETMOSLAR */
+	isb
+
+	bx      lr
+
+
+	.data
+
+etm_state:
+	.space	MAX_ETM_STATE_SIZE * NR_CPUS
diff --git a/arch/arm/mach-msm/cp14.h b/arch/arm/mach-msm/cp14.h
new file mode 100644
index 0000000..0946e07
--- /dev/null
+++ b/arch/arm/mach-msm/cp14.h
@@ -0,0 +1,19 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/types.h>
+
+uint32_t etm_read_reg(uint32_t reg);
+void   etm_write_reg(uint32_t reg, uint32_t val);
+void   l2tevselr0_write(uint32_t val);
+void etm_save_reg(void);
+void etm_restore_reg(void);
diff --git a/arch/arm/mach-msm/etm.c b/arch/arm/mach-msm/etm.c
new file mode 100644
index 0000000..81c0478
--- /dev/null
+++ b/arch/arm/mach-msm/etm.c
@@ -0,0 +1,978 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/cpu.h>
+#include <linux/smp.h>
+#include <linux/percpu.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/wakelock.h>
+#include <linux/pm_qos_params.h>
+
+#include <asm/atomic.h>
+
+#include "cp14.h"
+
+#define LOG_BUF_LEN			32768
+#define ETM_NUM_REGS			128
+#define ETB_NUM_REGS			9
+/* each slot is 4 bytes, 8kb total */
+#define ETB_RAM_SLOTS			2048
+
+#define DATALOG_SYNC			0xB5C7
+#define ETM_DUMP_MSG_ID			0x000A6960
+#define ETB_DUMP_MSG_ID			0x000A6961
+
+/* ETM Registers */
+#define ETM_REG_CONTROL			0x00
+#define ETM_REG_STATUS			0x04
+#define ETB_REG_CONTROL			0x71
+#define ETB_REG_STATUS			0x72
+#define ETB_REG_COUNT			0x73
+#define ETB_REG_ADDRESS			0x74
+#define ETB_REG_DATA			0x75
+
+/* Bitmasks for the ETM control register */
+#define ETM_CONTROL_POWERDOWN		0x00000001
+#define ETM_CONTROL_PROGRAM		0x00000400
+
+/* Bitmasks for the ETM status register */
+#define ETM_STATUS_PROGRAMMING		0x00000002
+
+/* ETB Status Register bit definitions */
+#define OV				0x00200000
+
+/* ETB Control Register bit definitions */
+#define AIR				0x00000008
+#define AIW				0x00000004
+#define CPTM				0x00000002
+#define CPTEN				0x00000001
+
+/* Bitmasks for the swconfig field of ETM_CONFIG
+ * ETM trigger propagated to ETM instances on all cores
+ */
+#define TRIGGER_ALL			0x00000002
+
+#define PROG_TIMEOUT_MS			500
+
+static int trace_enabled;
+static int cpu_to_dump;
+static int next_cpu_to_dump;
+static struct wake_lock etm_wake_lock;
+static struct pm_qos_request_list etm_qos_req;
+static int trace_on_boot;
+module_param_named(
+	trace_on_boot, trace_on_boot, int, S_IRUGO
+);
+
+struct b {
+	uint8_t etm_log_buf[LOG_BUF_LEN];
+	uint32_t log_end;
+};
+
+static struct b buf[NR_CPUS];
+static struct b __percpu * *alloc_b;
+static atomic_t etm_dev_in_use;
+
+/* These default settings will be used to configure the ETM/ETB
+ * when the driver loads. */
+struct etm_config_struct {
+	uint32_t etm_00_control;
+	uint32_t etm_02_trigger_event;
+	uint32_t etm_06_te_start_stop;
+	uint32_t etm_07_te_single_addr_comp;
+	uint32_t etm_08_te_event;
+	uint32_t etm_09_te_control;
+	uint32_t etm_0a_fifofull_region;
+	uint32_t etm_0b_fifofull_level;
+	uint32_t etm_0c_vd_event;
+	uint32_t etm_0d_vd_single_addr_comp;
+	uint32_t etm_0e_vd_mmd;
+	uint32_t etm_0f_vd_control;
+	uint32_t etm_addr_comp_value[8]; /* 10 to 17 */
+	uint32_t etm_addr_access_type[8]; /* 20 to 27 */
+	uint32_t etm_data_comp_value[2]; /* 30 and 32 */
+	uint32_t etm_data_comp_mask[2]; /* 40 and 42 */
+	uint32_t etm_counter_reload_value[2]; /* 50 to 51 */
+	uint32_t etm_counter_enable[2]; /* 54 to 55 */
+	uint32_t etm_counter_reload_event[2]; /* 58 to 59 */
+	uint32_t etm_60_seq_event_1_to_2;
+	uint32_t etm_61_seq_event_2_to_1;
+	uint32_t etm_62_seq_event_2_to_3;
+	uint32_t etm_63_seq_event_3_to_1;
+	uint32_t etm_64_seq_event_3_to_2;
+	uint32_t etm_65_seq_event_1_to_3;
+	uint32_t etm_6c_cid_comp_value_1;
+	uint32_t etm_6f_cid_comp_mask;
+	uint32_t etm_78_sync_freq;
+	uint32_t swconfig;
+	uint32_t etb_trig_cnt;
+	uint32_t etb_init_ptr;
+};
+
+static struct etm_config_struct etm_config = {
+	/* etm_00_control 0x0000D84E: 32-bit CID, cycle-accurate,
+	 * monitorCPRT */
+	.etm_00_control			= 0x0000D84E,
+	/* etm_02_trigger_event 0x00000000: address comparator 0 matches */
+	.etm_02_trigger_event		= 0x00000000,
+	.etm_06_te_start_stop		= 0x00000000,
+	.etm_07_te_single_addr_comp	= 0x00000000,
+	/* etm_08_te_event 0x0000006F: always true */
+	.etm_08_te_event		= 0x0000006F,
+	/* etm_09_te_control 0x01000000: exclude none */
+	.etm_09_te_control		= 0x01000000,
+	.etm_0a_fifofull_region		= 0x00000000,
+	.etm_0b_fifofull_level		= 0x00000000,
+	/* etm_0c_vd_event 0x0000006F: always true */
+	.etm_0c_vd_event                = 0x0000006F,
+	.etm_0d_vd_single_addr_comp     = 0x00000000,
+	.etm_0e_vd_mmd                  = 0x00000000,
+	/* etm_0f_vd_control 0x00010000: exclude none */
+	.etm_0f_vd_control              = 0x00010000,
+	.etm_addr_comp_value[0]         = 0x00000000,
+	.etm_addr_comp_value[1]         = 0x00000000,
+	.etm_addr_comp_value[2]         = 0x00000000,
+	.etm_addr_comp_value[3]         = 0x00000000,
+	.etm_addr_comp_value[4]         = 0x00000000,
+	.etm_addr_comp_value[5]         = 0x00000000,
+	.etm_addr_comp_value[6]         = 0x00000000,
+	.etm_addr_comp_value[7]         = 0x00000000,
+	.etm_addr_access_type[0]        = 0x00000000,
+	.etm_addr_access_type[1]        = 0x00000000,
+	.etm_addr_access_type[2]        = 0x00000000,
+	.etm_addr_access_type[3]        = 0x00000000,
+	.etm_addr_access_type[4]        = 0x00000000,
+	.etm_addr_access_type[5]        = 0x00000000,
+	.etm_addr_access_type[6]        = 0x00000000,
+	.etm_addr_access_type[7]        = 0x00000000,
+	.etm_data_comp_value[0]         = 0x00000000,
+	.etm_data_comp_value[1]         = 0x00000000,
+	.etm_data_comp_mask[0]          = 0x00000000,
+	.etm_data_comp_mask[1]          = 0x00000000,
+	.etm_counter_reload_value[0]    = 0x00000000,
+	.etm_counter_reload_value[1]    = 0x00000000,
+	.etm_counter_enable[0]          = 0x0002406F,
+	.etm_counter_enable[1]          = 0x0002406F,
+	.etm_counter_reload_event[0]    = 0x0000406F,
+	.etm_counter_reload_event[1]    = 0x0000406F,
+	.etm_60_seq_event_1_to_2        = 0x0000406F,
+	.etm_61_seq_event_2_to_1        = 0x0000406F,
+	.etm_62_seq_event_2_to_3        = 0x0000406F,
+	.etm_63_seq_event_3_to_1        = 0x0000406F,
+	.etm_64_seq_event_3_to_2        = 0x0000406F,
+	.etm_65_seq_event_1_to_3        = 0x0000406F,
+	.etm_6c_cid_comp_value_1        = 0x00000000,
+	.etm_6f_cid_comp_mask           = 0x00000000,
+	.etm_78_sync_freq               = 0x00000400,
+	.swconfig                       = 0x00000002,
+	/* etb_trig_cnt 0x00000000: ignore trigger */
+	.etb_trig_cnt                   = 0x00000000,
+	/* etb_init_ptr 0x00000010: 16 marker bytes */
+	.etb_init_ptr                   = 0x00000010,
+};
+
+static void emit_log_char(uint8_t c)
+{
+	int this_cpu = get_cpu();
+	struct b *mybuf = *per_cpu_ptr(alloc_b, this_cpu);
+	char *log_buf = mybuf->etm_log_buf;
+	int index = (mybuf->log_end)++ & (LOG_BUF_LEN - 1);
+	log_buf[index] = c;
+	put_cpu();
+}
+
+static void emit_log_word(uint32_t word)
+{
+	emit_log_char(word >> 24);
+	emit_log_char(word >> 16);
+	emit_log_char(word >> 8);
+	emit_log_char(word >> 0);
+}
+
+static void __cpu_enable_etb(void)
+{
+	uint32_t etb_control;
+	uint32_t i;
+
+	/* enable auto-increment on reads and writes */
+	etb_control = AIR | AIW;
+	etm_write_reg(ETB_REG_CONTROL, etb_control);
+
+	/* write tags to the slots before the write pointer so we can
+	 * detect overflow */
+	etm_write_reg(ETB_REG_ADDRESS, 0x00000000);
+	for (i = 0; i < (etm_config.etb_init_ptr >> 2); i++)
+		etm_write_reg(ETB_REG_DATA, 0xDEADBEEF);
+
+	etm_write_reg(ETB_REG_STATUS, 0x00000000);
+
+	/* initialize write pointer */
+	etm_write_reg(ETB_REG_ADDRESS, etm_config.etb_init_ptr);
+
+	/* multiple of 16 */
+	etm_write_reg(ETB_REG_COUNT, etm_config.etb_trig_cnt & 0xFFFFFFF0);
+
+	/* Enable ETB and enable the trigger counter as appropriate. A
+	 * trigger count of 0 will be used to signify that the user wants to
+	 * ignore the trigger (just keep writing to the ETB and overwriting
+	 * the oldest data).  For "trace before trigger" captures the user
+	 * should set the trigger count to a small number. */
+
+	etb_control |= CPTEN;
+	if (etm_config.etb_trig_cnt)
+		etb_control |= CPTM;
+	etm_write_reg(ETB_REG_CONTROL, etb_control);
+}
+
+static void __cpu_disable_etb(void)
+{
+	uint32_t etb_control;
+	etb_control = etm_read_reg(ETB_REG_CONTROL);
+	etb_control &= ~CPTEN;
+	etm_write_reg(ETB_REG_CONTROL, etb_control);
+}
+
+static void __cpu_enable_etm(void)
+{
+	uint32_t etm_control;
+	unsigned long timeout = jiffies + msecs_to_jiffies(PROG_TIMEOUT_MS);
+
+	etm_control = etm_read_reg(ETM_REG_CONTROL);
+	etm_control &= ~ETM_CONTROL_PROGRAM;
+	etm_write_reg(ETM_REG_CONTROL, etm_control);
+
+	while ((etm_read_reg(ETM_REG_STATUS) & ETM_STATUS_PROGRAMMING) == 1) {
+		cpu_relax();
+		if (time_after(jiffies, timeout)) {
+			pr_err("etm: timeout while clearing prog bit\n");
+			break;
+		}
+	}
+}
+
+static void __cpu_disable_etm(void)
+{
+	uint32_t etm_control;
+	unsigned long timeout = jiffies + msecs_to_jiffies(PROG_TIMEOUT_MS);
+
+	etm_control = etm_read_reg(ETM_REG_CONTROL);
+	etm_control |= ETM_CONTROL_PROGRAM;
+	etm_write_reg(ETM_REG_CONTROL, etm_control);
+
+	while ((etm_read_reg(ETM_REG_STATUS) & ETM_STATUS_PROGRAMMING) == 0) {
+		cpu_relax();
+		if (time_after(jiffies, timeout)) {
+			pr_err("etm: timeout while setting prog bit\n");
+			break;
+		}
+	}
+}
+
+static void __cpu_enable_trace(void *unused)
+{
+	uint32_t etm_control;
+	uint32_t etm_trigger;
+	uint32_t etm_external_output;
+
+	get_cpu();
+
+	etm_read_reg(0xC5); /* clear sticky bit in PDSR */
+
+	__cpu_disable_etb();
+	__cpu_disable_etm();
+
+	etm_control = (etm_config.etm_00_control & ~ETM_CONTROL_POWERDOWN)
+						| ETM_CONTROL_PROGRAM;
+	etm_write_reg(0x00, etm_control);
+
+	etm_trigger = etm_config.etm_02_trigger_event;
+	etm_external_output = 0x406F; /* always FALSE */
+
+	if (etm_config.swconfig & TRIGGER_ALL) {
+		uint32_t function = 0x5; /*  A OR B */
+		uint32_t resource_b = 0x60; /* external input 1 */
+
+		etm_trigger &= 0x7F; /* keep resource A, clear function and
+				      * resource B */
+		etm_trigger |= (function << 14);
+		etm_trigger |= (resource_b << 7);
+		etm_external_output = etm_trigger;
+	}
+
+	etm_write_reg(0x02, etm_trigger);
+	etm_write_reg(0x06, etm_config.etm_06_te_start_stop);
+	etm_write_reg(0x07, etm_config.etm_07_te_single_addr_comp);
+	etm_write_reg(0x08, etm_config.etm_08_te_event);
+	etm_write_reg(0x09, etm_config.etm_09_te_control);
+	etm_write_reg(0x0a, etm_config.etm_0a_fifofull_region);
+	etm_write_reg(0x0b, etm_config.etm_0b_fifofull_level);
+	etm_write_reg(0x0c, etm_config.etm_0c_vd_event);
+	etm_write_reg(0x0d, etm_config.etm_0d_vd_single_addr_comp);
+	etm_write_reg(0x0e, etm_config.etm_0e_vd_mmd);
+	etm_write_reg(0x0f, etm_config.etm_0f_vd_control);
+	etm_write_reg(0x10, etm_config.etm_addr_comp_value[0]);
+	etm_write_reg(0x11, etm_config.etm_addr_comp_value[1]);
+	etm_write_reg(0x12, etm_config.etm_addr_comp_value[2]);
+	etm_write_reg(0x13, etm_config.etm_addr_comp_value[3]);
+	etm_write_reg(0x14, etm_config.etm_addr_comp_value[4]);
+	etm_write_reg(0x15, etm_config.etm_addr_comp_value[5]);
+	etm_write_reg(0x16, etm_config.etm_addr_comp_value[6]);
+	etm_write_reg(0x17, etm_config.etm_addr_comp_value[7]);
+	etm_write_reg(0x20, etm_config.etm_addr_access_type[0]);
+	etm_write_reg(0x21, etm_config.etm_addr_access_type[1]);
+	etm_write_reg(0x22, etm_config.etm_addr_access_type[2]);
+	etm_write_reg(0x23, etm_config.etm_addr_access_type[3]);
+	etm_write_reg(0x24, etm_config.etm_addr_access_type[4]);
+	etm_write_reg(0x25, etm_config.etm_addr_access_type[5]);
+	etm_write_reg(0x26, etm_config.etm_addr_access_type[6]);
+	etm_write_reg(0x27, etm_config.etm_addr_access_type[7]);
+	etm_write_reg(0x30, etm_config.etm_data_comp_value[0]);
+	etm_write_reg(0x32, etm_config.etm_data_comp_value[1]);
+	etm_write_reg(0x40, etm_config.etm_data_comp_mask[0]);
+	etm_write_reg(0x42, etm_config.etm_data_comp_mask[1]);
+	etm_write_reg(0x50, etm_config.etm_counter_reload_value[0]);
+	etm_write_reg(0x51, etm_config.etm_counter_reload_value[1]);
+	etm_write_reg(0x54, etm_config.etm_counter_enable[0]);
+	etm_write_reg(0x55, etm_config.etm_counter_enable[1]);
+	etm_write_reg(0x58, etm_config.etm_counter_reload_event[0]);
+	etm_write_reg(0x59, etm_config.etm_counter_reload_event[1]);
+	etm_write_reg(0x60, etm_config.etm_60_seq_event_1_to_2);
+	etm_write_reg(0x61, etm_config.etm_61_seq_event_2_to_1);
+	etm_write_reg(0x62, etm_config.etm_62_seq_event_2_to_3);
+	etm_write_reg(0x63, etm_config.etm_63_seq_event_3_to_1);
+	etm_write_reg(0x64, etm_config.etm_64_seq_event_3_to_2);
+	etm_write_reg(0x65, etm_config.etm_65_seq_event_1_to_3);
+	etm_write_reg(0x68, etm_external_output);
+	etm_write_reg(0x6c, etm_config.etm_6c_cid_comp_value_1);
+	etm_write_reg(0x6f, etm_config.etm_6f_cid_comp_mask);
+	etm_write_reg(0x78, etm_config.etm_78_sync_freq);
+
+	/* Note that we must enable the ETB before we enable the ETM if we
+	 * want to capture the "always true" trigger event. */
+
+	__cpu_enable_etb();
+	__cpu_enable_etm();
+
+	put_cpu();
+}
+
+static void __cpu_disable_trace(void *unused)
+{
+	uint32_t etm_control;
+
+	get_cpu();
+	etm_read_reg(0xC5); /* clear sticky bit in PDSR */
+
+	__cpu_disable_etm();
+
+	/* program trace enable to be low by using always false event */
+	etm_write_reg(0x08, 0x6F | BIT(14));
+
+	/* set the powerdown bit */
+	etm_control = etm_read_reg(ETM_REG_CONTROL);
+	etm_control |= ETM_CONTROL_POWERDOWN;
+	etm_write_reg(ETM_REG_CONTROL, etm_control);
+
+	__cpu_disable_etb();
+
+	put_cpu();
+}
+
+static void enable_trace(void)
+{
+	wake_lock(&etm_wake_lock);
+	pm_qos_update_request(&etm_qos_req, 0);
+
+	if (etm_config.swconfig & TRIGGER_ALL) {
+		/* This register is accessible from either core.
+		 * CPU1_extout[0] -> CPU0_extin[0]
+		 * CPU_extout[0] -> CPU1_extin[0] */
+		l2tevselr0_write(0x00000001);
+	}
+
+	get_cpu();
+	__cpu_enable_trace(NULL);
+	smp_call_function(__cpu_enable_trace, NULL, 1);
+	put_cpu();
+
+	/* 1. causes all online cpus to come out of idle PC
+	 * 2. prevents idle PC until save restore flag is enabled atomically
+	 *
+	 * we rely on the user to prevent hotplug on/off racing with this
+	 * operation and to ensure cores where trace is expected to be turned
+	 * on are already hotplugged on
+	 */
+	trace_enabled = 1;
+
+	pm_qos_update_request(&etm_qos_req, PM_QOS_DEFAULT_VALUE);
+	wake_unlock(&etm_wake_lock);
+}
+
+static void disable_trace(void)
+{
+	wake_lock(&etm_wake_lock);
+	pm_qos_update_request(&etm_qos_req, 0);
+
+	get_cpu();
+	__cpu_disable_trace(NULL);
+	smp_call_function(__cpu_disable_trace, NULL, 1);
+	put_cpu();
+
+	/* 1. causes all online cpus to come out of idle PC
+	 * 2. prevents idle PC until save restore flag is disabled atomically
+	 *
+	 * we rely on the user to prevent hotplug on/off racing with this
+	 * operation and to ensure cores where trace is expected to be turned
+	 * off are already hotplugged on
+	 */
+	trace_enabled = 0;
+
+	cpu_to_dump = next_cpu_to_dump = 0;
+
+	pm_qos_update_request(&etm_qos_req, PM_QOS_DEFAULT_VALUE);
+	wake_unlock(&etm_wake_lock);
+}
+
+static void generate_etb_dump(void)
+{
+	uint32_t i;
+	uint32_t full_slots;
+	uint32_t etb_control;
+	uint32_t prim_len;
+	uint32_t uptime = 0;
+
+	etb_control = etm_read_reg(ETB_REG_CONTROL);
+	etb_control |= AIR;
+	etm_write_reg(ETB_REG_CONTROL, etb_control);
+
+	if (etm_read_reg(ETB_REG_STATUS) & OV)
+		full_slots = ETB_RAM_SLOTS;
+	else
+		full_slots = etm_read_reg(ETB_REG_ADDRESS) >> 2;
+
+	prim_len = 28 + (full_slots * 4);
+
+	emit_log_char((DATALOG_SYNC >> 8) & 0xFF);
+	emit_log_char((DATALOG_SYNC >> 0) & 0xFF);
+	emit_log_char((prim_len >> 8) & 0xFF);
+	emit_log_char((prim_len >> 0) & 0xFF);
+	emit_log_word(uptime);
+	emit_log_word(ETB_DUMP_MSG_ID);
+	emit_log_word(etm_read_reg(ETM_REG_CONTROL));
+	emit_log_word(etm_config.etb_init_ptr >> 2);
+	emit_log_word(etm_read_reg(ETB_REG_ADDRESS) >> 2);
+	emit_log_word((etm_read_reg(ETB_REG_STATUS) & OV) >> 21);
+
+	etm_write_reg(ETB_REG_ADDRESS, 0x00000000);
+	for (i = 0; i < full_slots; i++)
+		emit_log_word(etm_read_reg(ETB_REG_DATA));
+}
+
+static void generate_etm_dump(void)
+{
+	uint32_t i;
+	uint32_t prim_len;
+	uint32_t uptime = 0;
+
+	prim_len = 12 + (4 * ETM_NUM_REGS);
+
+	emit_log_char((DATALOG_SYNC >> 8) & 0xFF);
+	emit_log_char((DATALOG_SYNC >> 0) & 0xFF);
+	emit_log_char((prim_len >> 8) & 0xFF);
+	emit_log_char((prim_len >> 0) & 0xFF);
+	emit_log_word(uptime);
+	emit_log_word(ETM_DUMP_MSG_ID);
+
+	/* do not disturb ETB_REG_ADDRESS by reading ETB_REG_DATA */
+	for (i = 0; i < ETM_NUM_REGS; i++)
+		if (i == ETB_REG_DATA)
+			emit_log_word(0);
+		else
+			emit_log_word(etm_read_reg(i));
+}
+
+static void dump_all(void *unused)
+{
+	get_cpu();
+	etm_read_reg(0xC5); /* clear sticky bit in PDSR in case
+			     * trace hasn't been enabled yet. */
+	__cpu_disable_etb();
+	generate_etm_dump();
+	generate_etb_dump();
+	if (trace_enabled)
+		__cpu_enable_etb();
+	put_cpu();
+}
+
+static void dump_trace(void)
+{
+	get_cpu();
+	dump_all(NULL);
+	smp_call_function(dump_all, NULL, 1);
+	put_cpu();
+}
+
+static int bytes_to_dump;
+static uint8_t *etm_buf_ptr;
+
+static int etm_dev_open(struct inode *inode, struct file *file)
+{
+	if (atomic_cmpxchg(&etm_dev_in_use, 0, 1))
+		return -EBUSY;
+
+	pr_debug("%s: successfully opened\n", __func__);
+	return 0;
+}
+
+static ssize_t etm_dev_read(struct file *file, char __user *data,
+				size_t len, loff_t *ppos)
+{
+	if (cpu_to_dump == next_cpu_to_dump) {
+		if (cpu_to_dump == 0)
+			dump_trace();
+		bytes_to_dump = buf[cpu_to_dump].log_end;
+		buf[cpu_to_dump].log_end = 0;
+		etm_buf_ptr = buf[cpu_to_dump].etm_log_buf;
+		next_cpu_to_dump++;
+		if (next_cpu_to_dump >= num_possible_cpus())
+			next_cpu_to_dump = 0;
+	}
+
+	if (len > bytes_to_dump)
+		len = bytes_to_dump;
+
+	if (copy_to_user(data, etm_buf_ptr, len)) {
+		pr_debug("%s: copy_to_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	bytes_to_dump -= len;
+	etm_buf_ptr += len;
+
+	pr_debug("%s: %d bytes copied, %d bytes left (cpu %d)\n",
+		 __func__, len, bytes_to_dump, next_cpu_to_dump);
+	return len;
+}
+
+static void setup_range_filter(char addr_type, char range, uint32_t reg1,
+				uint32_t addr1, uint32_t reg2, uint32_t addr2)
+{
+	etm_config.etm_addr_comp_value[reg1] = addr1;
+	etm_config.etm_addr_comp_value[reg2] = addr2;
+
+	etm_config.etm_07_te_single_addr_comp |= (1 << reg1);
+	etm_config.etm_07_te_single_addr_comp |= (1 << reg2);
+
+	etm_config.etm_09_te_control |= (1 << (reg1/2));
+	if (range == 'i')
+		etm_config.etm_09_te_control &= ~(1 << 24);
+	else if (range == 'e')
+		etm_config.etm_09_te_control |= (1 << 24);
+
+	if (addr_type == 'i') {
+		etm_config.etm_addr_access_type[reg1] = 0x99;
+		etm_config.etm_addr_access_type[reg2] = 0x99;
+	} else if (addr_type == 'd') {
+		etm_config.etm_addr_access_type[reg1] = 0x9C;
+		etm_config.etm_addr_access_type[reg2] = 0x9C;
+	}
+}
+
+static void setup_start_stop_filter(char addr_type, char start_stop,
+				uint32_t reg, uint32_t addr)
+{
+	etm_config.etm_addr_comp_value[reg] = addr;
+
+	if (start_stop == 's')
+		etm_config.etm_06_te_start_stop |= (1 << reg);
+	else if (start_stop == 't')
+		etm_config.etm_06_te_start_stop |= (1 << (reg + 16));
+
+	etm_config.etm_09_te_control |= (1 << 25);
+
+	if (addr_type == 'i')
+		etm_config.etm_addr_access_type[reg] = 0x99;
+	else if (addr_type == 'd')
+		etm_config.etm_addr_access_type[reg] = 0x9C;
+}
+
+static void setup_viewdata_range_filter(char range, uint32_t reg1,
+				uint32_t addr1, uint32_t reg2, uint32_t addr2)
+{
+	etm_config.etm_addr_comp_value[reg1] = addr1;
+	etm_config.etm_addr_comp_value[reg2] = addr2;
+
+	if (range == 'i') {
+		etm_config.etm_0d_vd_single_addr_comp |= (1 << reg1);
+		etm_config.etm_0d_vd_single_addr_comp |= (1 << reg2);
+		etm_config.etm_0f_vd_control |= (1 << (reg1/2));
+	} else if (range == 'e') {
+		etm_config.etm_0d_vd_single_addr_comp |= (1 << (reg1 + 16));
+		etm_config.etm_0d_vd_single_addr_comp |= (1 << (reg2 + 16));
+		etm_config.etm_0f_vd_control |= (1 << ((reg1/2) + 8));
+	}
+	etm_config.etm_0f_vd_control &= ~(1 << 16);
+
+	etm_config.etm_addr_access_type[reg1] = 0x9C;
+	etm_config.etm_addr_access_type[reg2] = 0x9C;
+}
+
+static void setup_viewdata_start_stop_filter(char start_stop, uint32_t reg,
+				uint32_t addr)
+{
+	etm_config.etm_addr_comp_value[reg] = addr;
+
+	if (start_stop == 's')
+		etm_config.etm_06_te_start_stop |= (1 << reg);
+	else if (start_stop == 't')
+		etm_config.etm_06_te_start_stop |= (1 << (reg + 16));
+
+	etm_config.etm_addr_access_type[reg] = 0x9C;
+}
+
+static void setup_access_type(uint32_t reg, uint32_t value)
+{
+	etm_config.etm_addr_access_type[reg] &= 0xFFFFFFF8;
+	value &= 0x7;
+	etm_config.etm_addr_access_type[reg] |= value;
+}
+
+static void reset_filter(void)
+{
+	etm_config.etm_00_control			= 0x0000D84E;
+	/* etm_02_trigger_event 0x00000000: address comparator 0 matches */
+	etm_config.etm_02_trigger_event		= 0x00000000;
+	etm_config.etm_06_te_start_stop		= 0x00000000;
+	etm_config.etm_07_te_single_addr_comp	= 0x00000000;
+	/* etm_08_te_event 0x0000006F: always true */
+	etm_config.etm_08_te_event		= 0x0000006F;
+	/* etm_09_te_control 0x01000000: exclude none */
+	etm_config.etm_09_te_control		= 0x01000000;
+	etm_config.etm_0a_fifofull_region		= 0x00000000;
+	etm_config.etm_0b_fifofull_level		= 0x00000000;
+	/* etm_0c_vd_event 0x0000006F: always true */
+	etm_config.etm_0c_vd_event                = 0x0000006F;
+	etm_config.etm_0d_vd_single_addr_comp     = 0x00000000;
+	etm_config.etm_0e_vd_mmd                  = 0x00000000;
+	/* etm_0f_vd_control 0x00010000: exclude none */
+	etm_config.etm_0f_vd_control              = 0x00010000;
+	etm_config.etm_addr_comp_value[0]         = 0x00000000;
+	etm_config.etm_addr_comp_value[1]         = 0x00000000;
+	etm_config.etm_addr_comp_value[2]         = 0x00000000;
+	etm_config.etm_addr_comp_value[3]         = 0x00000000;
+	etm_config.etm_addr_comp_value[4]         = 0x00000000;
+	etm_config.etm_addr_comp_value[5]         = 0x00000000;
+	etm_config.etm_addr_comp_value[6]         = 0x00000000;
+	etm_config.etm_addr_comp_value[7]         = 0x00000000;
+	etm_config.etm_addr_access_type[0]        = 0x00000000;
+	etm_config.etm_addr_access_type[1]        = 0x00000000;
+	etm_config.etm_addr_access_type[2]        = 0x00000000;
+	etm_config.etm_addr_access_type[3]        = 0x00000000;
+	etm_config.etm_addr_access_type[4]        = 0x00000000;
+	etm_config.etm_addr_access_type[5]        = 0x00000000;
+	etm_config.etm_addr_access_type[6]        = 0x00000000;
+	etm_config.etm_addr_access_type[7]        = 0x00000000;
+	etm_config.etm_data_comp_value[0]         = 0x00000000;
+	etm_config.etm_data_comp_value[1]         = 0x00000000;
+	etm_config.etm_data_comp_mask[0]          = 0x00000000;
+	etm_config.etm_data_comp_mask[1]          = 0x00000000;
+	etm_config.etm_counter_reload_value[0]    = 0x00000000;
+	etm_config.etm_counter_reload_value[1]    = 0x00000000;
+	etm_config.etm_counter_enable[0]          = 0x0002406F;
+	etm_config.etm_counter_enable[1]          = 0x0002406F;
+	etm_config.etm_counter_reload_event[0]    = 0x0000406F;
+	etm_config.etm_counter_reload_event[1]    = 0x0000406F;
+	etm_config.etm_60_seq_event_1_to_2        = 0x0000406F;
+	etm_config.etm_61_seq_event_2_to_1        = 0x0000406F;
+	etm_config.etm_62_seq_event_2_to_3        = 0x0000406F;
+	etm_config.etm_63_seq_event_3_to_1        = 0x0000406F;
+	etm_config.etm_64_seq_event_3_to_2        = 0x0000406F;
+	etm_config.etm_65_seq_event_1_to_3        = 0x0000406F;
+	etm_config.etm_6c_cid_comp_value_1        = 0x00000000;
+	etm_config.etm_6f_cid_comp_mask           = 0x00000000;
+	etm_config.etm_78_sync_freq               = 0x00000400;
+	etm_config.swconfig                       = 0x00000002;
+	/* etb_trig_cnt 0x00000020: ignore trigger */
+	etm_config.etb_trig_cnt                   = 0x00000000;
+	/* etb_init_ptr 0x00000010: 16 marker bytes */
+	etm_config.etb_init_ptr                   = 0x00000010;
+}
+
+#define MAX_COMMAND_STRLEN  40
+static ssize_t etm_dev_write(struct file *file, const char __user *data,
+				size_t len, loff_t *ppos)
+{
+	char command[MAX_COMMAND_STRLEN];
+	int strlen;
+	unsigned long value;
+	unsigned long reg1, reg2;
+	unsigned long addr1, addr2;
+
+	strlen = strnlen_user(data, MAX_COMMAND_STRLEN);
+	pr_debug("etm: string length: %d", strlen);
+	if (strlen == 0 || strlen == (MAX_COMMAND_STRLEN+1)) {
+		pr_err("etm: error in strlen: %d", strlen);
+		return -EFAULT;
+	}
+	/* includes the null character */
+	if (copy_from_user(command, data, strlen)) {
+		pr_err("etm: error in copy_from_user: %d", strlen);
+		return -EFAULT;
+	}
+
+	pr_debug("etm: input = %s", command);
+
+	switch (command[0]) {
+	case '0':
+		if (trace_enabled) {
+			disable_trace();
+			pr_info("etm: tracing disabled\n");
+		}
+		break;
+	case '1':
+		if (!trace_enabled) {
+			enable_trace();
+			pr_info("etm: tracing enabled\n");
+		}
+		break;
+	case 'f':
+		switch (command[2]) {
+		case 'i':
+		case 'd':
+			switch (command[4]) {
+			case 'i':
+				if (sscanf(&command[6], "%lx:%lx:%lx:%lx\\0",
+					&reg1, &addr1, &reg2, &addr2) != 4)
+					goto err_out;
+				if (reg1 > 7 || reg2 > 7 || (reg1 % 2))
+					goto err_out;
+				setup_range_filter(command[2], 'i',
+					reg1, addr1, reg2, addr2);
+				break;
+			case 'e':
+				if (sscanf(&command[6], "%lx:%lx:%lx:%lx\\0",
+					&reg1, &addr1, &reg2, &addr2) != 4)
+					goto err_out;
+				if (reg1 > 7 || reg2 > 7 || (reg1 % 2)
+					|| command[2] == 'd')
+					goto err_out;
+				setup_range_filter(command[2], 'e',
+					reg1, addr1, reg2, addr2);
+				break;
+			case 's':
+				if (sscanf(&command[6], "%lx:%lx\\0",
+					&reg1, &addr1) != 2)
+					goto err_out;
+				if (reg1 > 7)
+					goto err_out;
+				setup_start_stop_filter(command[2], 's',
+					reg1, addr1);
+				break;
+			case 't':
+				if (sscanf(&command[6], "%lx:%lx\\0",
+						&reg1, &addr1) != 2)
+					goto err_out;
+				if (reg1 > 7)
+					goto err_out;
+				setup_start_stop_filter(command[2], 't',
+					reg1, addr1);
+				break;
+			default:
+				goto err_out;
+			}
+			break;
+		case 'r':
+			reset_filter();
+			break;
+		default:
+			goto err_out;
+		}
+		break;
+	case 'v':
+		switch (command[2]) {
+		case 'd':
+			switch (command[4]) {
+			case 'i':
+				if (sscanf(&command[6], "%lx:%lx:%lx:%lx\\0",
+					&reg1, &addr1, &reg2, &addr2) != 4)
+					goto err_out;
+				if (reg1 > 7 || reg2 > 7 || (reg1 % 2))
+					goto err_out;
+				setup_viewdata_range_filter('i',
+					reg1, addr1, reg2, addr2);
+				break;
+			case 'e':
+				if (sscanf(&command[6], "%lx:%lx:%lx:%lx\\0",
+					&reg1, &addr1, &reg2, &addr2) != 4)
+					goto err_out;
+				if (reg1 > 7 || reg2 > 7 || (reg1 % 2))
+					goto err_out;
+				setup_viewdata_range_filter('e',
+					reg1, addr1, reg2, addr2);
+				break;
+			case 's':
+				if (sscanf(&command[6], "%lx:%lx\\0",
+					&reg1, &addr1) != 2)
+					goto err_out;
+				if (reg1 > 7)
+					goto err_out;
+				setup_viewdata_start_stop_filter('s',
+					reg1, addr1);
+				break;
+			case 't':
+				if (sscanf(&command[6], "%lx:%lx\\0",
+					&reg1, &addr1) != 2)
+					goto err_out;
+				if (reg1 > 7)
+					goto err_out;
+				setup_viewdata_start_stop_filter('t',
+					reg1, addr1);
+				break;
+			default:
+				goto err_out;
+			}
+			break;
+		default:
+			goto err_out;
+		}
+		break;
+	case 'a':
+		switch (command[2]) {
+		case 't':
+			if (sscanf(&command[4], "%lx:%lx\\0",
+					&reg1, &value) != 2)
+				goto err_out;
+			if (reg1 > 7 || value > 6)
+				goto err_out;
+			setup_access_type(reg1, value);
+			break;
+		default:
+			goto err_out;
+		}
+		break;
+	default:
+		goto err_out;
+	}
+
+	return len;
+
+err_out:
+	return -EFAULT;
+}
+
+static int etm_dev_release(struct inode *inode, struct file *file)
+{
+	if (cpu_to_dump == next_cpu_to_dump)
+		next_cpu_to_dump = 0;
+	cpu_to_dump = next_cpu_to_dump;
+
+	atomic_set(&etm_dev_in_use, 0);
+	pr_debug("%s: released\n", __func__);
+	return 0;
+}
+
+static const struct file_operations etm_dev_fops = {
+	.owner = THIS_MODULE,
+	.open = etm_dev_open,
+	.read = etm_dev_read,
+	.write = etm_dev_write,
+	.release = etm_dev_release,
+};
+
+static struct miscdevice etm_dev = {
+	.name = "msm_etm",
+	.minor = MISC_DYNAMIC_MINOR,
+	.fops = &etm_dev_fops,
+};
+
+/* etm_save_reg_check and etm_restore_reg_check should be fast
+ *
+ * These functions will be called either from:
+ * 1. per_cpu idle thread context for idle power collapses.
+ * 2. per_cpu idle thread context for hotplug/suspend power collapse for
+ *    nonboot cpus.
+ * 3. suspend thread context for core0.
+ *
+ * In all cases we are guaranteed to be running on the same cpu for the
+ * entire duration.
+ *
+ * Another assumption is that etm registers won't change after trace_enabled
+ * is set. Current usage model guarantees this doesn't happen.
+ *
+ * Also disabling all types of power_collapses when enabling and disabling
+ * trace provides mutual exclusion to be able to safely access
+ * ptm.trace_enabled here.
+ */
+void etm_save_reg_check(void)
+{
+	if (trace_enabled)
+		etm_save_reg();
+}
+
+void etm_restore_reg_check(void)
+{
+	if (trace_enabled)
+		etm_restore_reg();
+}
+
+static int __init etm_init(void)
+{
+	int ret, cpu;
+
+	ret = misc_register(&etm_dev);
+	if (ret)
+		return -ENODEV;
+
+	alloc_b = alloc_percpu(typeof(*alloc_b));
+	if (!alloc_b)
+		goto err1;
+
+	for_each_possible_cpu(cpu)
+		*per_cpu_ptr(alloc_b, cpu) = &buf[cpu];
+
+	wake_lock_init(&etm_wake_lock, WAKE_LOCK_SUSPEND, "msm_etm");
+	pm_qos_add_request(&etm_qos_req, PM_QOS_CPU_DMA_LATENCY,
+						PM_QOS_DEFAULT_VALUE);
+
+	cpu_to_dump = next_cpu_to_dump = 0;
+
+	pr_info("ETM/ETB intialized.\n");
+
+	if (trace_on_boot)
+		enable_trace();
+
+	return 0;
+
+err1:
+	misc_deregister(&etm_dev);
+	return -ENOMEM;
+}
+module_init(etm_init);
+
+static void __exit etm_exit(void)
+{
+	disable_trace();
+	pm_qos_remove_request(&etm_qos_req);
+	wake_lock_destroy(&etm_wake_lock);
+	free_percpu(alloc_b);
+	misc_deregister(&etm_dev);
+}
+module_exit(etm_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("embedded trace driver");
diff --git a/arch/arm/mach-msm/include/mach/msm_serial_hs.h b/arch/arm/mach-msm/include/mach/msm_serial_hs.h
index 890cfc0..0c4603e 100644
--- a/arch/arm/mach-msm/include/mach/msm_serial_hs.h
+++ b/arch/arm/mach-msm/include/mach/msm_serial_hs.h
@@ -25,11 +25,16 @@ struct msm_serial_hs_platform_data {
 	unsigned char inject_rx_on_wakeup;
 	char rx_to_inject;
 	int (*gpio_config)(int);
-#ifdef CONFIG_SERIAL_BCM_BT_LPM
-	void (*exit_lpm_cb)(struct uart_port *);
-#endif
+
+	unsigned char cpu_lock_supported;
+
+	/* for bcm BT */
+	int rx_wakeup_irq;  /* wakeup irq */
+	unsigned char bt_wakeup_pin_supported;
+	unsigned char bt_wakeup_pin;	/* Device to Chip */
+	unsigned char host_wakeup_pin;	/* Chip to Device */
 };
-#ifdef CONFIG_MACH_RUBY
+#if 1		//Add by evan.xu@2012-02-02
 /* API for TI_ST */
 extern void ti_msm_hs_request_clock_off(struct uart_port *uport);
 extern void ti_msm_hs_request_clock_on(struct uart_port *uport);
@@ -37,16 +42,10 @@ struct msm_serial_hs_platform_data {
 extern void ti_dc_msm_hs_request_clock_on(struct uart_port *uport);
 #endif
 
+extern void imc_msm_hs_request_clock_on(struct uart_port *uport);
 unsigned int msm_hs_tx_empty(struct uart_port *uport);
 void msm_hs_request_clock_off(struct uart_port *uport);
 void msm_hs_request_clock_on(struct uart_port *uport);
 void msm_hs_set_mctrl(struct uart_port *uport,
 				    unsigned int mctrl);
-
-#ifdef CONFIG_SERIAL_BCM_BT_LPM
-/* uport->lock must be held when calling _locked() */
-extern void msm_hs_request_clock_off_locked(struct uart_port *uport);
-extern void msm_hs_request_clock_on_locked(struct uart_port *uport);
-#endif
-
 #endif
diff --git a/drivers/media/video/msm/sensors/ov8830.c b/drivers/media/video/msm/sensors/ov8830.c
new file mode 100644
index 0000000..74991c4
--- /dev/null
+++ b/drivers/media/video/msm/sensors/ov8830.c
@@ -0,0 +1,2485 @@
+/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#include <linux/slab.h>
+#include <media/msm_camera_sensor.h>
+#include <mach/gpio.h>
+#ifdef CONFIG_MSM_CAMERA_8X60
+#include <mach/camera-8x60.h>
+#elif defined(CONFIG_MSM_CAMERA_7X30)
+#include <mach/camera-7x30.h>
+#else
+#include <mach/camera.h>
+#endif
+#include <mach/vreg.h>
+#include <asm/mach-types.h>
+#include "ov8830.h"
+
+
+/* CAMIF output resolutions */
+/* 816x612, 24MHz MCLK 96MHz PCLK */
+#define OV8830_QTR_SIZE_DUMMY_PIXELS	0
+#define OV8830_QTR_SIZE_DUMMY_LINES	0
+#define OV8830_QTR_SIZE_WIDTH		1640
+#define OV8830_QTR_SIZE_HEIGHT		1232
+
+#define OV8830_FULL_SIZE_DUMMY_PIXELS	0
+#define OV8830_FULL_SIZE_DUMMY_LINES	0
+#define OV8830_FULL_SIZE_WIDTH		3280
+#define OV8830_FULL_SIZE_HEIGHT		2464
+
+#define OV8830_VIDE_SIZE_DUMMY_PIXELS	0
+#define OV8830_VIDE_SIZE_DUMMY_LINES	0
+#if defined(CONFIG_MACH_RUNNYMEDE)
+#define OV8830_VIDEO_SIZE_WIDTH		1640
+#define OV8830_VIDEO_SIZE_HEIGHT	1232
+#define OV8830_VIDEO_SIZE_WIDTH_FAST   1632 /* 1632 */ /* 1640 */ /* 656 */
+#define OV8830_VIDEO_SIZE_HEIGHT_FAST   768 /* 768 */ /* 1232 */ /* 496 */
+#else
+#define OV8830_VIDEO_SIZE_WIDTH		3088
+#define OV8830_VIDEO_SIZE_HEIGHT	1736
+#define OV8830_VIDEO_SIZE_WIDTH_FAST   1640
+#define OV8830_VIDEO_SIZE_HEIGHT_FAST   916
+#endif
+
+#define OV8830_HRZ_QTR_BLK_PIXELS	1968
+#define OV8830_VER_QTR_BLK_LINES	36
+#define OV8830_HRZ_FULL_BLK_PIXELS	328  /*stella 1203*/
+#define OV8830_VER_FULL_BLK_LINES	36
+#if defined(CONFIG_MACH_RUNNYMEDE)
+#define OV8830_HRZ_VIDEO_BLK_PIXELS	1968
+#define OV8830_VER_VIDEO_BLK_LINES	36
+#define OV8830_HRZ_VIDEO_BLK_PIXELS_FAST  1976 /* 1976 */ /* 1968 */ /* 2952 */
+#define OV8830_VER_VIDEO_BLK_LINES_FAST    116 /* 116 */ /* 96 */ /* 168 */
+#else
+#define OV8830_HRZ_VIDEO_BLK_PIXELS	520
+#define OV8830_VER_VIDEO_BLK_LINES	149
+#define OV8830_HRZ_VIDEO_BLK_PIXELS_FAST  1968
+#define OV8830_VER_VIDEO_BLK_LINES_FAST		82
+#endif
+
+#define OV8830_MIN_COARSE_INTEGRATION_TIME 1
+#define OV8830_OFFSET				12
+
+static int cam_mode_sel = 0; /* 0: photo, 1: video@30fps, 2: video@24fps */
+/* 240: 26, 365: 24, 589: 21 */
+const int ov8830_ver_qtr_blk_lines_array[] = {44, 44, 365};
+
+/*=============================================================
+	SENSOR REGISTER DEFINES
+==============================================================*/
+#define Q8				0x00000100
+
+/* Omnivision8830 product ID register address */
+#define OV8830_PIDH_REG			0x300A
+#define OV8830_PIDL_REG			0x300B
+
+/* Omnivision8830 product ID */
+#define OV8830_PID			0x88
+/* Omnivision8830 version */
+#define OV8830_VER			0x30
+
+/* Time in milisecs for waiting for the sensor to reset */
+#define OV8830_RESET_DELAY_MSECS	66
+
+#define OV8830_DEFAULT_CLOCK_RATE	24000000
+
+/* Registers*/
+/* PLL Registers */
+#define REG_PRE_PLL_CLK_DIV		0x3011 /*0x0305*/
+#define REG_PLL_MULTIPLIER		0x3010
+#define REG_VT_CLK_DIV			0x300E	/*[7:4]VT_SYS_DIV, [3-0]VT_PIX_DIV*/
+#define REG_OP_CLK_DIV			0x300F	/*[7:4]OP_SYS_DIV, [3-0]OP_PIX_DIV*/
+
+/* ISP Enable Control */
+#define REG_ISP_ENABLE_CONTROL_00	0x3302
+#define REG_ISP_ENABLE_CONTROL_01	0x3301
+
+/* AWB Control */
+#define REG_AWB_CTRL_0			0x3320
+#define REG_AWB_CTRL_1			0x3321
+#define REG_AWB_CTRL_2			0x3322
+#define REG_AWB_CTRL_8			0x3328
+
+/* Output Size */
+#define REG_X_OUTPUT_SIZE_MSB		0x302C
+#define REG_X_OUTPUT_SIZE_LSB		0x302D
+#define REG_Y_OUTPUT_SIZE_MSB		0x302E
+#define REG_Y_OUTPUT_SIZE_LSB		0x302F
+
+/*Reserved register */
+#define REG_BINNING_CONTROL		0x3091
+
+/* Frame Fotmat */
+#define REG_FRAME_LENGTH_LINES_MSB	0x3020
+#define REG_FRAME_LENGTH_LINES_LSB	0x3021
+#define REG_LINE_LENGTH_PCK_MSB		0x3022
+#define REG_LINE_LENGTH_PCK_LSB		0x3023
+#define REG_EXTRA_VSYNC_WIDTH_MSB	0x301E
+#define REG_EXTRA_VSYNC_WIDTH_LSB	0x301F
+
+#define REG_VSYNC_WIDTH_MSB	0x380E  /*px301E*/
+#define REG_VSYNC_WIDTH_LSB	0x380F  /*0x301F*/
+
+#define REG_X_ADDR_START_HIGH		0x3024
+#define REG_X_ADDR_START_LOW		0x3025
+#define REG_Y_ADDR_START_HIGH		0x3026
+#define REG_Y_ADDR_START_LOW		0x3027
+#define REG_X_ADDR_END_HIGH		0x3028
+#define REG_X_ADDR_END_LOW		0x3029
+#define REG_Y_ADDR_END_HIGH		0x302A
+#define REG_Y_ADDR_END_LOW		0x302B
+
+/* Gain setting register */
+#define OV8830_GAIN			0x3000
+
+#define OV8830_GAIN_MSB			0x350A
+#define OV8830_GAIN_LSB			0x350B
+
+#define OV8830_AEC_MSB_24	        0x3500 /*easter for frame rate=10fps 20110526*/
+#define OV8830_AEC_MSB			0x3501
+#define OV8830_AEC_LSB			0x3502
+
+/* additional gain function provided by OV8830,
+ * original gain can changed to 1x, 2x or 4x
+ * to increase the gain that OV8830 can provide */
+#define OV8830_REG_MUL_GAIN		0x3006
+#define MUL_GAIN_INIT_VALUE		0x00
+
+#define OV8830_MAX_EXPOSURE_GAIN	0x1FF
+
+/* Mode select register */
+#define OV8830_REG_MODE_SELECT		0x30FA	/* image system */
+#define OV8830_MODE_SELECT_STREAM	0x01	/* start streaming */
+#define OV8830_MODE_SELECT_SW_STANDBY	0x00	/* software standby */
+#define OV8830_REG_SOFTWARE_RESET	0x3012	/* 0x0103 */
+#define OV8830_SOFTWARE_RESET		0x80	/* 0x01 */
+
+#define OV8830_REG_MODE_FLIP		0x3820
+#define OV8830_REG_MODE_MIRROR		0x3821
+
+#define OV8830_REG_FLIP		0x52
+#define OV8830_REG_MIRROR		0x08
+
+/* AF Total steps parameters */
+#define OV8830_AF_MSB			0x30EC
+#define OV8830_AF_LSB			0x30ED
+
+#define OV8830_AF_I2C_ADDR 0x18
+#define OV8830_VCM_CODE_MSB 0x04
+#define OV8830_VCM_CODE_LSB 0x05
+#define OV8830_SW_DAMPING_STEP 10
+#define OV8830_MAX_FPS 30
+
+#define OV8830_STEPS_NEAR_TO_CLOSEST_INF	42 /*43 stella0122 */
+#define OV8830_TOTAL_STEPS_NEAR_TO_FAR		42 /*43 stella0122 */
+
+/*Test pattern*/
+/* Color bar pattern selection */
+#define OV8830_COLOR_BAR_PATTERN_SEL_REG	0x307B
+
+/* Color bar enabling control */
+#define OV8830_COLOR_BAR_ENABLE_REG		0x307D
+
+/* I2C Address of the Sensor */
+#define OV8830_I2C_SLAVE_ID		0x6C
+
+/*LSC table length*/
+#define LSC_table_length 144
+
+/*============================================================================
+TYPE DECLARATIONS
+============================================================================*/
+
+struct awb_lsc_struct_type {
+       unsigned int caBuff[8];  /*awb_calibartion*/
+	struct reg_addr_val_pair_struct LSC_table[150];  /*lsc_calibration*/
+	uint32_t LSC_table_CRC;
+};
+
+enum ov8830_test_mode_t {
+	TEST_OFF,
+	TEST_1,
+	TEST_2,
+	TEST_3
+};
+
+enum ov8830_resolution_t {
+	QTR_SIZE,
+	FULL_SIZE,
+	QVGA_SIZE,
+	VIDEO_SIZE,
+	FAST_VIDEO_SIZE,
+	INVALID_SIZE
+};
+
+/*LSC calibration*/
+int global_mode;
+/*TODO: should be use a header file to reference this function*/
+extern unsigned char *get_cam_awb_cal(void);
+
+static int ov8830_common_deinit(void);
+
+static int sensor_probe_node = 0;
+static int preview_frame_count = 0;
+
+static struct wake_lock ov8830_wake_lock;
+
+static inline void init_suspend(void)
+{
+	wake_lock_init(&ov8830_wake_lock, WAKE_LOCK_IDLE, "ov8830");
+}
+
+static inline void deinit_suspend(void)
+{
+	wake_lock_destroy(&ov8830_wake_lock);
+}
+
+static inline void prevent_suspend(void)
+{
+	wake_lock(&ov8830_wake_lock);
+}
+
+static inline void allow_suspend(void)
+{
+	wake_unlock(&ov8830_wake_lock);
+}
+
+/*============================================================================
+DATA DECLARATIONS
+============================================================================*/
+
+/* AF Tuning Parameters */
+
+static uint16_t ov8830_step_position_table[OV8830_TOTAL_STEPS_NEAR_TO_FAR+1];
+
+/*static uint32_t stored_line_length_ratio = 1 * Q8;*/
+
+static uint16_t write_cnt;
+/*static uint16_t updated_BLC;*/ /* only set to 0x50 after 1st update again*/
+
+uint8_t S3_to_0 = 0x1; /* 0x9 */
+
+/* static Variables*/
+static uint16_t step_position_table[OV8830_TOTAL_STEPS_NEAR_TO_FAR+1];
+
+
+/* FIXME: Changes from here */
+struct ov8830_work {
+	struct work_struct work;
+};
+
+static struct  ov8830_work *ov8830_sensorw;
+static struct  i2c_client *ov8830_client;
+static uint16_t ov8830_pos_tbl[OV8830_TOTAL_STEPS_NEAR_TO_FAR + 1];
+
+static struct vreg *vreg_af_actuator;
+
+enum ov8830_reg_update_t{
+	REG_INIT,
+	REG_PERIODIC
+};
+
+
+struct ov8830_ctrl {
+	const struct  msm_camera_sensor_info *sensordata;
+
+	uint32_t sensormode;
+	uint32_t fps_divider; 		/* init to 1 * 0x00000400 */
+	uint32_t pict_fps_divider; 	/* init to 1 * 0x00000400 */
+	uint16_t fps;
+
+	int16_t  curr_lens_pos;
+	uint16_t curr_step_pos;
+	uint16_t init_curr_lens_pos;
+	uint16_t my_reg_gain;
+	uint16_t my_reg_dig_gain;
+	uint32_t my_reg_line_count;
+	uint16_t total_lines_per_frame;
+
+	enum ov8830_resolution_t prev_res;
+	enum ov8830_resolution_t pict_res;
+	enum ov8830_resolution_t curr_res;
+	enum ov8830_test_mode_t  set_test;
+  enum ov8830_reg_update_t reg_update;
+
+	unsigned short imgaddr;
+};
+
+
+static struct ov8830_ctrl *ov8830_ctrl;
+static struct platform_device *ov8830_pdev;
+
+struct ov8830_waitevent{
+	uint32_t waked_up;
+	wait_queue_head_t event_wait;
+};
+static struct ov8830_waitevent ov8830_event;
+
+static DECLARE_WAIT_QUEUE_HEAD(ov8830_wait_queue);
+DEFINE_SEMAPHORE(ov8830_sem);
+
+
+/*=============================================================*/
+
+static int ov8830_i2c_rxdata(unsigned short saddr,
+	unsigned char *rxdata, int length)
+{
+	struct i2c_msg msgs[] = {
+	{
+		.addr   = saddr,
+		.flags = 0,
+		.len   = 2,
+		.buf   = rxdata,
+	},
+	{
+		.addr  = saddr,
+		.flags = I2C_M_RD,
+		.len   = length,
+		.buf   = rxdata,
+	},
+	};
+	CDBG("[CAM] %s: saddr=0x%X\n", __func__, saddr);
+	CDBG("[CAM] %s: raddr=0x%X\n", __func__, *rxdata);
+
+	if (i2c_transfer(ov8830_client->adapter, msgs, 2) < 0) {
+		pr_err("[CAM]ov8830_i2c_rxdata failed!\n");
+		return -EIO;
+	}
+	CDBG("[CAM] %s: rxdata=0x%X\n", __func__, *rxdata);
+
+	return 0;
+}
+static int32_t ov8830_i2c_txdata(unsigned short saddr,
+				 unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+		 .addr = saddr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txdata,
+		 },
+	};
+	if (i2c_transfer(ov8830_client->adapter, msg, 1) < 0) {
+		pr_err("[CAM]ov8830_i2c_txdata faild 0x%x\n", ov8830_client->addr);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+static int32_t ov8830_i2c_read(unsigned short raddr,
+				unsigned short *rdata, int rlen)
+{
+	int32_t rc = 0;
+	unsigned char buf[2];
+	int count = 0;
+	if (!rdata)
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	buf[0] = (raddr & 0xFF00) >> 8;
+	buf[1] = (raddr & 0x00FF);
+retry:
+	rc = ov8830_i2c_rxdata(ov8830_client->addr, buf, rlen);
+
+	if (rc < 0) {
+		pr_err("[CAM]ov8830_i2c_read 0x%x failed!\n", raddr);
+		pr_err("[CAM] starting read retry policy count:%d\n", count);
+		udelay(10);
+		count++;
+		if (count < 20) {
+			if (count > 10)
+				udelay(100);
+		} else
+			return rc;
+		goto retry;
+	}
+
+	*rdata = (rlen == 2 ? buf[0] << 8 | buf[1] : buf[0]);
+	return rc;
+}
+
+
+static int32_t ov8830_i2c_write_b(unsigned short saddr,
+				unsigned short waddr, uint8_t bdata)
+{
+	int32_t rc = -EFAULT;
+	unsigned char buf[3];
+	int count = 0;
+	CDBG("[CAM] i2c_write_w_b, addr = 0x%x, val = 0x%x!\n", waddr, bdata);
+
+	memset(buf, 0, sizeof(buf));
+	buf[0] = (waddr & 0xFF00) >> 8;
+	buf[1] = (waddr & 0x00FF);
+	buf[2] = bdata;
+
+retry:
+	CDBG("[CAM] i2c_write_b addr = %d, val = %d\n", waddr, bdata);
+	rc = ov8830_i2c_txdata(saddr, buf, 3);
+
+	if (rc < 0) {
+		pr_err("[CAM]i2c_write_b failed, addr = 0x%x, val = 0x%x!\n",
+			 waddr, bdata);
+		pr_err(KERN_ERR "[CAM] starting read retry policy count:%d\n", count);
+		udelay(10);
+		count++;
+		if (count < 20) {
+			if (count > 10)
+				udelay(100);
+		} else
+			return rc;
+		goto retry;
+	}
+
+	return rc;
+}
+
+
+/*for LSC calibration*/
+static int ov8830_update_lsc_table(struct sensor_cfg_data *cdata)
+{
+	int i = 0;
+	pr_info("[CAM][LSC calibration]ov8830_update_lsc_table\n");
+	for (i = 0; i < 144; i++) {
+		ov8830_i2c_write_b(
+			ov8830_client->addr,
+			cdata->cfg.lsctable.lsc_table[i].reg_addr,
+			cdata->cfg.lsctable.lsc_table[i].reg_val);
+		pr_info("[CAM][LSC calibration]update_lsc_table: 0x%x, 0x%x\n",
+				cdata->cfg.lsctable.lsc_table[i].reg_addr,
+				cdata->cfg.lsctable.lsc_table[i].reg_val);
+	}
+	/*enable lsc on sensor*/
+	ov8830_i2c_write_b(ov8830_client->addr, 0x3300, 0xff);
+	/*mirror on*/
+	ov8830_i2c_write_b(ov8830_client->addr, 0x30f8, 0x45);
+	/*mirror on*/
+	ov8830_i2c_write_b(ov8830_client->addr, 0x3316, 0x03);
+	return 1;
+
+}
+
+/*20100330 vincent for LSC calibration*/
+static int ov8830_LSC_calibration_set_rawflag(struct sensor_cfg_data *cdata)
+{
+	global_mode = 1;
+	return 1;
+}
+
+#define MAX_FUSE_ID_INFO 17
+unsigned short fuse_id[MAX_FUSE_ID_INFO] = {0};
+
+static int ov8830_i2c_read_fuseid(struct sensor_cfg_data *cdata)
+{
+#if 0 /* move to ov8830_sensor_probe() */
+	unsigned short fuse_id[MAX_FUSE_ID_INFO];
+	int count = 0;
+
+	ov8830_i2c_write_b(ov8830_client->addr, 0x3d84, 0xc0);
+	ov8830_i2c_write_b(ov8830_client->addr, 0x3d81, 0x01);
+	ov8830_i2c_read(0x3d00, &fuse_id[0], 1);
+	ov8830_i2c_read(0x3d01, &fuse_id[1], 1);
+	ov8830_i2c_read(0x3d02, &fuse_id[2], 1);
+	ov8830_i2c_read(0x3d03, &fuse_id[3], 1);
+	ov8830_i2c_read(0x3d04, &fuse_id[4], 1);
+	ov8830_i2c_read(0x3d05, &fuse_id[5], 1);
+	ov8830_i2c_read(0x3d06, &fuse_id[6], 1);
+	ov8830_i2c_read(0x3d07, &fuse_id[7], 1);
+	ov8830_i2c_read(0x3d08, &fuse_id[8], 1);
+	ov8830_i2c_read(0x3d09, &fuse_id[9], 1);
+	ov8830_i2c_read(0x3d0A, &fuse_id[10], 1);
+	ov8830_i2c_read(0x3d0B, &fuse_id[11], 1);
+	ov8830_i2c_read(0x3d0C, &fuse_id[12], 1);
+	ov8830_i2c_read(0x3d0D, &fuse_id[13], 1);
+	ov8830_i2c_read(0x3d0E, &fuse_id[14], 1);
+	ov8830_i2c_read(0x3d0F, &fuse_id[15], 1);
+
+	for (count = 0; count < MAX_FUSE_ID_INFO; count++)
+		pr_info("[CAM]Ov8830 Get fuse: fuse_id[%d]: %x\n",
+		count, fuse_id[count]);
+#endif
+
+	pr_info("[CAM]ov8830_i2c_read_fuseid\n");
+
+	/* Wafer number */
+	cdata->cfg.fuse.fuse_id_word1 =
+		(uint32_t) (fuse_id[0]<<16) | (fuse_id[1]<<8) | (fuse_id[2]);
+	/* X and Y coordinate */
+	cdata->cfg.fuse.fuse_id_word2 = (uint32_t) (fuse_id[3]<<8) | (fuse_id[4]);
+	cdata->cfg.fuse.fuse_id_word3 = 0;
+	cdata->cfg.fuse.fuse_id_word4 = 0;
+
+	pr_info("[CAM] read_fuseid: fuse_id_word = %x %x %x %x\n", cdata->cfg.fuse.fuse_id_word1,
+		cdata->cfg.fuse.fuse_id_word2, cdata->cfg.fuse.fuse_id_word3, cdata->cfg.fuse.fuse_id_word4);
+	return 0;
+}
+
+static void ov8830_setup_af_tbl(void)
+{
+  uint32_t i;
+  uint16_t ov8830_nl_region_boundary1 = 3;
+  uint16_t ov8830_nl_region_boundary2 = 5;
+  uint16_t ov8830_nl_region_code_per_step1 = 40;
+  uint16_t ov8830_nl_region_code_per_step2 = 20;
+  uint16_t ov8830_l_region_code_per_step = 16;
+
+  ov8830_pos_tbl[0] = 0;
+
+  for (i = 1; i <= OV8830_TOTAL_STEPS_NEAR_TO_FAR; i++) {
+    if (i <= ov8830_nl_region_boundary1)
+      ov8830_pos_tbl[i] = ov8830_pos_tbl[i-1] +
+      ov8830_nl_region_code_per_step1;
+    else if (i <= ov8830_nl_region_boundary2)
+      ov8830_pos_tbl[i] = ov8830_pos_tbl[i-1] +
+      ov8830_nl_region_code_per_step2;
+    else
+      ov8830_pos_tbl[i] = ov8830_pos_tbl[i-1] +
+      ov8830_l_region_code_per_step;
+  }
+}
+
+static int32_t
+ov8830_go_to_position(uint32_t lens_pos, uint8_t mask)
+{
+	int32_t rc = 0;
+	unsigned char buf[2];
+	uint8_t vcm_code_msb, vcm_code_lsb;
+
+	vcm_code_msb = (lens_pos >> 8) & 0x3;
+	vcm_code_lsb = lens_pos & 0xFF;
+
+	buf[0] = OV8830_VCM_CODE_MSB;
+	buf[1] = vcm_code_msb;
+
+	rc = ov8830_i2c_txdata(OV8830_AF_I2C_ADDR >> 1, buf, 2);
+
+	if (rc < 0)
+		pr_err("[CAM]i2c_write failed, saddr = 0x%x addr = 0x%x, val =0x%x!\n", OV8830_AF_I2C_ADDR >> 1, buf[0], buf[1]);
+
+	buf[0] = OV8830_VCM_CODE_LSB;
+	buf[1] = vcm_code_lsb;
+
+	rc = ov8830_i2c_txdata(OV8830_AF_I2C_ADDR >> 1, buf, 2);
+
+	if (rc < 0)
+		pr_err("[CAM]i2c_write failed, saddr = 0x%x addr = 0x%x, val =0x%x!\n", OV8830_AF_I2C_ADDR >> 1, buf[0], buf[1]);
+
+	return rc;
+}
+
+static int32_t
+ov8830_move_focus(int direction, int32_t num_steps)
+{
+  uint16_t ov8830_sw_damping_time_wait = 1;
+  uint16_t ov8830_damping_threshold = 10;
+  uint8_t ov8830_mode_mask = 0x02;
+  int16_t step_direction;
+  int16_t curr_lens_pos;
+  int16_t curr_step_pos;
+  int16_t dest_lens_pos;
+  int16_t dest_step_pos;
+  int16_t target_dist;
+  int16_t small_step;
+  int16_t next_lens_pos;
+  int16_t time_wait_per_step;
+  int32_t rc = 0, time_wait;
+  int8_t ov8830_sw_damping_required = 0;
+  uint16_t ov8830_max_fps_val;
+
+  if (num_steps > OV8830_TOTAL_STEPS_NEAR_TO_FAR)
+      num_steps = OV8830_TOTAL_STEPS_NEAR_TO_FAR;
+  else if (num_steps == 0)
+      return -EINVAL;
+
+  if (direction == MOVE_NEAR)
+      step_direction = 1;
+  else if (direction == MOVE_FAR)
+      step_direction = -1;
+  else
+      return -EINVAL;
+
+  /* need to decide about default position and power supplied
+   * at start up and reset */
+  curr_lens_pos = ov8830_ctrl->curr_lens_pos;
+  curr_step_pos = ov8830_ctrl->curr_step_pos;
+
+  if (curr_lens_pos < ov8830_ctrl->init_curr_lens_pos)
+      curr_lens_pos = ov8830_ctrl->init_curr_lens_pos;
+
+  dest_step_pos = curr_step_pos + (step_direction * num_steps);
+
+  if (dest_step_pos < 0)
+      dest_step_pos = 0;
+  else if (dest_step_pos > OV8830_TOTAL_STEPS_NEAR_TO_FAR)
+      dest_step_pos = OV8830_TOTAL_STEPS_NEAR_TO_FAR;
+
+  if (dest_step_pos == ov8830_ctrl->curr_step_pos)
+      return rc;
+
+  dest_lens_pos = ov8830_pos_tbl[dest_step_pos];
+  target_dist = step_direction * (dest_lens_pos - curr_lens_pos);
+
+  ov8830_max_fps_val = OV8830_MAX_FPS;
+
+  /* HW damping */
+  if (step_direction < 0
+    && target_dist >= ov8830_pos_tbl[ov8830_damping_threshold]) {
+    ov8830_sw_damping_required = 1;
+    time_wait = 1000000
+      / ov8830_max_fps_val
+      - OV8830_SW_DAMPING_STEP * ov8830_sw_damping_time_wait * 1000;
+  } else
+    time_wait = 1000000 / ov8830_max_fps_val;
+
+  time_wait_per_step = (int16_t) (time_wait / target_dist);
+
+  if (time_wait_per_step >= 800)
+    /* ~800 */
+    ov8830_mode_mask = 0x5;
+  else if (time_wait_per_step >= 400)
+    /* ~400 */
+    ov8830_mode_mask = 0x4;
+  else if (time_wait_per_step >= 200)
+    /* 200~400 */
+    ov8830_mode_mask = 0x3;
+  else if (time_wait_per_step >= 100)
+    /* 100~200 */
+    ov8830_mode_mask = 0x2;
+  else if (time_wait_per_step >= 50)
+    /* 50~100 */
+    ov8830_mode_mask = 0x1;
+  else {
+    if (time_wait >= 17600)
+      ov8830_mode_mask = 0x0D;
+    else if (time_wait >= 8800)
+      ov8830_mode_mask = 0x0C;
+    else if (time_wait >= 4400)
+      ov8830_mode_mask = 0x0B;
+    else if (time_wait >= 2200)
+      ov8830_mode_mask = 0x0A;
+    else
+      ov8830_mode_mask = 0x09;
+  }
+
+  if (ov8830_sw_damping_required) {
+    small_step = (uint16_t) target_dist / OV8830_SW_DAMPING_STEP;
+    if ((target_dist % OV8830_SW_DAMPING_STEP) != 0)
+      small_step = small_step + 1;
+
+    for (next_lens_pos = curr_lens_pos + (step_direction*small_step);
+      (step_direction*next_lens_pos) <= (step_direction*dest_lens_pos);
+      next_lens_pos += (step_direction*small_step)) {
+      rc = ov8830_go_to_position(next_lens_pos, ov8830_mode_mask);
+      if (rc < 0) {
+      CDBG("[CAM] ov8830_go_to_position Failed in Move Focus!!!\n");
+      return rc;
+      }
+      curr_lens_pos = next_lens_pos;
+      mdelay(ov8830_sw_damping_time_wait);
+    }
+
+    if (curr_lens_pos != dest_lens_pos) {
+      rc = ov8830_go_to_position(dest_lens_pos, ov8830_mode_mask);
+      if (rc < 0) {
+      pr_err("[CAM]ov8830_go_to_position Failed in Move Focus!!!\n");
+      return rc;
+      }
+      mdelay(ov8830_sw_damping_time_wait);
+    }
+  } else {
+    rc = ov8830_go_to_position(dest_lens_pos, ov8830_mode_mask);
+    if (rc < 0) {
+      pr_err("[CAM]ov8830_go_to_position Failed in Move Focus!!!\n");
+      return rc;
+    }
+  }
+
+  ov8830_ctrl->curr_lens_pos = dest_lens_pos;
+  ov8830_ctrl->curr_step_pos = dest_step_pos;
+
+  return rc;
+}
+
+static int32_t
+ov8830_set_default_focus(void)
+{
+  int32_t rc = 0;
+  if (ov8830_ctrl->curr_step_pos != 0) {
+    rc = ov8830_move_focus(MOVE_FAR, ov8830_ctrl->curr_step_pos);
+    if (rc < 0) {
+      pr_err("[CAM]ov8830_set_default_focus Failed!!!\n");
+      return rc;
+    }
+  } else {
+    rc = ov8830_go_to_position(0, 0x02);
+    if (rc < 0) {
+      pr_err("[CAM]ov8830_go_to_position Failed!!!\n");
+      return rc;
+    }
+  }
+
+  ov8830_ctrl->curr_lens_pos = 0;
+  ov8830_ctrl->init_curr_lens_pos = 0;
+  ov8830_ctrl->curr_step_pos = 0;
+
+  return rc;
+}
+
+static void ov8830_get_pict_fps(uint16_t fps, uint16_t *pfps)
+{
+	/* input fps is preview fps in Q8 format */
+
+	uint32_t divider, d1, d2;
+
+	uint16_t snapshot_height, preview_height, preview_width, snapshot_width;
+
+	if (ov8830_ctrl->prev_res == QTR_SIZE) {
+		preview_width =
+			OV8830_QTR_SIZE_WIDTH  + OV8830_HRZ_QTR_BLK_PIXELS ;
+		preview_height =
+			OV8830_QTR_SIZE_HEIGHT + ov8830_ver_qtr_blk_lines_array[cam_mode_sel] ;
+	} else if (ov8830_ctrl->prev_res == VIDEO_SIZE) {
+		preview_width =
+			OV8830_VIDEO_SIZE_WIDTH  + OV8830_HRZ_VIDEO_BLK_PIXELS;
+		preview_height =
+			OV8830_VIDEO_SIZE_HEIGHT + OV8830_VER_VIDEO_BLK_LINES;
+    } else if (ov8830_ctrl->prev_res == FAST_VIDEO_SIZE) {
+    preview_width =
+      OV8830_VIDEO_SIZE_WIDTH_FAST	+ OV8830_HRZ_VIDEO_BLK_PIXELS_FAST;
+    preview_height =
+      OV8830_VIDEO_SIZE_HEIGHT_FAST + OV8830_VER_VIDEO_BLK_LINES_FAST;
+	} else {
+		/* full size resolution used for preview. */
+		preview_width =
+			OV8830_FULL_SIZE_WIDTH + OV8830_HRZ_FULL_BLK_PIXELS ;
+		preview_height =
+			OV8830_FULL_SIZE_HEIGHT + OV8830_VER_FULL_BLK_LINES ;
+	}
+
+	if (ov8830_ctrl->pict_res == QTR_SIZE) {
+		snapshot_width =
+			OV8830_QTR_SIZE_WIDTH + OV8830_HRZ_QTR_BLK_PIXELS ;
+		snapshot_height =
+			OV8830_QTR_SIZE_HEIGHT + ov8830_ver_qtr_blk_lines_array[cam_mode_sel] ;
+
+	} else {
+		snapshot_width =
+			OV8830_FULL_SIZE_WIDTH + OV8830_HRZ_FULL_BLK_PIXELS;
+		snapshot_height =
+			OV8830_FULL_SIZE_HEIGHT + OV8830_VER_FULL_BLK_LINES;
+	}
+
+	d1 = preview_height * 0x00000400 / snapshot_height;
+	d2 = preview_width * 0x00000400 / snapshot_width;
+
+	divider = (uint32_t) (d1 * d2) / 0x00000400;
+	*pfps = (uint16_t)(fps * divider / 0x00000400);
+
+} /* endof ov8830_get_pict_fps */
+
+static uint16_t ov8830_get_prev_lines_pf(void)
+{
+  if (ov8830_ctrl->prev_res == QTR_SIZE) {
+    return (OV8830_QTR_SIZE_HEIGHT + ov8830_ver_qtr_blk_lines_array[cam_mode_sel]);
+  } else if (ov8830_ctrl->prev_res == VIDEO_SIZE) {
+    return (OV8830_VIDEO_SIZE_HEIGHT + OV8830_VER_VIDEO_BLK_LINES);
+  } else if (ov8830_ctrl->prev_res == FAST_VIDEO_SIZE) {
+    return (OV8830_VIDEO_SIZE_HEIGHT_FAST + OV8830_VER_VIDEO_BLK_LINES_FAST);
+  } else  {
+    return (OV8830_FULL_SIZE_HEIGHT + OV8830_VER_FULL_BLK_LINES);
+  }
+
+}
+
+static uint16_t ov8830_get_prev_pixels_pl(void)
+{
+    if (ov8830_ctrl->prev_res == QTR_SIZE) {
+      return (OV8830_QTR_SIZE_WIDTH + OV8830_HRZ_QTR_BLK_PIXELS);
+    } else if (ov8830_ctrl->prev_res == VIDEO_SIZE) {
+      return (OV8830_VIDEO_SIZE_WIDTH + OV8830_HRZ_VIDEO_BLK_PIXELS);
+	  } else if (ov8830_ctrl->prev_res == FAST_VIDEO_SIZE) {
+      return (OV8830_VIDEO_SIZE_WIDTH_FAST + OV8830_HRZ_VIDEO_BLK_PIXELS_FAST);
+	  } else {
+      return (OV8830_FULL_SIZE_WIDTH + OV8830_HRZ_FULL_BLK_PIXELS);
+  }
+}
+
+static uint16_t ov8830_get_pict_lines_pf(void)
+{
+	if (ov8830_ctrl->pict_res == QTR_SIZE) {
+		return (OV8830_QTR_SIZE_HEIGHT + ov8830_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (OV8830_FULL_SIZE_HEIGHT + OV8830_VER_FULL_BLK_LINES);
+	}
+}
+
+static uint16_t ov8830_get_pict_pixels_pl(void)
+{
+	if (ov8830_ctrl->pict_res == QTR_SIZE) {
+		return (OV8830_QTR_SIZE_WIDTH + OV8830_HRZ_QTR_BLK_PIXELS);
+	} else  {
+		return (OV8830_FULL_SIZE_WIDTH + OV8830_HRZ_FULL_BLK_PIXELS);
+	}
+}
+
+static uint32_t ov8830_get_pict_max_exp_lc(void)
+{
+	if (ov8830_ctrl->pict_res == QTR_SIZE) {
+		return (OV8830_QTR_SIZE_HEIGHT + ov8830_ver_qtr_blk_lines_array[cam_mode_sel]);
+	} else  {
+		return (OV8830_FULL_SIZE_HEIGHT + OV8830_VER_FULL_BLK_LINES);
+	}
+}
+
+
+static int32_t ov8830_write_exp_gain
+			(uint16_t mul, uint16_t gain, uint32_t line)
+{
+	uint32_t aec_msb_24; /*easter for frame rate=10fps 20110526*/
+	uint16_t aec_msb;
+	uint16_t aec_lsb;
+	int32_t rc = 0;
+	uint32_t total_lines_per_frame;
+	uint32_t total_pixels_per_line;
+	uint16_t offset = OV8830_OFFSET;
+	/*uint32_t line_length_ratio = 1 * Q8;*/
+	/*uint8_t ov8830_offset = 2; */
+	/*uint32_t extra_line_length = 0;*/
+	/*uint16_t extra_line_msb = 0;*/
+	/*uint16_t extra_line_lsb = 0;*/
+	uint32_t phy_line = 0;
+	uint32_t phy_line_2 = 0;
+	uint8_t phy_mul = MUL_GAIN_INIT_VALUE;
+	uint16_t phy_gain = 0;
+	/*uint32_t phy_extra_line_length = 0;*/
+	uint16_t lf_msb;
+	uint16_t lf_lsb;
+	uint32_t fps_divider;
+
+	CDBG("[CAM] %s start, mul = %d gain = %d line = %d\n", __func__,
+		mul, gain, line);
+
+	if (ov8830_ctrl->curr_res == QTR_SIZE) {
+		total_lines_per_frame =
+			(OV8830_QTR_SIZE_HEIGHT + ov8830_ver_qtr_blk_lines_array[cam_mode_sel]);
+		total_pixels_per_line =
+			OV8830_QTR_SIZE_WIDTH + OV8830_HRZ_QTR_BLK_PIXELS;
+	} else if (ov8830_ctrl->curr_res == VIDEO_SIZE) {
+		total_lines_per_frame =
+			OV8830_VIDEO_SIZE_HEIGHT + OV8830_VER_VIDEO_BLK_LINES;
+		total_pixels_per_line =
+			OV8830_VIDEO_SIZE_WIDTH + OV8830_HRZ_VIDEO_BLK_PIXELS;
+	} else if (ov8830_ctrl->curr_res == FAST_VIDEO_SIZE) {
+		total_lines_per_frame =
+			OV8830_VIDEO_SIZE_HEIGHT_FAST + OV8830_VER_VIDEO_BLK_LINES_FAST;
+		total_pixels_per_line =
+			OV8830_VIDEO_SIZE_WIDTH_FAST + OV8830_HRZ_VIDEO_BLK_PIXELS_FAST;
+	} else {
+		total_lines_per_frame =
+			(OV8830_FULL_SIZE_HEIGHT + OV8830_VER_FULL_BLK_LINES);
+		total_pixels_per_line =
+			OV8830_FULL_SIZE_WIDTH + OV8830_HRZ_FULL_BLK_PIXELS;
+	}
+
+	phy_line = line;
+	phy_mul = mul;
+	phy_gain = gain;
+	/*phy_extra_line_length = extra_line_length;*/
+
+	if (ov8830_ctrl->sensormode == SENSOR_PREVIEW_MODE) {
+		fps_divider = ov8830_ctrl->fps_divider;
+		ov8830_ctrl->my_reg_gain = gain;
+		ov8830_ctrl->my_reg_dig_gain = mul;
+		ov8830_ctrl->my_reg_line_count = (uint16_t)line;
+	} else
+		fps_divider = ov8830_ctrl->pict_fps_divider;
+
+	/*extra_line_msb = (uint16_t)(phy_extra_line_length & 0xFF00) >> 8;*/
+	/*extra_line_lsb = (uint16_t)(phy_extra_line_length & 0x00FF);*/
+
+	phy_line_2 = phy_line << 4;  /*1995*/
+	aec_msb_24 = (uint32_t)(phy_line_2 & 0xFF0000) >> 16;/*easter for frame rate=10fps 20110526*/
+	aec_msb = (uint16_t)(phy_line_2 & 0xFF00) >> 8;
+	aec_lsb = (uint16_t)(phy_line_2 & 0x00FF);
+
+
+	rc = ov8830_i2c_write_b(ov8830_client->addr, OV8830_AEC_MSB_24, (uint8_t)aec_msb_24);
+	if (rc < 0)
+		return rc;/*easter for frame rate=10fps 20110526*/
+
+	rc = ov8830_i2c_write_b(ov8830_client->addr, OV8830_AEC_MSB, (uint8_t)aec_msb);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8830_i2c_write_b(ov8830_client->addr, OV8830_AEC_LSB, (uint8_t)aec_lsb);
+	if (rc < 0)
+		return rc;
+
+  rc = ov8830_i2c_write_b(ov8830_client->addr, OV8830_GAIN_LSB, (uint8_t)phy_gain);
+	if (rc < 0)
+		return rc;
+
+	if (phy_line * 0x400 <= (total_lines_per_frame - offset) * fps_divider) {
+		total_lines_per_frame = (total_lines_per_frame * fps_divider) / 0x400;
+		lf_msb = (uint16_t)((total_lines_per_frame) & 0xFF00) >> 8;
+		lf_lsb = (uint16_t)((total_lines_per_frame) & 0x00FF);
+	} else {
+		lf_msb = (uint16_t)((total_lines_per_frame + (phy_line - (total_lines_per_frame - offset))) & 0xFF00) >> 8;
+		lf_lsb = (uint16_t)((total_lines_per_frame + (phy_line - (total_lines_per_frame - offset))) & 0x00FF);
+	}
+
+	rc = ov8830_i2c_write_b(ov8830_client->addr, REG_VSYNC_WIDTH_MSB, (uint8_t)lf_msb);
+	if (rc < 0)
+		return rc;
+
+	rc = ov8830_i2c_write_b(ov8830_client->addr, REG_VSYNC_WIDTH_LSB, (uint8_t)lf_lsb);
+	if (rc < 0)
+		return rc;
+
+	/*stored_line_length_ratio = line_length_ratio;*/
+	return rc;
+
+} /* endof ov8830_write_exp_gain*/
+
+/* ### this function is not called for userspace ### */
+static int32_t ov8830_set_pict_exp_gain
+			(uint16_t mul, uint16_t gain, uint32_t line)
+{
+	int32_t rc = 0;
+	rc = ov8830_write_exp_gain(mul, gain, line);
+	return rc;
+} /* endof ov8830_set_pict_exp_gain*/
+
+static int32_t ov8830_set_fps(struct fps_cfg *fps)
+{
+	int32_t rc = 0;
+	uint32_t delay;
+	uint32_t min_coarse = OV8830_MIN_COARSE_INTEGRATION_TIME;
+	uint32_t pre_fps_divider = ov8830_ctrl->fps_divider;
+	uint32_t pre_fps = ov8830_ctrl->fps;
+	ov8830_ctrl->fps_divider = fps->fps_div;
+	ov8830_ctrl->pict_fps_divider = fps->pict_fps_div;
+	ov8830_ctrl->fps = fps->f_mult;
+
+	if (ov8830_ctrl->sensormode == SENSOR_PREVIEW_MODE &&
+		(ov8830_ctrl->my_reg_gain != 0 || ov8830_ctrl->my_reg_line_count != 0) &&
+		(pre_fps != ov8830_ctrl->fps || pre_fps_divider != ov8830_ctrl->fps_divider)) {
+		min_coarse = (min_coarse * ov8830_ctrl->fps_divider + 0x400 - 1) / 0x400;
+		if (ov8830_ctrl->my_reg_line_count < min_coarse)
+			ov8830_ctrl->my_reg_line_count = min_coarse;
+		rc =
+			ov8830_write_exp_gain(ov8830_ctrl->my_reg_dig_gain, ov8830_ctrl->my_reg_gain,
+				ov8830_ctrl->my_reg_line_count);
+
+		delay = (1000 * Q8 / pre_fps) + 1;
+		mdelay(delay);
+	}
+
+	return rc;
+}
+
+/* remove test code */
+#if 0
+static int32_t ov8830_test(enum ov8830_test_mode_t mo)
+{
+	int32_t rc = 0;
+	if (mo == TEST_OFF) {
+		return rc;
+	}
+
+	/* Activate  the Color bar test pattern */
+	if (mo == TEST_1) {
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+			OV8830_COLOR_BAR_ENABLE_REG, 0xa0);
+		if (rc < 0) {
+			return rc;
+		}
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+			0x3085, 0x20);
+		if (rc < 0) {
+			return rc;
+		}
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+			0x306c, 0x00);
+		if (rc < 0) {
+			return rc;
+		}
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+			OV8830_COLOR_BAR_PATTERN_SEL_REG, 0x02);
+		if (rc < 0) {
+			return rc;
+		}
+	}
+
+	return rc;
+
+}
+#endif
+
+
+uint32_t Crc32CheckSumByte(uint8_t *pData, uint32_t uiLen, uint32_t preValue)
+{
+	const uint32_t crc32table[256] = {
+		/* 0x00 */ 0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
+		/* 0x04 */ 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
+		/* 0x08 */ 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
+		/* 0x0C */ 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
+		/* 0x10 */ 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
+		/* 0x14 */ 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
+		/* 0x18 */ 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+		/* 0x1C */ 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
+		/* 0x20 */ 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
+		/* 0x24 */ 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
+		/* 0x28 */ 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
+		/* 0x2C */ 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
+		/* 0x30 */ 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
+		/* 0x34 */ 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+		/* 0x38 */ 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
+		/* 0x3C */ 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
+		/* 0x40 */ 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
+		/* 0x44 */ 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
+		/* 0x48 */ 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
+		/* 0x4C */ 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
+		/* 0x50 */ 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+		/* 0x54 */ 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
+		/* 0x58 */ 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
+		/* 0x5C */ 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
+		/* 0x60 */ 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
+		/* 0x64 */ 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
+		/* 0x68 */ 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
+		/* 0x6C */ 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+		/* 0x70 */ 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
+		/* 0x74 */ 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
+		/* 0x78 */ 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
+		/* 0x7C */ 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
+		/* 0x80 */ 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
+		/* 0x84 */ 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
+		/* 0x88 */ 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+		/* 0x8C */ 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
+		/* 0x90 */ 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
+		/* 0x94 */ 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
+		/* 0x98 */ 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
+		/* 0x9C */ 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
+		/* 0xA0 */ 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
+		/* 0xA4 */ 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+		/* 0xA8 */ 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
+		/* 0xAC */ 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
+		/* 0xB0 */ 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
+		/* 0xB4 */ 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
+		/* 0xB8 */ 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
+		/* 0xBC */ 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
+		/* 0xC0 */ 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+		/* 0xC4 */ 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
+		/* 0xC8 */ 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
+		/* 0xCC */ 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
+		/* 0xD0 */ 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
+		/* 0xD4 */ 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
+		/* 0xD8 */ 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
+		/* 0xDC */ 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+		/* 0xE0 */ 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
+		/* 0xE4 */ 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
+		/* 0xE8 */ 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
+		/* 0xEC */ 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
+		/* 0xF0 */ 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
+		/* 0xF4 */ 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
+		/* 0xF8 */ 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+		/* 0xFC */ 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,};
+	uint32_t i, CheckSum, cvalue;
+
+	CheckSum = preValue;
+	for (i = 0; i < uiLen; i++) {
+		cvalue = *pData;
+		CheckSum =
+			(CheckSum>>8) ^
+			crc32table[(CheckSum & 0xFF) ^
+			(cvalue & 0xFF)];
+		pData++;
+	}
+	return CheckSum;
+}
+
+#if 0
+static int32_t HTC_update_ov8830_lsc_registers(void)
+{
+	int i;
+	struct awb_lsc_struct_type *awb_lsc_data_ptr;
+	awb_lsc_data_ptr = (struct awb_lsc_struct_type *)get_cam_awb_cal();
+
+	for (i = 0; i < 8; i++) {
+		pr_info(KERN_INFO"[CAM][LSC calibration]  read AWB table 0x%x\n",
+			awb_lsc_data_ptr->caBuff[i]);
+	}
+
+	for (i = 0; i < LSC_table_length; i++) {
+		pr_info("[CAM][LSC calibration]  read LSC table 0x%x, 0x%x\n",
+			awb_lsc_data_ptr->LSC_table[i].reg_addr,
+			awb_lsc_data_ptr->LSC_table[i].reg_val);
+	}
+
+       if (awb_lsc_data_ptr->LSC_table_CRC ==
+		Crc32CheckSumByte(
+			(uint8_t *) awb_lsc_data_ptr->LSC_table,
+			150 * sizeof(struct reg_addr_val_pair_struct), 0) &&
+		awb_lsc_data_ptr->LSC_table_CRC != 0) {
+
+		pr_info("[CAM][LSC calibration]checksum pass,use calibrated LSC\n");
+
+		for (i = 0; i < LSC_table_length; i++) {
+			ov8830_i2c_write_b(ov8830_client->addr,
+				awb_lsc_data_ptr->LSC_table[i].reg_addr,
+				awb_lsc_data_ptr->LSC_table[i].reg_val);
+		}
+		/*enable lsc on sensor*/
+		ov8830_i2c_write_b(ov8830_client->addr, 0x3300, 0xff);
+		/*move to the last*/
+		ov8830_i2c_write_b(ov8830_client->addr,
+			OV8830_REG_MODE_SELECT, OV8830_MODE_SELECT_STREAM);
+
+	} else {/*use default LSC table*/
+	      pr_info("[CAM][LSC calibration]checksum fail\n");
+	      return false;
+	}
+	return true;
+}
+#endif
+
+static int32_t ov8830_i2c_write_table(
+	struct ov8830_i2c_reg_conf *reg_cfg_tbl, int num)
+{
+	int i;
+	int32_t rc = -EIO;
+
+	for (i = 0; i < num; i++) {
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+			reg_cfg_tbl->waddr, reg_cfg_tbl->bdata);
+		if (rc < 0)
+			break;
+		reg_cfg_tbl++;
+	}
+
+	return rc;
+}
+
+
+static int32_t initialize_ov8830_registers(void)
+{
+	int32_t rc = 0;
+
+	/* Configure sensor for Preview mode and Snapshot mode */
+   rc = ov8830_i2c_write_table(ov8830_regs.full_mipi, ov8830_regs.full_mipi_size);
+
+	return rc;
+} /* end of initialize_ov8830_ov8m0vc_registers. */
+
+static int32_t ov8830_setting(int rt)
+{
+	int32_t rc = 0;
+	/*int32_t i, array_length;*/
+	static int16_t did_snapshot;
+	/*uint16_t ori_reg_mul_gain;*/
+	/*uint8_t ori_reg_mul_gain_8bit;*/
+	struct msm_camera_csi_params ov8830_csi_params;
+	struct msm_camera_sensor_info *sinfo = ov8830_pdev->dev.platform_data;
+
+	write_cnt = 0;
+
+	if (sinfo->csi_if) {
+		if (ov8830_ctrl->reg_update == REG_INIT) {
+			/* config mipi csi controller */
+			ov8830_csi_params.data_format = CSI_10BIT;
+			ov8830_csi_params.lane_cnt = 2;
+			ov8830_csi_params.lane_assign = 0xe4;
+			ov8830_csi_params.dpcm_scheme = 0;
+			ov8830_csi_params.settle_cnt = 20;
+			ov8830_csi_params.mipi_driving_strength = 0;
+			ov8830_csi_params.hs_impedence = 0x0F;
+			rc = msm_camio_csi_config(&ov8830_csi_params);
+
+			ov8830_ctrl->reg_update = REG_PERIODIC;
+			pr_info("[CAM]after set csi config\n");
+		}
+	}
+
+	pr_info("[CAM]ov8830_setting,rt=%d\n", rt);
+
+	switch (rt) {
+
+	case QTR_SIZE:
+	case VIDEO_SIZE:
+	case FAST_VIDEO_SIZE:
+
+    rc = ov8830_i2c_write_table(ov8830_regs.common_mipi, ov8830_regs.common_mipi_size);
+
+    if (rc < 0)
+      return rc;
+
+		if (rt == VIDEO_SIZE) {
+			pr_info("[CAM]ov8830_setting(VIDEO_SIZE)\n");
+			rc = ov8830_i2c_write_table(ov8830_regs.video_mipi, ov8830_regs.video_mipi_size);
+		} else if (rt == FAST_VIDEO_SIZE) {
+			pr_info("[CAM]ov8830_setting(FAST_VIDEO_SIZE)\n");
+			rc = ov8830_i2c_write_table(ov8830_regs.fast_video_mipi, ov8830_regs.fast_video_mipi_size);
+		} else {
+			pr_info("[CAM]ov8830_setting(QTR_SIZE)\n");
+			rc = ov8830_i2c_write_table(ov8830_regs.qtr_mipi, ov8830_regs.qtr_mipi_size);
+		}
+
+    if (rc < 0) {
+			pr_info("[CAM]fail,QTR_SIZE\n");
+			return rc;
+    }
+
+		if (rt == VIDEO_SIZE) {
+			ov8830_ctrl->curr_res = VIDEO_SIZE;
+		} else if (rt == FAST_VIDEO_SIZE) {
+			ov8830_ctrl->curr_res = FAST_VIDEO_SIZE;
+		} else {
+			ov8830_ctrl->curr_res = QTR_SIZE;
+		}
+
+		if (ov8830_ctrl->sensormode == SENSOR_PREVIEW_MODE &&
+				(ov8830_ctrl->my_reg_gain != 0 || ov8830_ctrl->my_reg_dig_gain != 0 ||
+				ov8830_ctrl->my_reg_line_count != 0))
+			ov8830_write_exp_gain(ov8830_ctrl->my_reg_dig_gain,
+				ov8830_ctrl->my_reg_gain, ov8830_ctrl->my_reg_line_count);
+
+		/*streaming on*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+		0x0100, 0x01);
+		if (rc < 0)
+			return rc;
+
+		if (sinfo->mirror_mode) {
+			if (rt == QTR_SIZE || rt == FAST_VIDEO_SIZE) {
+				rc = ov8830_i2c_write_b(ov8830_client->addr,
+				OV8830_REG_MODE_FLIP, OV8830_REG_FLIP+1);  /*+1 for binning*/
+				if (rc < 0)
+					return rc;
+
+				rc = ov8830_i2c_write_b(ov8830_client->addr,
+				OV8830_REG_MODE_MIRROR, OV8830_REG_MIRROR+1); /*+1 for binning*/
+				if (rc < 0)
+					return rc;
+			} else {
+				rc = ov8830_i2c_write_b(ov8830_client->addr,
+				OV8830_REG_MODE_FLIP, OV8830_REG_FLIP);
+				if (rc < 0)
+					return rc;
+
+				rc = ov8830_i2c_write_b(ov8830_client->addr,
+				OV8830_REG_MODE_MIRROR, OV8830_REG_MIRROR);
+				if (rc < 0)
+					return rc;
+			}
+		}
+
+		did_snapshot = 0;
+
+		break;
+
+	case FULL_SIZE:
+
+    pr_info("[CAM]ov8830_setting FULL_SIZE\n");
+
+    rc = ov8830_i2c_write_table(ov8830_regs.common_mipi, ov8830_regs.common_mipi_size);
+
+    if (rc < 0)
+      return rc;
+
+    rc = ov8830_i2c_write_table(ov8830_regs.full_mipi, ov8830_regs.full_mipi_size);
+    if (rc < 0) {
+			pr_info("[CAM]fail\n");
+			return rc;
+    }
+
+		ov8830_ctrl->curr_res = FULL_SIZE;
+
+		if (ov8830_ctrl->sensormode == SENSOR_PREVIEW_MODE &&
+				(ov8830_ctrl->my_reg_gain != 0 || ov8830_ctrl->my_reg_dig_gain != 0 ||
+				ov8830_ctrl->my_reg_line_count != 0))
+			ov8830_write_exp_gain(ov8830_ctrl->my_reg_dig_gain,
+				ov8830_ctrl->my_reg_gain, ov8830_ctrl->my_reg_line_count);
+
+		/*streaming on*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr,
+		0x0100, 0x01);
+		if (rc < 0)
+			return rc;
+
+		if (sinfo->mirror_mode) {
+			rc = ov8830_i2c_write_b(ov8830_client->addr,
+			OV8830_REG_MODE_FLIP, OV8830_REG_FLIP);
+			if (rc < 0)
+				return rc;
+
+			rc = ov8830_i2c_write_b(ov8830_client->addr,
+			OV8830_REG_MODE_MIRROR, OV8830_REG_MIRROR);
+			if (rc < 0)
+				return rc;
+		}
+
+		did_snapshot = 1;
+		break;
+
+	default:
+		rc = -EFAULT;
+		return rc;
+	}
+
+	/*disablt LSC for calibration*/
+	pr_info("[CAM][LSC calibration] global_mode=%d!!!!\n", global_mode);
+	/*take raw picture for LSC calibration*/
+	if (global_mode) {
+		/*disable sensor LSC*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr, 0x3300, 0xef);
+		/*mirror off*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr, 0x30f8, 0x00);
+		/*mirror off*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr, 0x3316, 0x02);
+		pr_info("[CAM][LSC calibration]turn off LSC!Mirror On\n");
+
+		/*fix gain & linecount*/
+		/*Gain=0x9,exp=008d*/
+		/*so luma taget = 100 to mfg light source*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr, 0x3000, 0x9);
+		/*AEC_MSB*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr, 0x3002, 0x00);
+		/*AEC_LSB*/
+		rc = ov8830_i2c_write_b(ov8830_client->addr, 0x3003, 0x8d);
+		pr_info("[CAM][LSC calibration]fix gain & linecount\n");
+		global_mode = 0;
+	}
+
+/* remove test code
+	rc = ov8830_test(ov8830_ctrl->set_test);
+	if (rc < 0)
+		return rc;
+*/
+
+	return rc;
+} /*endof  ov8830_setting*/
+
+static int32_t ov8830_video_config(int mode)
+{
+    int32_t rc = 0;
+    static int pre_sel = 0;
+    int cur_sel = (cam_mode_sel > 1)?1:0;
+    enum ov8830_resolution_t curr_res = ov8830_ctrl->curr_res;
+    uint32_t curr_mode = ov8830_ctrl->sensormode;
+
+    ov8830_ctrl->sensormode = mode;
+
+    pr_info("[CAM]%s cam_mode_sel %d cur_sel %d \n", __func__, cam_mode_sel, cur_sel);
+
+    preview_frame_count = 0;
+
+    if (ov8830_ctrl->curr_res != ov8830_ctrl->prev_res
+      || pre_sel != cur_sel
+      )  {
+				rc = ov8830_setting(ov8830_ctrl->prev_res);
+				if (rc < 0) {
+					ov8830_ctrl->curr_res = curr_res;
+					ov8830_ctrl->sensormode = curr_mode;
+					return rc;
+				}
+    } else {
+				ov8830_ctrl->curr_res = ov8830_ctrl->prev_res;
+    }
+
+    pre_sel = cur_sel;
+
+    return rc;
+
+} /*end of ov354_video_config*/
+
+static int32_t ov8830_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	enum ov8830_resolution_t curr_res = ov8830_ctrl->curr_res;
+	uint32_t curr_mode = ov8830_ctrl->sensormode;
+
+	ov8830_ctrl->sensormode = mode;
+
+	if (ov8830_ctrl->curr_res != ov8830_ctrl->pict_res) {
+		rc = ov8830_setting(ov8830_ctrl->pict_res);
+		if (rc < 0) {
+			ov8830_ctrl->curr_res = curr_res;
+			ov8830_ctrl->sensormode = curr_mode;
+			return rc;
+		}
+	} else {
+		ov8830_ctrl->curr_res = ov8830_ctrl->pict_res;
+	}
+
+	return rc;
+
+} /*end of ov8830_snapshot_config*/
+
+static int32_t ov8830_raw_snapshot_config(int mode)
+{
+	int32_t rc = 0;
+	enum ov8830_resolution_t curr_res = ov8830_ctrl->curr_res;
+	uint32_t curr_mode = ov8830_ctrl->sensormode;
+
+	ov8830_ctrl->sensormode = mode;
+	if (ov8830_ctrl->curr_res != ov8830_ctrl->pict_res) {
+		rc = ov8830_setting(ov8830_ctrl->pict_res);
+		if (rc < 0) {
+			ov8830_ctrl->curr_res = curr_res;
+			ov8830_ctrl->sensormode = curr_mode;
+			return rc;
+		}
+	} else {
+		ov8830_ctrl->curr_res = ov8830_ctrl->pict_res;
+	} /* Update sensor resolution */
+
+	return rc;
+
+} /*end of ov8830_raw_snapshot_config*/
+
+static int32_t ov8830_set_sensor_mode(int mode,
+	int res)
+{
+	int32_t rc = 0;
+	struct msm_camera_sensor_info *sinfo = ov8830_pdev->dev.platform_data;
+
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		ov8830_ctrl->prev_res = res; /* VIDEO_SIZE, FAST_VIDEO_SIZE, FULL_SIZE, QTR_SIZE */
+		rc = ov8830_video_config(mode);
+		break;
+
+	case SENSOR_SNAPSHOT_MODE:
+		pr_info("[CAM]KPI PA: start sensor snapshot config: %d\n", __LINE__);
+		sinfo->kpi_sensor_start = ktime_to_ns(ktime_get());
+		ov8830_ctrl->pict_res = res;
+		rc = ov8830_snapshot_config(mode);
+		break;
+
+	case SENSOR_RAW_SNAPSHOT_MODE:
+		/*global_mode = 1; //20100330 vincent lsc calibration*/
+		pr_info("[CAM]KPI PA: start sensor snapshot config: %d\n", __LINE__);
+		sinfo->kpi_sensor_start = ktime_to_ns(ktime_get());
+		ov8830_ctrl->pict_res = res;
+		rc = ov8830_raw_snapshot_config(mode);
+		break;
+
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+static int32_t ov8830_power_down(void)
+{
+	return 0;
+}
+
+static int ov8830_probe_read_id(const struct msm_camera_sensor_info *data)
+{
+	int32_t rc = 0;
+	uint16_t  chipidh = 0; /*, chipidl;*/
+	uint16_t  def_chipid = 0;
+	msleep(20);
+	pr_info("[CAM]%s, ov8830_probe_init_sensor 1\n", __func__);
+	/* 3. Read sensor Model ID: */
+	if (ov8830_i2c_read(OV8830_PIDH_REG, &chipidh, 2) < 0) {
+		rc = -1;
+		pr_err("[CAM]read sensor id fail\n");
+	}
+
+	pr_info("[CAM]ov8830 model_id + ver = 0x%x\n", chipidh);
+
+	/* 4. Compare sensor ID to OV8830 ID: */
+	def_chipid = (((OV8830_PID << 8) & 0xFF00) + (OV8830_VER & 0x00FF));
+	pr_info("[CAM]%s, Expected id=0x%x\n", __func__, def_chipid);
+
+	if (chipidh < def_chipid) {
+		rc = -ENODEV;
+		pr_err("[CAM]read sensor id incorrect\n");
+	}
+
+	pr_info("[CAM]%s, vreg_get vreg_af_actuator\n", __func__);
+	/*vreg_af_actuator = vreg_get(0, "gp5");*/
+	if (IS_ERR(vreg_af_actuator))
+		return PTR_ERR(vreg_af_actuator);
+
+#ifdef CONFIG_ARCH_QSD8X50
+	data->camera_set_source(MAIN_SOURCE);
+#endif
+	pr_info("[CAM]ov8830_probe_init_sensor finishes\n");
+	return rc;
+}
+
+#ifndef CONFIG_ARCH_QSD8X50
+static int ov8830_vreg_enable(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+	int rc;
+	pr_info("[CAM]%s camera vreg on\n", __func__);
+
+	if (sdata->camera_power_on == NULL) {
+		pr_err("[CAM]sensor platform_data didnt register\n");
+		return -EIO;
+	}
+	rc = sdata->camera_power_on();
+	return rc;
+}
+#endif
+
+static int ov8830_sensor_open_init(struct msm_camera_sensor_info *data)
+{
+
+	int i;
+	int32_t  rc = 0;
+	/*stella0122*/
+	uint16_t ov8830_nl_region_boundary = 5; /*3;*/
+	uint16_t ov8830_nl_region_code_per_step = 35; /*101;*/
+	uint16_t ov8830_l_region_code_per_step = 20; /*18;*/
+	int timeout;
+	int count = 0;
+	pr_info("[CAM]Calling ov8830_sensor_open_init\n");
+	down(&ov8830_sem);
+
+	if (data == NULL) {
+		pr_info("[CAM]data is a NULL pointer\n");
+		return -EINVAL;
+	}
+	/*check whether resume done*/
+	timeout = wait_event_interruptible_timeout(
+		ov8830_event.event_wait,
+		ov8830_event.waked_up,
+		30*HZ);
+	pr_info("[CAM]wait event : %d timeout:%d\n", ov8830_event.waked_up, timeout);
+	if (timeout == 0) {
+		up(&ov8830_sem);
+		return rc;
+	}
+	msm_camio_probe_on(ov8830_pdev);
+	ov8830_ctrl = kzalloc(sizeof(struct ov8830_ctrl), GFP_KERNEL);
+	if (!ov8830_ctrl) {
+		pr_err("[CAM]ov8830_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+	ov8830_ctrl->curr_lens_pos = -1;
+	ov8830_ctrl->fps_divider = 1 * 0x00000400;
+	ov8830_ctrl->pict_fps_divider = 1 * 0x00000400;
+	ov8830_ctrl->set_test = TEST_OFF;
+	ov8830_ctrl->prev_res = QTR_SIZE;
+	ov8830_ctrl->pict_res = FULL_SIZE;
+	ov8830_ctrl->curr_res = INVALID_SIZE;
+	ov8830_ctrl->my_reg_gain = 0;
+	ov8830_ctrl->my_reg_dig_gain = 0;
+	ov8830_ctrl->my_reg_line_count = 0;
+	if (data)
+		ov8830_ctrl->sensordata = data;
+
+	pr_info("[CAM]%s  add open retry policy !!!\n", __func__);
+retry:
+	rc = ov8830_vreg_enable(ov8830_pdev);
+	if (rc < 0) {
+		pr_err("[CAM]fail,__ov8830_probe rc < 0\n");
+	}
+
+	/*PWD and RST config*/
+	pr_info("[CAM]%s, GPIO(%d) sensor_pwd 0\n", __func__, data->sensor_pwd);
+	if (data->sensor_pwd >= 0) {
+		rc = gpio_request(data->sensor_pwd, "ov8830");
+		if (!rc)
+			gpio_direction_output(data->sensor_pwd, 0);
+		else
+			pr_err("[CAM]GPIO (%d) request faile\n", data->sensor_pwd);
+		gpio_free(data->sensor_pwd);
+	} else {
+      if (data->camera_pm8058_power != NULL) {
+		if (data->camera_pm8058_power(0) < 0)
+		  pr_err("[CAM]camera_pm8058_power(0): request failed\n");
+	  }
+	}
+	msleep(5);
+
+	if (data->camera_clk_switch != NULL)
+		data->camera_clk_switch();
+	mdelay(5);
+
+	/*power down setup*/
+	if (data->sensor_pwd >= 0) {
+		rc = gpio_request(data->sensor_pwd, "ov8830");
+		if (!rc)
+			gpio_direction_output(data->sensor_pwd, 1);
+		else
+			pr_err("[CAM]GPIO (%d) request faile\n", data->sensor_pwd);
+		gpio_free(data->sensor_pwd);
+	} else {
+		if (data->camera_pm8058_power != NULL) {
+			if (data->camera_pm8058_power(1) < 0)
+				goto init_fail;
+		}
+	}
+	mdelay(5);
+
+	data->pdata->camera_gpio_on();
+
+	/*set MCLK*/
+	pr_info("[CAM]%s, msm_camio_clk_rate_set %d\n",
+		__func__, OV8830_DEFAULT_CLOCK_RATE);
+
+       msm_camio_clk_rate_set(OV8830_DEFAULT_CLOCK_RATE);
+
+	msleep(10);
+
+	if (data->vcm_pwd) {
+		rc = gpio_request(data->vcm_pwd, "ov8830");
+		if (!rc) {
+			gpio_direction_output(data->vcm_pwd, 1);
+		} else {
+			pr_err("[CAM]GPIO (%d) request failed\n", data->vcm_pwd);
+			goto init_fail;
+		}
+		gpio_free(data->vcm_pwd);
+	}
+
+	/*read sensor id*/
+	rc = ov8830_probe_read_id(data);
+	if (rc < 0) {
+		pr_err("[CAM]starting open retry policy count:%d\n", count);
+		mdelay(10);
+		count++;
+		if (count < 10) {
+			ov8830_common_deinit();
+			mdelay(10);
+		} else
+			goto init_fail;
+		goto retry;
+	}
+
+	ov8830_ctrl->sensormode = SENSOR_PREVIEW_MODE ;
+
+	if (rc < 0)
+		goto init_fail;
+
+	pr_info("[CAM]%s, enable AF actuator %d\n", __func__, __LINE__);
+
+	msleep(1);
+
+	ov8830_ctrl->fps = 30*Q8;
+
+	step_position_table[0] = 0;
+
+	for (i = 1; i <= OV8830_TOTAL_STEPS_NEAR_TO_FAR; i++) {
+		if (i <= ov8830_nl_region_boundary) {
+			ov8830_step_position_table[i] =
+				ov8830_step_position_table[i-1] +
+				ov8830_nl_region_code_per_step;
+		} else {
+			ov8830_step_position_table[i] =
+				ov8830_step_position_table[i-1] +
+				ov8830_l_region_code_per_step;
+		}
+	}
+
+	 /* generate test pattern */
+	pr_info("[CAM]%s, generate test pattern, %d, rc=%d\n",
+		__func__, __LINE__, rc);
+
+	/* set up lens position table */
+	ov8830_setup_af_tbl();
+	ov8830_go_to_position(0, 0);
+	ov8830_ctrl->curr_lens_pos = 0;
+	ov8830_ctrl->curr_step_pos = 0;
+
+	if (rc >= 0)
+		goto init_done;
+	    /* reset the driver state */
+init_fail:
+	pr_err("[CAM]%s: init_fail\n", __func__);
+	/*vreg_disable(vreg_af_actuator);*/
+	if (ov8830_ctrl) {
+		kfree(ov8830_ctrl);
+		ov8830_ctrl = NULL;
+	}
+init_done:
+	up(&ov8830_sem);
+	pr_info("[CAM]%s: init_done\n", __func__);
+	return rc;
+
+} /*endof ov8830_sensor_open_init*/
+
+static int ov8830_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&ov8830_wait_queue);
+	return 0;
+}
+
+static const struct i2c_device_id ov8830_i2c_id[] = {
+	{ "ov8830", 0},
+	{ }
+};
+
+static int ov8830_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rc = 0;
+	pr_info("[CAM]ov8830_probe called!\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("[CAM]i2c_check_functionality failed\n");
+		goto probe_failure;
+	}
+
+	ov8830_sensorw = kzalloc(sizeof(struct ov8830_work), GFP_KERNEL);
+	if (!ov8830_sensorw) {
+		pr_err("[CAM]kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, ov8830_sensorw);
+	ov8830_init_client(client);
+	ov8830_client = client;
+
+	msleep(50);
+
+	pr_info("[CAM]ov8830_probe successed! rc = %d\n", rc);
+	return 0;
+
+probe_failure:
+	pr_err("[CAM]ov8830_probe failed! rc = %d\n", rc);
+	return rc;
+}
+
+static int ov8830_vreg_disable(struct platform_device *pdev)
+{
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+	int rc;
+	pr_info("[CAM] %s camera vreg off\n", __func__);
+	if (sdata->camera_power_off == NULL) {
+		pr_err("[CAM]sensor platform_data didnt register\n");
+		return -EIO;
+	}
+	rc = sdata->camera_power_off();
+	return rc;
+}
+
+static int ov8830_probe_init_done(const struct msm_camera_sensor_info *data)
+{
+	int rc;
+
+	if (data->sensor_pwd >= 0) {
+		rc = gpio_request(data->sensor_pwd, "ov8830");
+		if (!rc)
+			gpio_direction_output(data->sensor_pwd, 0);
+		else
+			pr_err("[CAM]GPIO (%d) request faile\n", data->sensor_pwd);
+		gpio_free(data->sensor_pwd);
+	} else {
+      if (data->camera_pm8058_power != NULL) {
+		if (data->camera_pm8058_power(0) < 0)
+		  pr_err("[CAM]camera_pm8058_power(0): request failed\n");
+	  }
+	}
+	mdelay(1);
+
+  if (data->vcm_pwd) {
+    rc = gpio_request(data->vcm_pwd, "ov8830");
+    if (!rc)
+      gpio_direction_output(data->vcm_pwd, 0);
+    else
+      pr_err("[CAM]GPIO (%d) request faile\n", data->vcm_pwd);
+    gpio_free(data->vcm_pwd);
+  }
+  mdelay(1);
+
+
+  data->pdata->camera_gpio_off();
+  mdelay(1);
+
+  pr_info("[CAM] data->power_down_disable=%d", data->power_down_disable);
+  if (!data->power_down_disable) {
+    ov8830_vreg_disable(ov8830_pdev);
+  }
+
+	return 0;
+}
+
+static int ov8830_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int rc;
+	struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+
+	if (!sinfo->need_suspend)
+		return 0;
+	ov8830_event.waked_up = 0;
+
+	pr_info("[CAM]ov8830: camera suspend\n");
+
+	pr_info("[CAM]%s, vreg_af_actuator vreg_disable\n", __func__);
+	/*vreg_disable(vreg_af_actuator);*/
+
+	rc = gpio_request(sinfo->sensor_reset, "ov8830");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_reset, 0);
+	else
+		pr_info("[CAM]ov8830: request GPIO(sensor_reset) :%d faile\n",
+			sinfo->sensor_reset);
+
+	gpio_free(sinfo->sensor_reset);
+	msleep(10);
+		rc = gpio_request(sinfo->sensor_pwd, "ov8830");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_pwd, 0);
+	else
+		pr_info("[CAM]ov8830: request GPIO(sensor_reset) :%d faile\n",
+			sinfo->sensor_pwd);
+
+	gpio_free(sinfo->sensor_pwd);
+
+	pr_info("[CAM]ov8830:suspend done\n");
+	return rc;
+}
+
+static void ov8830_resume(struct early_suspend *handler)
+{
+	int rc = 0;
+	struct msm_camera_sensor_info *sinfo = ov8830_pdev->dev.platform_data;
+	pr_info("[CAM]ov8830_resume\n");
+
+	/*check whether need resume*/
+	if (!sinfo->need_suspend)
+		return;
+
+	/*check whether already suspend*/
+	if (ov8830_event.waked_up == 1) {
+		pr_info("[CAM]Ov8830: No nesesary to do Resume\n");
+		return;
+	}
+
+	mdelay(5);
+	/*power down setup*/
+	pr_info("[CAM]%s, sensor_pwd 0\n", __func__);
+	rc = gpio_request(sinfo->sensor_pwd, "ov8830");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_pwd, 0);
+	else
+		pr_err("[CAM]GPIO (%d) request faile\n", sinfo->sensor_pwd);
+	gpio_free(sinfo->sensor_pwd);
+	mdelay(5);
+	/*reset setup */
+	rc = gpio_request(sinfo->sensor_reset, "ov8830");
+	if (!rc)
+		gpio_direction_output(sinfo->sensor_reset, 1);
+	else
+		pr_err("[CAM]GPIO (%d) request faile\n", sinfo->sensor_reset);
+	gpio_free(sinfo->sensor_reset);
+
+	/*init msm,clk ,GPIO,enable*/
+	pr_info("[CAM]%s, msm_camio_probe_on\n", __func__);
+	msm_camio_probe_on(ov8830_pdev);
+	msm_camio_clk_enable(CAMIO_MDC_CLK);
+
+	/*set MCLK*/
+	pr_info("[CAM]%s, msm_camio_clk_rate_set = %d\n",
+		__func__, OV8830_DEFAULT_CLOCK_RATE);
+	msm_camio_clk_rate_set(OV8830_DEFAULT_CLOCK_RATE);
+	msleep(100);
+
+	/*read sensor id*/
+	rc = ov8830_probe_read_id(sinfo);
+	if (rc < 0)
+		pr_err("[CAM]OV8830 resume faile :can not read sensor ID\n");
+
+	/* Initialize Sensor registers */
+	rc = initialize_ov8830_registers();
+	if (rc < 0)
+		return;
+	msleep(20);
+	/*resume done*/
+	ov8830_probe_init_done(sinfo);
+	/*turn off MCLK*/
+	msm_camio_probe_off(ov8830_pdev);
+	msm_camio_clk_disable(CAMIO_MDC_CLK);
+
+	ov8830_event.waked_up = 1;
+	pr_info("[CAM]ov8830:resume done\n");
+	wake_up(&ov8830_event.event_wait);
+	return;
+}
+
+
+static int __exit ov8830_i2c_remove(struct i2c_client *client)
+{
+	struct ov8830_work_t *sensorw = i2c_get_clientdata(client);
+	free_irq(client->irq, sensorw);
+	deinit_suspend();
+	ov8830_client = NULL;
+	kfree(sensorw);
+	sensorw = NULL;
+	return 0;
+}
+
+static struct i2c_driver ov8830_i2c_driver = {
+	.id_table = ov8830_i2c_id,
+	.probe	= ov8830_i2c_probe,
+	.remove = __exit_p(ov8830_i2c_remove),
+	.driver = {
+		.name = "ov8830",
+	},
+};
+
+
+static struct early_suspend early_suspend_ov8830 = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN+1,
+	.resume = ov8830_resume,
+	.suspend = NULL,
+};
+
+static const char *Ov8830Vendor = "OmniVision";
+static const char *Ov8830NAME = "ov8830";
+static const char *Ov8830Size = "8M";
+
+static ssize_t sensor_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "%s %s %s\n", Ov8830Vendor, Ov8830NAME, Ov8830Size);
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+DEFINE_MUTEX(cam_mode_lock);
+
+static ssize_t sensor_read_cam_mode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	mutex_lock(&cam_mode_lock);
+	length = sprintf(buf, "%d\n", cam_mode_sel);
+	mutex_unlock(&cam_mode_lock);
+	return length;
+}
+
+static ssize_t sensor_set_cam_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t tmp = 0;
+	mutex_lock(&cam_mode_lock);
+	tmp = buf[0] - 0x30; /* only get the first char */
+	cam_mode_sel = tmp;
+	mutex_unlock(&cam_mode_lock);
+	return count;
+}
+
+static ssize_t sensor_read_node(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	length = sprintf(buf, "%d\n", sensor_probe_node);
+	return length;
+}
+
+static DEVICE_ATTR(sensor, 0444, sensor_vendor_show, NULL);
+static DEVICE_ATTR(cam_mode, 0644, sensor_read_cam_mode, sensor_set_cam_mode);
+static DEVICE_ATTR(node, 0444, sensor_read_node, NULL);
+
+static struct kobject *android_ov8830;
+
+static int ov8830_sysfs_init(void)
+{
+	int ret = 0;
+	pr_info("[CAM]ov8830:kobject creat and add\n");
+	android_ov8830 = kobject_create_and_add("android_camera", NULL);
+	if (android_ov8830 == NULL) {
+		pr_info("[CAM]ov8830_sysfs_init: subsystem_register failed\n");
+		ret = -ENOMEM;
+		return ret ;
+	}
+	pr_info("[CAM]ov8830:sysfs_create_file\n");
+	ret = sysfs_create_file(android_ov8830, &dev_attr_sensor.attr);
+	if (ret) {
+		pr_info("[CAM]ov8830_sysfs_init: sysfs_create_file failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(android_ov8830, &dev_attr_cam_mode.attr);
+	if (ret) {
+		pr_info("[CAM]ov8830_sysfs_init: dev_attr_cam_mode failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	ret = sysfs_create_file(android_ov8830, &dev_attr_node.attr);
+	if (ret) {
+		pr_info("[CAM]ov8830_sysfs_init: dev_attr_node failed\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	return ret;
+
+error:
+	kobject_del(android_ov8830);
+	return ret;
+}
+
+#ifdef CONFIG_ARCH_MSM7X30
+uint8_t ov8830_preview_skip_frame(void)
+{
+	if (ov8830_ctrl->sensormode == SENSOR_PREVIEW_MODE && preview_frame_count < 2) {
+		preview_frame_count++;
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+int ov8830_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cdata;
+	long rc = 0;
+
+	if (copy_from_user(&cdata,
+			(void *)argp,
+			sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+
+	down(&ov8830_sem);
+
+	CDBG("[CAM] ov8830_sensor_config: cfgtype = %d\n",
+	  cdata.cfgtype);
+		switch (cdata.cfgtype) {
+		case CFG_GET_PICT_FPS:
+				ov8830_get_pict_fps(
+				cdata.cfg.gfps.prevfps,
+				&(cdata.cfg.gfps.pictfps));
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PREV_L_PF:
+			cdata.cfg.prevl_pf =
+			ov8830_get_prev_lines_pf();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PREV_P_PL:
+			cdata.cfg.prevp_pl =
+				ov8830_get_prev_pixels_pl();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_L_PF:
+			cdata.cfg.pictl_pf =
+				ov8830_get_pict_lines_pf();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_P_PL:
+			cdata.cfg.pictp_pl =
+				ov8830_get_pict_pixels_pl();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_GET_PICT_MAX_EXP_LC:
+			cdata.cfg.pict_max_exp_lc =
+				ov8830_get_pict_max_exp_lc();
+
+			if (copy_to_user((void *)argp,
+				&cdata,
+				sizeof(struct sensor_cfg_data)))
+				rc = -EFAULT;
+			break;
+
+		case CFG_SET_FPS:
+		case CFG_SET_PICT_FPS:
+			rc = ov8830_set_fps(&(cdata.cfg.fps));
+			break;
+
+		case CFG_SET_EXP_GAIN:
+			rc =
+				ov8830_write_exp_gain(
+					cdata.cfg.exp_gain.mul,
+					cdata.cfg.exp_gain.gain,
+					cdata.cfg.exp_gain.line);
+			break;
+
+		case CFG_SET_PICT_EXP_GAIN:
+			rc =
+				ov8830_set_pict_exp_gain(
+					cdata.cfg.exp_gain.mul,
+					cdata.cfg.exp_gain.gain,
+					cdata.cfg.exp_gain.line);
+			break;
+
+		case CFG_SET_MODE:
+			rc = ov8830_set_sensor_mode(cdata.mode,
+						cdata.rs);
+			break;
+
+		case CFG_PWR_DOWN:
+			rc = ov8830_power_down();
+			break;
+
+		case CFG_MOVE_FOCUS:
+			rc =
+				ov8830_move_focus(
+					cdata.cfg.focus.dir,
+					cdata.cfg.focus.steps);
+			break;
+
+		case CFG_SET_DEFAULT_FOCUS:
+			rc = ov8830_set_default_focus();
+			break;
+
+		case CFG_SET_EFFECT:
+			rc = ov8830_set_default_focus();
+			break;
+
+		case CFG_I2C_IOCTL_R_OTP:{
+			rc = ov8830_i2c_read_fuseid(&cdata);
+			if (copy_to_user
+				(argp, &cdata, sizeof(struct sensor_cfg_data))
+			    )
+			rc = -EFAULT;
+			}
+			break;
+
+		case CFG_SET_OV_LSC:
+			rc = ov8830_update_lsc_table(&cdata);
+			break;
+
+		/*20100330 vincent for lsc calibration*/
+		case CFG_SET_OV_LSC_RAW_CAPTURE:
+			rc = ov8830_LSC_calibration_set_rawflag(&cdata);
+			break;
+
+		default:
+			rc = -EFAULT;
+			break;
+		}
+
+	prevent_suspend();
+	up(&ov8830_sem);
+
+	return rc;
+}
+
+
+static int ov8830_common_deinit(void)
+{
+	int rc = -EBADF;
+
+	/*power down setup*/
+	if (ov8830_ctrl->sensordata->sensor_pwd >= 0) {
+		rc = gpio_request(ov8830_ctrl->sensordata->sensor_pwd, "ov8830");
+		if (!rc)
+			gpio_direction_output(ov8830_ctrl->sensordata->sensor_pwd, 0);
+		else
+			pr_err("[CAM]GPIO (%d) request faile\n", ov8830_ctrl->sensordata->sensor_pwd);
+		gpio_free(ov8830_ctrl->sensordata->sensor_pwd);
+
+	} else {
+      if (ov8830_ctrl->sensordata->camera_pm8058_power != NULL) {
+		if (ov8830_ctrl->sensordata->camera_pm8058_power(0) < 0)
+		  pr_err("[CAM]camera_pm8058_power(0): request failed\n");
+	  }
+	}
+	mdelay(5);
+
+	if (ov8830_ctrl->sensordata->vcm_pwd) {
+		rc = gpio_request(ov8830_ctrl->sensordata->vcm_pwd, "ov8830");
+		if (!rc)
+			gpio_direction_output(ov8830_ctrl->sensordata->vcm_pwd, 0);
+		else
+			pr_err("[CAM]GPIO (%d) request faile\n", ov8830_ctrl->sensordata->vcm_pwd);
+		gpio_free(ov8830_ctrl->sensordata->vcm_pwd);
+	}
+	mdelay(1);
+
+	msm_camio_probe_off(ov8830_pdev);
+
+	ov8830_ctrl->sensordata->pdata->camera_gpio_off();
+
+	if (!ov8830_ctrl->sensordata->power_down_disable) {
+		rc = ov8830_vreg_disable(ov8830_pdev);
+	}
+
+	return rc;
+}
+
+static int ov8830_sensor_release(void)
+{
+	int rc = -EBADF;
+
+	down(&ov8830_sem);
+	msleep(35);
+
+	pr_info("[CAM]ov8830_sensor_release");
+
+
+/*HTC_START Horng 20110905*/
+#ifdef CONFIG_MSM_CAMERA_8X60
+	msm_mipi_csi_disable();
+#endif
+/*HTC_END*/
+
+
+	rc = ov8830_common_deinit();
+
+	msleep(20);
+
+	allow_suspend();
+	pr_info("[CAM]ov8830_release completed\n");
+	up(&ov8830_sem);
+
+	return rc;
+}
+
+static int ov8830_sensor_probe(struct msm_camera_sensor_info *info,
+		struct msm_sensor_ctrl *s)
+{
+	int rc = 0;
+	pr_info("[CAM]ov8830_sensor_probe()\n");
+
+	rc = i2c_add_driver(&ov8830_i2c_driver);
+
+	if (rc < 0 || ov8830_client == NULL) {
+		rc = -ENOTSUPP;
+		pr_err("[CAM]__ov8830_probe, rc < 0 or ov8830_client == NULL\n");
+		return rc;
+	}
+
+	pr_info("[CAM]ov8830 s->node %d\n", s->node);
+	sensor_probe_node = s->node;
+	/*switch pclk and mclk between main cam and 2nd cam*/
+	/*only for supersonic*/
+	pr_info("[CAM]ov8830: doing clk switch (ov8830)\n");
+
+  rc = ov8830_vreg_enable(ov8830_pdev);
+	if (rc < 0) {
+		pr_err("[CAM]__ov8830_probe rc < 0\n");
+	}
+
+	if (info->camera_clk_switch != NULL)
+		info->camera_clk_switch();
+	mdelay(5);
+
+	/*power down setup*/
+	pr_info("[CAM]%s, GPIO(%d) sensor_pwd 0\n", __func__, info->sensor_pwd);
+	if (info->sensor_pwd >= 0) {
+		rc = gpio_request(info->sensor_pwd, "ov8830");
+		if (!rc)
+			gpio_direction_output(info->sensor_pwd, 1);
+		else
+			pr_err("[CAM]GPIO (%d) request faile\n", info->sensor_pwd);
+		gpio_free(info->sensor_pwd);
+	} else {
+		if (info->camera_pm8058_power != NULL) {
+			if (info->camera_pm8058_power(1) < 0)
+				goto probe_fail;
+		}
+	}
+	mdelay(5);
+
+	info->pdata->camera_gpio_on();
+
+	/*set MCLK*/
+	pr_info("[CAM]%s, msm_camio_clk_rate_set %d\n",
+		__func__, OV8830_DEFAULT_CLOCK_RATE);
+
+       msm_camio_clk_rate_set(OV8830_DEFAULT_CLOCK_RATE);
+
+	msleep(100);
+	/*read sensor id*/
+	rc = ov8830_probe_read_id(info);
+
+  if (rc < 0) {
+		goto probe_fail;
+  }
+
+	/* Initialize Sensor registers */
+	rc = initialize_ov8830_registers();
+	if (rc < 0)
+		return rc;
+
+/*
+	if (info->camera_main_set_probe != NULL)
+		info->camera_main_set_probe(true);
+*/
+
+#if 1 /* Get OTP fuse id for OV sensor*/
+ov8830_i2c_write_b(ov8830_client->addr, 0x3d84, 0xc0);
+ov8830_i2c_write_b(ov8830_client->addr, 0x3d81, 0x01);
+ov8830_i2c_read(0x3d00, &fuse_id[0], 1);
+ov8830_i2c_read(0x3d01, &fuse_id[1], 1);
+ov8830_i2c_read(0x3d02, &fuse_id[2], 1);
+ov8830_i2c_read(0x3d03, &fuse_id[3], 1);
+ov8830_i2c_read(0x3d04, &fuse_id[4], 1);
+ov8830_i2c_read(0x3d05, &fuse_id[5], 1);
+ov8830_i2c_read(0x3d06, &fuse_id[6], 1);
+ov8830_i2c_read(0x3d07, &fuse_id[7], 1);
+ov8830_i2c_read(0x3d08, &fuse_id[8], 1);
+ov8830_i2c_read(0x3d09, &fuse_id[9], 1);
+ov8830_i2c_read(0x3d0A, &fuse_id[10], 1);
+ov8830_i2c_read(0x3d0B, &fuse_id[11], 1);
+ov8830_i2c_read(0x3d0C, &fuse_id[12], 1);
+ov8830_i2c_read(0x3d0D, &fuse_id[13], 1);
+ov8830_i2c_read(0x3d0E, &fuse_id[14], 1);
+ov8830_i2c_read(0x3d0F, &fuse_id[15], 1);
+#endif
+
+	init_suspend();
+	s->s_init = ov8830_sensor_open_init;
+	s->s_release = ov8830_sensor_release;
+	s->s_config  = ov8830_sensor_config;
+
+#ifdef CONFIG_ARCH_MSM7X30
+	info->preview_skip_frame = ov8830_preview_skip_frame;
+#endif
+
+	msleep(20);
+	ov8830_probe_init_done(info);
+	/*register late resuem*/
+	register_early_suspend(&early_suspend_ov8830);
+	/*init wait event*/
+	init_waitqueue_head(&ov8830_event.event_wait);
+	/*init waked_up value*/
+	ov8830_event.waked_up = 1;
+	/*write sysfs*/
+	ov8830_sysfs_init();
+	pr_info("[CAM]%s: ov8830_probe_init_done %d\n",  __func__, __LINE__);
+	goto probe_done;
+
+probe_fail:
+	pr_err("[CAM]SENSOR PROBE FAILS!\n");
+	ov8830_probe_init_done(info);
+probe_done:
+	return rc;
+
+}
+
+static int __ov8830_probe(struct platform_device *pdev)
+{
+/*
+	struct msm_camera_sensor_info *sdata = pdev->dev.platform_data;
+*/
+	pr_info("[CAM]__ov8830_probe\n");
+	ov8830_pdev = pdev;
+
+/*
+	if (sdata->camera_main_get_probe != NULL) {
+		if (sdata->camera_main_get_probe()) {
+			pr_info("[CAM]__ov8830_probe camera main get probed already.\n");
+			return 0;
+		}
+	}
+*/
+
+	return msm_camera_drv_start(pdev, ov8830_sensor_probe);  /*msm_camera_drv_start(pdev, ov8830_sensor_probe)*/
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __ov8830_probe,
+	.driver = {
+		.name = "msm_camera_ov8830",
+		.owner = THIS_MODULE,
+	},
+	.suspend = ov8830_suspend,
+};
+
+static int __init ov8830_init(void)
+{
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(ov8830_init);
diff --git a/drivers/media/video/msm/sensors/ov8830.h b/drivers/media/video/msm/sensors/ov8830.h
new file mode 100644
index 0000000..e8760b5
--- /dev/null
+++ b/drivers/media/video/msm/sensors/ov8830.h
@@ -0,0 +1,89 @@
+/* Copyright (c) 2008-2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef OV8830_H
+#define OV8830_H
+
+#include <linux/types.h>
+#include <mach/camera.h>
+
+struct ov8830_i2c_reg_conf {
+	unsigned short waddr;
+	unsigned char  bdata;
+};
+
+struct ov8830_reg_t {
+	struct ov8830_i2c_reg_conf *common_mipi;
+	uint16_t common_mipi_size;
+
+	struct ov8830_i2c_reg_conf *qtr_mipi;
+	uint16_t qtr_mipi_size;
+
+	struct ov8830_i2c_reg_conf *video_mipi;
+	uint16_t video_mipi_size;
+
+  struct ov8830_i2c_reg_conf *fast_video_mipi;
+  uint16_t fast_video_mipi_size;
+
+	struct ov8830_i2c_reg_conf *full_mipi;
+	uint16_t full_mipi_size;
+};
+
+extern struct ov8830_reg_t ov8830_regs;
+
+
+#endif
+
diff --git a/drivers/media/video/msm/sensors/ov8830_reg_vigor.c b/drivers/media/video/msm/sensors/ov8830_reg_vigor.c
new file mode 100644
index 0000000..08092b7
--- /dev/null
+++ b/drivers/media/video/msm/sensors/ov8830_reg_vigor.c
@@ -0,0 +1,614 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ov8830.h"
+
+struct ov8830_i2c_reg_conf ov8830_common_settings_array_mipi[] =
+{
+  {0x0100, 0x00},
+  {0x0103, 0x01},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0102, 0x01},  /*ov init_setting from FAE 20110530*/
+
+	{0x0100, 0x00},  /*for delay start easter 20110530*/
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00}, /*for delay end 20110530*/
+
+  {0x3000, 0x00},
+  {0x3001, 0x2a},
+  {0x3002, 0x88},
+  {0x3003, 0x00},
+  {0x3004, 0x00},
+  {0x3005, 0x00},
+  {0x3006, 0x00},
+  {0x3007, 0x00},
+  {0x3008, 0x00},
+  {0x3009, 0x00},
+  {0x3011, 0x21},
+  {0x3012, 0x08},
+  {0x3013, 0x10},
+  {0x3014, 0x00},
+  {0x3015, 0xc8},
+  {0x3016, 0xf0},
+  {0x3017, 0xf0},
+  {0x3018, 0xf0},
+  {0x301b, 0xb4},
+  {0x301d, 0x02}, /*ov init_setting from FAE 20110530*/
+  {0x3021, 0x00},
+  {0x3022, 0x00},
+  {0x3024, 0x00},
+  {0x3026, 0x00},
+  {0x3027, 0x00},
+  {0x3081, 0x02},
+  {0x3083, 0x01},
+  {0x3090, 0x02},
+  {0x3091, 0x12},
+  {0x3092, 0x00},
+  {0x3093, 0x00},
+  {0x3098, 0x03},
+  {0x3099, 0x1e},
+  {0x309a, 0x00},
+  {0x309b, 0x00},
+  {0x30a2, 0x01},
+  {0x30b0, 0x05},
+  {0x30b2, 0x00},
+  {0x30b3, 0x54},
+  {0x30b4, 0x02},
+  {0x30b5, 0x04},
+  {0x30b6, 0x01},
+  {0x3104, 0xa1},
+  {0x3106, 0x01},
+  {0x3300, 0x00},
+  {0x3400, 0x04},
+  {0x3401, 0x00},
+  {0x3402, 0x04}, /*ov init_setting from FAE 20110530*/
+  {0x3403, 0x00},
+  {0x3404, 0x04}, /*ov init_setting from FAE 20110530*/
+  {0x3405, 0x00},
+  {0x3406, 0x01},
+  {0x3500, 0x01},/*{0x3500, 0x00}, //ov init_setting from FAE 20110530*/
+  {0x3501, 0x4b},/*{0x3501, 0x4c}, //ov init_setting from FAE 20110530*/
+  {0x3502, 0x40},/*{0x3502, 0x80}, //ov init_setting from FAE 20110530*/
+  {0x3503, 0x07},
+  {0x3504, 0x00},
+  {0x3505, 0x30},
+  {0x3506, 0x00},
+  {0x3507, 0x08},
+  {0x3508, 0x80},
+  {0x3509, 0x10},
+  {0x350a, 0x00},
+  {0x350b, 0xbf},/*{0x350b, 0x38},//ov init_setting from FAE 20110530*/
+  {0x350c, 0x00},
+  {0x350d, 0x00},
+  {0x3600, 0x78},
+  {0x3601, 0x02},
+  {0x3602, 0x1c},
+  {0x3604, 0x38},
+  {0x3620, 0x64},
+  {0x3625, 0x64}, /*ov init_setting from FAE 20110530*/
+  {0x3621, 0xb5},
+  {0x3622, 0x03},
+  {0x3630, 0x55},
+  {0x3631, 0xd2},
+  {0x3632, 0x00},
+  {0x3633, 0x34},
+  {0x3634, 0x03},
+  {0x3660, 0x80},
+  {0x3662, 0x10},
+  {0x3665, 0x00},
+  {0x3666, 0x00},
+  {0x3667, 0x00},
+  {0x366a, 0x80},
+  {0x366c, 0x00},
+  {0x366d, 0x00},
+  {0x366e, 0x00},
+  {0x366f, 0x20}, /*ov init_setting from FAE 20110530*/
+  {0x3680, 0xe0},
+  {0x3681, 0x00},
+  {0x3701, 0x14},
+  {0x3702, 0xbf},
+  {0x3703, 0x8c},
+  {0x3704, 0x78},
+  {0x3705, 0x02},
+  {0x3708, 0xe4},
+  {0x3709, 0x03},
+  {0x370a, 0x00},
+  {0x370b, 0x20},
+  {0x370c, 0x0c},
+  {0x370d, 0x11},
+  {0x370e, 0x00},
+  {0x370f, 0x00},
+  {0x3710, 0x00},
+  {0x371c, 0x01},
+  {0x371f, 0x0c},
+  {0x3721, 0x00},
+  {0x3724, 0x10},
+  {0x3726, 0x00},
+  {0x372a, 0x01},
+  {0x3730, 0x18},
+  {0x3738, 0x22},
+  {0x3739, 0x08},
+  {0x373a, 0x51},
+  {0x373b, 0x02},
+  {0x373c, 0x20},
+  {0x373f, 0x02},
+  {0x3740, 0x42},
+  {0x3741, 0x02},
+  {0x3742, 0x18},
+  {0x3743, 0x01},
+  {0x3744, 0x02},
+  {0x3747, 0x10},
+  {0x374c, 0x04},
+  {0x3751, 0xf0},
+  {0x3752, 0x00},
+  {0x3753, 0x00},
+  {0x3754, 0xc0},
+  {0x3755, 0x00},
+  {0x3756, 0x1a},
+  {0x3758, 0x00},
+  {0x3759, 0x0f},
+  {0x375c, 0x04},
+  {0x3767, 0x01},
+  {0x376b, 0x44},
+	{0x3774, 0x10}, /*ov init_setting from FAE 20110530*/
+  {0x3776, 0x00},
+  {0x377f, 0x08},
+  {0x3780, 0x22},
+  {0x3781, 0x0c},
+  {0x3784, 0x2c},
+  {0x3785, 0x1e},
+  {0x378f, 0xf5},
+  {0x3791, 0xb0},
+  {0x3795, 0x00},
+  {0x3796, 0x64},
+  {0x3797, 0x11},
+  {0x3798, 0x30},
+  {0x3799, 0x41},
+	{0x379a, 0x07}, /*ov init_setting from FAE 20110530*/
+	{0x379b, 0xb0}, /*ov init_setting from FAE 20110530*/
+  {0x379c, 0x0c},
+  {0x37c0, 0x00},
+  {0x37c1, 0x00},
+  {0x37c2, 0x00},
+  {0x37c3, 0x00},
+  {0x37c4, 0x00},
+  {0x37c5, 0x00},
+  {0x37c6, 0xa0},
+  {0x37c7, 0x00},
+  {0x37c8, 0x00},
+  {0x37c9, 0x00},
+  {0x37ca, 0x00},
+  {0x37cb, 0x00},
+  {0x37cc, 0x00},
+  {0x37cd, 0x00},
+  {0x37ce, 0x01},
+  {0x37cf, 0x00},
+	{0x37d1, 0x01}, /*ov init_setting from FAE 20110530*/
+  {0x37de, 0x00},
+  {0x37df, 0x00},
+  {0x3800, 0x00},
+  {0x3801, 0x28},
+  {0x3802, 0x00},
+  {0x3803, 0x20},
+  {0x3804, 0x0c},
+  {0x3805, 0xb7},
+  {0x3806, 0x09},
+  {0x3807, 0x8f},
+  {0x3808, 0x06},
+  {0x3809, 0x40},
+  {0x380a, 0x04},
+  {0x380b, 0xb0},
+  {0x380c, 0x0e},
+  {0x380d, 0x18},
+  {0x380e, 0x14},/*{0x380e, 0x07}, //ov init_setting from FAE 20110530*/
+  {0x380f, 0xc9},/*{0x380f, 0xd0}, //ov init_setting from FAE 20110530*/
+  {0x3810, 0x00},
+  {0x3811, 0x04},
+  {0x3812, 0x00},
+  {0x3813, 0x04},
+  {0x3814, 0x31},
+  {0x3815, 0x31},
+	{0x3820, 0x11},
+	{0x3821, 0x0f},
+	{0x3823, 0x00}, /*ov init_setting from FAE 20110530*/
+	{0x3824, 0x00}, /*ov init_setting from FAE 20110530*/
+	{0x3825, 0x00}, /*ov init_setting from FAE 20110530*/
+	{0x3826, 0x00}, /*ov init_setting from FAE 20110530*/
+	{0x3827, 0x00}, /*ov init_setting from FAE 20110530*/
+  {0x382a, 0x04},
+  {0x3a04, 0x04},
+  {0x3a05, 0xc9},
+  {0x3a06, 0x00},
+  {0x3a07, 0xf8},
+  {0x3a18, 0x00},
+  {0x3a19, 0x00},
+  {0x3b00, 0x00},
+  {0x3b01, 0x00},
+  {0x3b02, 0x00},
+  {0x3b03, 0x00},
+  {0x3b04, 0x00},
+  {0x3b05, 0x00},
+  {0x3d00, 0x00},
+  {0x3d01, 0x00},
+  {0x3d02, 0x00},
+  {0x3d03, 0x00},
+  {0x3d04, 0x00},
+  {0x3d05, 0x00},
+  {0x3d06, 0x00},
+  {0x3d07, 0x00},
+  {0x3d08, 0x00},
+  {0x3d09, 0x00},
+  {0x3d0a, 0x00},
+  {0x3d0b, 0x00},
+  {0x3d0c, 0x00},
+  {0x3d0d, 0x00},
+  {0x3d0e, 0x00},
+  {0x3d0f, 0x00},
+  {0x3d80, 0x00},
+  {0x3d81, 0x00},
+  {0x3d84, 0x00},
+  {0x3e07, 0x20},
+  {0x4000, 0x10},
+  {0x4001, 0x04},
+  {0x4002, 0x45},
+  {0x4004, 0x02},
+  {0x4005, 0x18},
+	{0x4006, 0x16}, /*ov init_setting from FAE 20110530*/
+	{0x4008, 0x20}, /*ov init_setting from FAE 20110530*/
+  {0x4009, 0x10},
+  {0x400c, 0x00},
+  {0x400d, 0x00},
+  {0x4058, 0x01},
+	{0x4101, 0x12}, /*ov init_setting from FAE 20110530*/
+  {0x4104, 0x5b},
+  {0x4303, 0x00},
+  {0x4304, 0x08},
+  {0x4307, 0x30},
+  {0x4315, 0x00},
+  {0x4511, 0x05},
+  {0x4512, 0x00},
+  {0x4750, 0x00},
+  {0x4751, 0x00},
+  {0x4752, 0x00},
+  {0x4753, 0x00},
+  {0x4805, 0x01},
+  {0x4806, 0x00},
+  {0x481f, 0x36},
+  {0x4831, 0x6c},
+  {0x4837, 0x0d},
+  {0x4a00, 0xaa},
+  {0x4a03, 0x01},
+  {0x4a05, 0x08},
+  {0x4a0a, 0x88},
+  {0x5000, 0x06},
+  {0x5001, 0x01},
+  {0x5002, 0x80},
+  {0x5003, 0x20},
+  {0x5013, 0x00},
+  {0x5046, 0x4a},
+	{0x5780, 0x1c}, /*ov init_setting from FAE 20110530*/
+  {0x5786, 0x20},
+  {0x5787, 0x10},
+  {0x5788, 0x18},
+	{0x578a, 0x04}, /*ov init_setting from FAE 20110530*/
+	{0x578b, 0x02}, /*ov init_setting from FAE 20110530*/
+	{0x578c, 0x02}, /*ov init_setting from FAE 20110530*/
+	{0x578e, 0x06}, /*ov init_setting from FAE 20110530*/
+	{0x578f, 0x02}, /*ov init_setting from FAE 20110530*/
+  {0x5790, 0x02},
+  {0x5791, 0xff},
+	{0x5a08, 0x02}, /*ov init_setting from FAE 20110530*/
+  {0x5e00, 0x00},
+  {0x5e10, 0x0c},
+  /*{0x0100, 0x01},*/ /*remmove stream off by easter 20110530*/
+};
+
+struct ov8830_i2c_reg_conf ov8830_qtr_settings_array_mipi[] =
+{
+  {0x0100, 0x00},  /*stream off*/
+
+	{0x0100, 0x00},/*for delay start*/
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},  /*for delay end*/
+
+  {0x3011, 0x21},
+  {0x3015, 0xc8},
+  {0x3090, 0x02},
+  {0x3091, 0x12},
+  {0x30b3, 0x4b},
+  {0x30b4, 0x03},
+  {0x3660, 0x80},
+  {0x3708, 0xe4},
+  {0x3800, 0x00},
+  {0x3801, 0x00},
+  {0x3802, 0x00},
+  {0x3803, 0x00},
+  {0x3804, 0x0c},
+  {0x3805, 0xdf},
+  {0x3806, 0x09},
+  {0x3807, 0xaf},
+  {0x3808, 0x06},
+  {0x3809, 0x68},
+  {0x380a, 0x04},
+  {0x380b, 0xd0},
+  {0x380c, 0x0e},
+  {0x380d, 0x18},
+  {0x380e, 0x04},
+  {0x380f, 0xf4},
+  {0x3810, 0x00},
+  {0x3811, 0x04},
+  {0x3812, 0x00},
+  {0x3813, 0x04},
+  {0x3814, 0x31},
+  {0x3815, 0x31},
+	{0x3820, 0x11},  /*0x11  0x53*/
+	{0x3821, 0x0f},  /*0x0f  0x09*/
+  {0x3a04, 0x04},
+  {0x3a05, 0xc9},
+  {0x4058, 0x01},
+  {0x4512, 0x00},
+  {0x4837, 0x0d},
+  {0x350b, 0x33},
+#if 0 /* move stream on to sensor_setting*/
+	{0x0100, 0x01}, /*stream on by easter 20110530*/
+#endif
+};
+
+struct ov8830_i2c_reg_conf ov8830_video_settings_array_mipi[] =
+{
+	{0x0100, 0x00},/*stream off*/
+
+	{0x0100, 0x00},/*for delay start easter 20110530*/
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},
+	{0x0100, 0x00},  /*for delay end easter 20110530*/
+
+	{0x3011, 0x21},
+	{0x3015, 0xc8},
+	{0x3090, 0x02},
+	{0x3091, 0x11},  /*0x12*/
+	{0x30b3, 0x4b},  /*0x50*/
+	{0x30b4, 0x02},  /*0x02*/
+	{0x3660, 0x80},
+	{0x3708, 0xe4},
+
+	{0x3092, 0x00},
+	{0x30b6, 0x01},
+
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x01},
+	{0x3803, 0x40},
+	{0x3804, 0x0c},
+	{0x3805, 0xd3},
+	{0x3806, 0x08},
+	{0x3807, 0x73},
+	{0x3808, 0x0c},
+	{0x3809, 0x10},
+	{0x380a, 0x06},
+	{0x380b, 0xc8},
+	{0x380c, 0x0e},
+	{0x380d, 0x18},
+	{0x380e, 0x07},
+	{0x380f, 0x5d}, /*0xcc*/
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x10},  /*0x52*/
+	{0x3821, 0x0e},  /*0x08*/
+	{0x3a04, 0x07},
+	{0x3a05, 0x49},
+	{0x4058, 0x00},
+	{0x4512, 0x01},
+	{0x4837, 0x09},  /*0x08*/
+	{0x350b, 0x37},
+#if 0 /* move stream on to sensor_setting*/
+	{0x0100, 0x01},/*stream on by easter 20110530*/
+#endif
+};
+
+struct ov8830_i2c_reg_conf ov8830_full_settings_array_mipi[] =
+{
+  {0x0100, 0x00},/*stream off by easter 20110530*/
+
+  {0x0100, 0x00},/*for delay start*/
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00},
+  {0x0100, 0x00}, /*for delay end*/
+
+  {0x3011, 0x21},
+  {0x3015, 0xc8},
+  {0x3090, 0x02},/*;modify for 21.1955fps 2011/05/06*/
+  {0x3091, 0x10},/*;modify for 21.1955fps 2011/05/06*/
+  {0x30b3, 0x4b},/*;modify for 900Mbps/lane 2011/05/06*/
+  {0x30b4, 0x02},/*;modify for 900Mbps/lane 2011/05/06*/
+  {0x3500, 0x00},/*ov init_setting from FAE 20110530*/
+  {0x3501, 0xa6},/*ov init_setting from FAE 20110530*/
+  {0x3502, 0x40},/*ov init_setting from FAE 20110530*/
+  {0x3660, 0x80},
+  {0x3708, 0xe4},
+  {0x3800, 0x00},
+  {0x3801, 0x04},
+  {0x3802, 0x00},
+  {0x3803, 0x04},
+  {0x3804, 0x0c},
+  {0x3805, 0xdb},
+  {0x3806, 0x09},
+  {0x3807, 0xab},
+  {0x3808, 0x0c},
+  {0x3809, 0xd0},
+  {0x380a, 0x09},
+  {0x380b, 0xa0},
+  {0x380c, 0x0e},
+  {0x380d, 0x18},
+  {0x380e, 0x09},/*ov 8M_setting from FAE 20110530*/
+  {0x380f, 0xc4},/*ov 8M_setting from FAE 20110530*/
+  {0x3810, 0x00},
+  {0x3811, 0x04},
+  {0x3812, 0x00},
+  {0x3813, 0x04},
+  {0x3814, 0x11},
+  {0x3815, 0x11},
+  {0x3820, 0x10},/*ov 8M_setting from FAE 20110530  0x52*/
+  {0x3821, 0x0e},/*ov 8M_setting from FAE 20110530  0x08*/
+  {0x3a04, 0x09},
+  {0x3a05, 0xa9},
+  {0x4058, 0x00},
+  {0x4512, 0x01},
+  {0x4837, 0x10},/*ov 8M_setting from FAE 20110530*/
+  {0x350b, 0x35},/*ov 8M_setting from FAE 20110530*/
+#if 0 /* move stream on to sensor_setting*/
+  {0x0100, 0x01},/*stream on by easter 20110530*/
+#endif
+};
+
+struct ov8830_i2c_reg_conf ov8830_fast_video_settings_array_mipi[] =
+{
+  {0x0100, 0x00},/*stream off*/
+  {0x3011, 0x21},
+  {0x3015, 0xc8},
+  {0x3090, 0x02},
+  {0x3091, 0x12},
+  {0x30b3, 0x51},
+  {0x30b4, 0x03},
+  {0x3660, 0x80},
+  {0x3708, 0xe4},
+  {0x3092, 0x00},
+  {0x3800, 0x00},
+  {0x3801, 0x00},
+  {0x3802, 0x01},
+  {0x3803, 0x18},
+  {0x3804, 0x0c},
+  {0x3805, 0xdf},
+  {0x3806, 0x08},
+  {0x3807, 0x77},
+  {0x3808, 0x06},
+  {0x3809, 0x68},
+  {0x380a, 0x03},
+  {0x380b, 0x94},
+  {0x380c, 0x0e},
+  {0x380d, 0x18},
+  {0x380e, 0x03},
+  {0x380f, 0xe6},
+  {0x3810, 0x00},
+  {0x3811, 0x04},
+  {0x3812, 0x00},
+  {0x3813, 0x04},
+  {0x3814, 0x31},
+  {0x3815, 0x31},
+  {0x3820, 0x11},	/*V-flip*/
+  {0x3821, 0x0f},	/*no H-mirror*/
+  {0x3a04, 0x04},
+  {0x3a05, 0xc9},
+  {0x4058, 0x01},
+  {0x4512, 0x00},
+  {0x4837, 0x10},
+  {0x350b, 0x33},
+#if 0 /* move stream on to sensor_setting*/
+  {0x0100, 0x01},/*stream on*/
+#endif
+};
+
+
+
+struct ov8830_reg_t ov8830_regs = {
+	.common_mipi = &ov8830_common_settings_array_mipi[0],
+	.common_mipi_size = ARRAY_SIZE(ov8830_common_settings_array_mipi),
+
+	.qtr_mipi = &ov8830_qtr_settings_array_mipi[0],
+	.qtr_mipi_size = ARRAY_SIZE(ov8830_qtr_settings_array_mipi),
+
+	.video_mipi = &ov8830_video_settings_array_mipi[0],
+	.video_mipi_size = ARRAY_SIZE(ov8830_video_settings_array_mipi),
+
+	.fast_video_mipi = &ov8830_fast_video_settings_array_mipi[0],
+	.fast_video_mipi_size = ARRAY_SIZE(ov8830_fast_video_settings_array_mipi),
+
+	.full_mipi = &ov8830_full_settings_array_mipi[0],
+	.full_mipi_size = ARRAY_SIZE(ov8830_full_settings_array_mipi),
+};
+
diff --git a/drivers/media/video/msm/sensors/s5k6aafx.h b/drivers/media/video/msm/sensors/s5k6aafx.h
index f8a9a0b..2f5547b 100644
--- a/drivers/media/video/msm/sensors/s5k6aafx.h
+++ b/drivers/media/video/msm/sensors/s5k6aafx.h
@@ -64,7 +64,7 @@
 
 extern struct s5k6aafx_reg s5k6aafx_regs;
 
-#if defined(CONFIG_MACH_SHOOTER) || defined(CONFIG_MACH_SHOOTER_K) || defined(CONFIG_MACH_SHOOTER_U) || defined(CONFIG_MACH_RIDER)  || defined(CONFIG_MACH_VILLEC2) || defined(CONFIG_MACH_HOLIDAY) || defined(CONFIG_MACH_VERDI_LTE) || defined(CONFIG_MACH_KINGDOM) || defined(CONFIG_MACH_SHOOTER_CT)
+#if defined(CONFIG_MACH_SHOOTER) || defined(CONFIG_MACH_SHOOTER_K) || defined(CONFIG_MACH_SHOOTER_U) || defined(CONFIG_MACH_RIDER) || defined(CONFIG_MACH_HOLIDAY) || defined(CONFIG_MACH_VERDI_LTE) || defined(CONFIG_MACH_KINGDOM) || defined(CONFIG_MACH_SHOOTER_CT)
 extern struct s5k6aafx_reg s5k6aafx_regs_cob;
 #else
 #define s5k6aafx_regs_cob s5k6aafx_regs
diff --git a/drivers/media/video/msm/sensors/s5k6aafx_reg_rider.c b/drivers/media/video/msm/sensors/s5k6aafx_reg_rider.c
new file mode 100644
index 0000000..772478b
--- /dev/null
+++ b/drivers/media/video/msm/sensors/s5k6aafx_reg_rider.c
@@ -0,0 +1,2760 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "s5k6aafx.h"
+
+static const struct s5k6aafx_i2c_reg_conf const reset_init_tbl[] = {
+	/* change to general mode */
+	{S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL},
+	{0x0010, 0x0001}, /* Reset */
+	{0x1030, 0x0000}, /* Clear host interrupt so main will wait */
+	{0x0014, 0x0001}, /* ARM go */
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const TP_init_tbl[] = {
+
+	/* Start T&P part */
+	/* DO NOT DELETE T&P SECTION COMMENTS! They are required to debug T&P related issues. */
+	/* svn://transrdsrv/svn/svnroot/System/Software/tcevb/SDK+FW/ISP_Oscar/Firmware */
+	/* Rev: 33110-33110 */
+	/* Signature: */
+	/* md5 f0ba942df15b96de5c09e6cf13fed9c9 .btp */
+	/* md5 8bc59f72129cb36e6f6db4be5ddca1f6 .htp */
+	/* md5 954ec97efcabad291d89f63e29f32490 .RegsMap.h */
+	/* md5 5c29fe50b51e7e860313f5b3b6452bfd .RegsMap.bin */
+	/* md5 6211407baaa234b753431cde4ba32402 .base.RegsMap.h */
+	/* md5 90cc21d42cc5f02eb80b2586e5c46d9b .base.RegsMap.bin */
+
+	{S5K6AAFX_REG_W_ADDH, S5K6AAFX_ADDH_SW_REG_INT},
+	{S5K6AAFX_REG_W_ADDL, 0x1D60},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x4936},
+	{S5K6AAFX_REG_WR, 0x4836},
+	{S5K6AAFX_REG_WR, 0x2205},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA4E},
+	{S5K6AAFX_REG_WR, 0x4935},
+	{S5K6AAFX_REG_WR, 0x2002},
+	{S5K6AAFX_REG_WR, 0x83C8},
+	{S5K6AAFX_REG_WR, 0x2001},
+	{S5K6AAFX_REG_WR, 0x3120},
+	{S5K6AAFX_REG_WR, 0x8088},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x8008},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x8048},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x4833},
+	{S5K6AAFX_REG_WR, 0x2204},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA3E},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x4833},
+	{S5K6AAFX_REG_WR, 0x2206},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA39},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x4832},
+	{S5K6AAFX_REG_WR, 0x2207},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA34},
+	{S5K6AAFX_REG_WR, 0x4931},
+	{S5K6AAFX_REG_WR, 0x4832},
+	{S5K6AAFX_REG_WR, 0x2208},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA2F},
+	{S5K6AAFX_REG_WR, 0x4931},
+	{S5K6AAFX_REG_WR, 0x4831},
+	{S5K6AAFX_REG_WR, 0x2209},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA2A},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x4831},
+	{S5K6AAFX_REG_WR, 0x220A},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA25},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x4830},
+	{S5K6AAFX_REG_WR, 0x220B},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA20},
+	{S5K6AAFX_REG_WR, 0x482F},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x6108},
+	{S5K6AAFX_REG_WR, 0x4830},
+	{S5K6AAFX_REG_WR, 0x39FF},
+	{S5K6AAFX_REG_WR, 0x3901},
+	{S5K6AAFX_REG_WR, 0x6748},
+	{S5K6AAFX_REG_WR, 0x482F},
+	{S5K6AAFX_REG_WR, 0x1C0A},
+	{S5K6AAFX_REG_WR, 0x32C0},
+	{S5K6AAFX_REG_WR, 0x6390},
+	{S5K6AAFX_REG_WR, 0x482E},
+	{S5K6AAFX_REG_WR, 0x6708},
+	{S5K6AAFX_REG_WR, 0x491A},
+	{S5K6AAFX_REG_WR, 0x482D},
+	{S5K6AAFX_REG_WR, 0x3108},
+	{S5K6AAFX_REG_WR, 0x60C1},
+	{S5K6AAFX_REG_WR, 0x6882},
+	{S5K6AAFX_REG_WR, 0x1A51},
+	{S5K6AAFX_REG_WR, 0x8201},
+	{S5K6AAFX_REG_WR, 0x4C2B},
+	{S5K6AAFX_REG_WR, 0x2607},
+	{S5K6AAFX_REG_WR, 0x6821},
+	{S5K6AAFX_REG_WR, 0x0736},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA05},
+	{S5K6AAFX_REG_WR, 0x4829},
+	{S5K6AAFX_REG_WR, 0x22D8},
+	{S5K6AAFX_REG_WR, 0x1C05},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA09},
+	{S5K6AAFX_REG_WR, 0x6025},
+	{S5K6AAFX_REG_WR, 0x68A1},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA07},
+	{S5K6AAFX_REG_WR, 0x4825},
+	{S5K6AAFX_REG_WR, 0x2224},
+	{S5K6AAFX_REG_WR, 0x3824},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA00},
+	{S5K6AAFX_REG_WR, 0x4822},
+	{S5K6AAFX_REG_WR, 0x3824},
+	{S5K6AAFX_REG_WR, 0x60A0},
+	{S5K6AAFX_REG_WR, 0x4D22},
+	{S5K6AAFX_REG_WR, 0x6D29},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA07},
+	{S5K6AAFX_REG_WR, 0x481F},
+	{S5K6AAFX_REG_WR, 0x228F},
+	{S5K6AAFX_REG_WR, 0x00D2},
+	{S5K6AAFX_REG_WR, 0x30D8},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9F2},
+	{S5K6AAFX_REG_WR, 0x652C},
+	{S5K6AAFX_REG_WR, 0xBC70},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0x218B},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x127B},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0398},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1376},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2370},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1F0D},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x890D},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1F2F},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x27A9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1FE1},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x27C5},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2043},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x285F},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2003},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x28FF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x20CD},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x6181},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x20EF},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x6663},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2123},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0100},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1EC1},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1EAD},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1F79},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x04AC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x06CC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0704},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9B9},
+	{S5K6AAFX_REG_WR, 0x48C3},
+	{S5K6AAFX_REG_WR, 0x49C3},
+	{S5K6AAFX_REG_WR, 0x8800},
+	{S5K6AAFX_REG_WR, 0x8048},
+	{S5K6AAFX_REG_WR, 0xBC10},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB5F8},
+	{S5K6AAFX_REG_WR, 0x1C06},
+	{S5K6AAFX_REG_WR, 0x4DC0},
+	{S5K6AAFX_REG_WR, 0x68AC},
+	{S5K6AAFX_REG_WR, 0x1C30},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9B3},
+	{S5K6AAFX_REG_WR, 0x68A9},
+	{S5K6AAFX_REG_WR, 0x4ABC},
+	{S5K6AAFX_REG_WR, 0x42A1},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x4BBD},
+	{S5K6AAFX_REG_WR, 0x8A1B},
+	{S5K6AAFX_REG_WR, 0x3301},
+	{S5K6AAFX_REG_WR, 0x8013},
+	{S5K6AAFX_REG_WR, 0x8813},
+	{S5K6AAFX_REG_WR, 0x1C14},
+	{S5K6AAFX_REG_WR, 0x2B00},
+	{S5K6AAFX_REG_WR, 0xD00F},
+	{S5K6AAFX_REG_WR, 0x2201},
+	{S5K6AAFX_REG_WR, 0x4281},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x8C2F},
+	{S5K6AAFX_REG_WR, 0x42B9},
+	{S5K6AAFX_REG_WR, 0xD300},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x60AE},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x8C28},
+	{S5K6AAFX_REG_WR, 0x42B0},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C30},
+	{S5K6AAFX_REG_WR, 0x1E59},
+	{S5K6AAFX_REG_WR, 0x8021},
+	{S5K6AAFX_REG_WR, 0xBCF8},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x48AF},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF997},
+	{S5K6AAFX_REG_WR, 0x4AAD},
+	{S5K6AAFX_REG_WR, 0x4BAE},
+	{S5K6AAFX_REG_WR, 0x8811},
+	{S5K6AAFX_REG_WR, 0x885B},
+	{S5K6AAFX_REG_WR, 0x8852},
+	{S5K6AAFX_REG_WR, 0x4359},
+	{S5K6AAFX_REG_WR, 0x1889},
+	{S5K6AAFX_REG_WR, 0x4288},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C08},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE7C5},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x1C05},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF98F},
+	{S5K6AAFX_REG_WR, 0x49A5},
+	{S5K6AAFX_REG_WR, 0x8989},
+	{S5K6AAFX_REG_WR, 0x4348},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x0349},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF98E},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x489F},
+	{S5K6AAFX_REG_WR, 0x8F80},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF991},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x20FF},
+	{S5K6AAFX_REG_WR, 0x43C0},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF994},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF998},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x4898},
+	{S5K6AAFX_REG_WR, 0x8840},
+	{S5K6AAFX_REG_WR, 0x4360},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF97A},
+	{S5K6AAFX_REG_WR, 0x6028},
+	{S5K6AAFX_REG_WR, 0xBC70},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB5F1},
+	{S5K6AAFX_REG_WR, 0xB082},
+	{S5K6AAFX_REG_WR, 0x4D96},
+	{S5K6AAFX_REG_WR, 0x4E91},
+	{S5K6AAFX_REG_WR, 0x88A8},
+	{S5K6AAFX_REG_WR, 0x1C2C},
+	{S5K6AAFX_REG_WR, 0x3420},
+	{S5K6AAFX_REG_WR, 0x4F90},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD018},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF988},
+	{S5K6AAFX_REG_WR, 0x9001},
+	{S5K6AAFX_REG_WR, 0x9802},
+	{S5K6AAFX_REG_WR, 0x6B39},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF974},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF978},
+	{S5K6AAFX_REG_WR, 0x9901},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF95F},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x8871},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF96A},
+	{S5K6AAFX_REG_WR, 0x0400},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x21FF},
+	{S5K6AAFX_REG_WR, 0x3101},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF97A},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x88E8},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD00A},
+	{S5K6AAFX_REG_WR, 0x4980},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x3128},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF979},
+	{S5K6AAFX_REG_WR, 0x8D38},
+	{S5K6AAFX_REG_WR, 0x8871},
+	{S5K6AAFX_REG_WR, 0x4348},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x8538},
+	{S5K6AAFX_REG_WR, 0xBCFE},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF974},
+	{S5K6AAFX_REG_WR, 0x6821},
+	{S5K6AAFX_REG_WR, 0x0409},
+	{S5K6AAFX_REG_WR, 0x0C09},
+	{S5K6AAFX_REG_WR, 0x1A40},
+	{S5K6AAFX_REG_WR, 0x4976},
+	{S5K6AAFX_REG_WR, 0x6849},
+	{S5K6AAFX_REG_WR, 0x4281},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C08},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF971},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE75B},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x6801},
+	{S5K6AAFX_REG_WR, 0x040D},
+	{S5K6AAFX_REG_WR, 0x0C2D},
+	{S5K6AAFX_REG_WR, 0x6844},
+	{S5K6AAFX_REG_WR, 0x486F},
+	{S5K6AAFX_REG_WR, 0x8981},
+	{S5K6AAFX_REG_WR, 0x1C28},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF927},
+	{S5K6AAFX_REG_WR, 0x8060},
+	{S5K6AAFX_REG_WR, 0x4970},
+	{S5K6AAFX_REG_WR, 0x69C9},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF968},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x80A0},
+	{S5K6AAFX_REG_WR, 0x0228},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF92D},
+	{S5K6AAFX_REG_WR, 0x0400},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x496B},
+	{S5K6AAFX_REG_WR, 0x2300},
+	{S5K6AAFX_REG_WR, 0x5EC9},
+	{S5K6AAFX_REG_WR, 0x4288},
+	{S5K6AAFX_REG_WR, 0xDA02},
+	{S5K6AAFX_REG_WR, 0x20FF},
+	{S5K6AAFX_REG_WR, 0x3001},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE797},
+	{S5K6AAFX_REG_WR, 0xB5F8},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x4867},
+	{S5K6AAFX_REG_WR, 0x4E65},
+	{S5K6AAFX_REG_WR, 0x7800},
+	{S5K6AAFX_REG_WR, 0x6AB7},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD100},
+	{S5K6AAFX_REG_WR, 0x6A37},
+	{S5K6AAFX_REG_WR, 0x495D},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0x688D},
+	{S5K6AAFX_REG_WR, 0xD100},
+	{S5K6AAFX_REG_WR, 0x684D},
+	{S5K6AAFX_REG_WR, 0x4859},
+	{S5K6AAFX_REG_WR, 0x8841},
+	{S5K6AAFX_REG_WR, 0x6820},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF94B},
+	{S5K6AAFX_REG_WR, 0x8DF1},
+	{S5K6AAFX_REG_WR, 0x434F},
+	{S5K6AAFX_REG_WR, 0x0A3A},
+	{S5K6AAFX_REG_WR, 0x4282},
+	{S5K6AAFX_REG_WR, 0xD30C},
+	{S5K6AAFX_REG_WR, 0x4D5C},
+	{S5K6AAFX_REG_WR, 0x26FF},
+	{S5K6AAFX_REG_WR, 0x8829},
+	{S5K6AAFX_REG_WR, 0x3601},
+	{S5K6AAFX_REG_WR, 0x43B1},
+	{S5K6AAFX_REG_WR, 0x8029},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF944},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0x8828},
+	{S5K6AAFX_REG_WR, 0x4330},
+	{S5K6AAFX_REG_WR, 0x8028},
+	{S5K6AAFX_REG_WR, 0xE73B},
+	{S5K6AAFX_REG_WR, 0x1C0A},
+	{S5K6AAFX_REG_WR, 0x436A},
+	{S5K6AAFX_REG_WR, 0x0A12},
+	{S5K6AAFX_REG_WR, 0x4282},
+	{S5K6AAFX_REG_WR, 0xD304},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8F3},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE7F4},
+	{S5K6AAFX_REG_WR, 0x6025},
+	{S5K6AAFX_REG_WR, 0xE7F2},
+	{S5K6AAFX_REG_WR, 0xB410},
+	{S5K6AAFX_REG_WR, 0x4848},
+	{S5K6AAFX_REG_WR, 0x4950},
+	{S5K6AAFX_REG_WR, 0x89C0},
+	{S5K6AAFX_REG_WR, 0x2316},
+	{S5K6AAFX_REG_WR, 0x5ECC},
+	{S5K6AAFX_REG_WR, 0x1C02},
+	{S5K6AAFX_REG_WR, 0x42A0},
+	{S5K6AAFX_REG_WR, 0xDC00},
+	{S5K6AAFX_REG_WR, 0x1C22},
+	{S5K6AAFX_REG_WR, 0x82CA},
+	{S5K6AAFX_REG_WR, 0x2318},
+	{S5K6AAFX_REG_WR, 0x5ECA},
+	{S5K6AAFX_REG_WR, 0x4290},
+	{S5K6AAFX_REG_WR, 0xDC00},
+	{S5K6AAFX_REG_WR, 0x1C10},
+	{S5K6AAFX_REG_WR, 0x8308},
+	{S5K6AAFX_REG_WR, 0xBC10},
+	{S5K6AAFX_REG_WR, 0x4770},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x1C06},
+	{S5K6AAFX_REG_WR, 0x4C45},
+	{S5K6AAFX_REG_WR, 0x2501},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x02AD},
+	{S5K6AAFX_REG_WR, 0x43A8},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF91E},
+	{S5K6AAFX_REG_WR, 0x6030},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFE0},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x4328},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE741},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x4C3D},
+	{S5K6AAFX_REG_WR, 0x2501},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x02ED},
+	{S5K6AAFX_REG_WR, 0x43A8},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF916},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFD1},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x4328},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE732},
+	{S5K6AAFX_REG_WR, 0x230D},
+	{S5K6AAFX_REG_WR, 0x071B},
+	{S5K6AAFX_REG_WR, 0x18C3},
+	{S5K6AAFX_REG_WR, 0x8818},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD001},
+	{S5K6AAFX_REG_WR, 0x4308},
+	{S5K6AAFX_REG_WR, 0xE000},
+	{S5K6AAFX_REG_WR, 0x4388},
+	{S5K6AAFX_REG_WR, 0x8018},
+	{S5K6AAFX_REG_WR, 0x4770},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x2402},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x8809},
+	{S5K6AAFX_REG_WR, 0x078A},
+	{S5K6AAFX_REG_WR, 0xD500},
+	{S5K6AAFX_REG_WR, 0x2406},
+	{S5K6AAFX_REG_WR, 0x2900},
+	{S5K6AAFX_REG_WR, 0xD01F},
+	{S5K6AAFX_REG_WR, 0x1C02},
+	{S5K6AAFX_REG_WR, 0x207D},
+	{S5K6AAFX_REG_WR, 0x00C0},
+	{S5K6AAFX_REG_WR, 0x2600},
+	{S5K6AAFX_REG_WR, 0x4D2D},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD019},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x8229},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8F9},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x482A},
+	{S5K6AAFX_REG_WR, 0x0309},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFDB},
+	{S5K6AAFX_REG_WR, 0x2008},
+	{S5K6AAFX_REG_WR, 0x4304},
+	{S5K6AAFX_REG_WR, 0x1C21},
+	{S5K6AAFX_REG_WR, 0x4C26},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x3C14},
+	{S5K6AAFX_REG_WR, 0x1C20},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFD2},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x2121},
+	{S5K6AAFX_REG_WR, 0x1C20},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFCD},
+	{S5K6AAFX_REG_WR, 0x802E},
+	{S5K6AAFX_REG_WR, 0xE6FD},
+	{S5K6AAFX_REG_WR, 0x822E},
+	{S5K6AAFX_REG_WR, 0x0789},
+	{S5K6AAFX_REG_WR, 0x0FC9},
+	{S5K6AAFX_REG_WR, 0x0089},
+	{S5K6AAFX_REG_WR, 0x223B},
+	{S5K6AAFX_REG_WR, 0x4311},
+	{S5K6AAFX_REG_WR, 0x8029},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8DA},
+	{S5K6AAFX_REG_WR, 0xE7F4},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x491B},
+	{S5K6AAFX_REG_WR, 0x8FC8},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD007},
+	{S5K6AAFX_REG_WR, 0x2000},
+	{S5K6AAFX_REG_WR, 0x87C8},
+	{S5K6AAFX_REG_WR, 0x8F88},
+	{S5K6AAFX_REG_WR, 0x4C19},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD002},
+	{S5K6AAFX_REG_WR, 0x2008},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE689},
+	{S5K6AAFX_REG_WR, 0x4815},
+	{S5K6AAFX_REG_WR, 0x3060},
+	{S5K6AAFX_REG_WR, 0x8900},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD103},
+	{S5K6AAFX_REG_WR, 0x4814},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8CA},
+	{S5K6AAFX_REG_WR, 0x2010},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE7F2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1376},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2370},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x14D8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x235C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xF4B0},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1554},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1AB8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0080},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x046C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0468},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1100},
+	{S5K6AAFX_REG_WR, 0xD000},
+	{S5K6AAFX_REG_WR, 0x198C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0AC4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xB0A0},
+	{S5K6AAFX_REG_WR, 0xD000},
+	{S5K6AAFX_REG_WR, 0xB0B4},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x044E},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0450},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x9CE7},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0x9FB8},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x14C1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27E1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x88DF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x275D},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1ED3},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27C5},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0xA144},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1F87},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27A9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1ECB},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x28FF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x26F9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x4027},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x9F03},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0x9D9C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x285F},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x6181},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x6663},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x85D9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x2001},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xE848},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0xE848},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0500},
+	{S5K6AAFX_REG_WR, 0x0064},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* End T&P part */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const analog_setting_init_tbl[] = {
+	/* Start tuning part */
+
+	/* Analog Settings */
+	{0xF418, 0x0050},
+	{0xF454, 0x0001},
+	{0xF43E, 0x0010},
+
+	{S5K6AAFX_REG_W_ADDL, 0x1106},
+	{S5K6AAFX_REG_WR, 0x00F0},
+	{S5K6AAFX_REG_WR, 0x00F1},
+
+	{S5K6AAFX_REG_W_ADDL, 0x112A},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1132},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x113E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x115C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1164},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1174},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1178},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x2170},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0090},
+
+	{S5K6AAFX_REG_W_ADDL, 0x07A2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x07B6},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0005},
+	{S5K6AAFX_REG_WR, 0x0005},
+	{0x002A, 0x0104},
+	{0x0F12, 0x0C2F},
+	{0x002A, 0x10EA},
+	{0x0F12, 0x007C},
+	{0x1000, 0x0001}, /* Set host interrupt so main start run */
+
+	/* delay 10ms */
+
+};
+
+static const struct s5k6aafx_i2c_reg_conf const register_init_tbl[] = {
+// Start user init script
+
+// End user init script
+
+	/* param_start - TVAR_ash_GASAlpha */
+	/* parawrite _start - TVAR_ash_GASAlpha */
+	{S5K6AAFX_REG_W_ADDL, 0x0712},
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[0] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[1] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[2] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_GASAlpha[3] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[4] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[5] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[6] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[7] */
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_GASAlpha[8] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[9] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[10] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[11] */
+	{S5K6AAFX_REG_WR, 0x00D8}, /* TVAR_ash_GASAlpha[12] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[13] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[14] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[15] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[16] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[17] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[18] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[19] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[20] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[21] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[22] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[23] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[24] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[25] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[26] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[27] */
+	/* parawrite _end - TVAR_ash_GASAlpha */
+
+	/* parawrite _start - TVAR_ash_GASOutdoorAlpha */
+	{S5K6AAFX_REG_W_ADDL, 0x074A},
+	{S5K6AAFX_REG_WR, 0x00FB},	//TVAR_ash_GASOutdoorAlpha[0]
+	{S5K6AAFX_REG_WR, 0x00FF},	//TVAR_ash_GASOutdoorAlpha[1]
+	{S5K6AAFX_REG_WR, 0x00F9},	//TVAR_ash_GASOutdoorAlpha[2]
+	{S5K6AAFX_REG_WR, 0x0104},	//TVAR_ash_GASOutdoorAlpha[3]
+	/* parawrite _end - TVAR_ash_GASOutdoorAlpha */
+
+	{S5K6AAFX_REG_W_ADDL, 0x075A},
+	{S5K6AAFX_REG_WR, 0x0001}, /* ash_bParabolicEstiwrite ation */
+	{S5K6AAFX_REG_WR, 0x0282}, /* ash_uParabolicCenterX */
+	{S5K6AAFX_REG_WR, 0x0216}, /* ash_uParabolicCenterY */
+	{S5K6AAFX_REG_WR, 0x000B}, /* ash_uParabolicScalingA */
+	{S5K6AAFX_REG_WR, 0x000E}, /* ash_uParabolicScalingB */
+
+	/* parawrite _start - TVAR_ash_pGAS */
+	{S5K6AAFX_REG_W_ADDL, 0x247C},
+	{S5K6AAFX_REG_WR, 0x02B2}, /* TVAR_ash_pGAS[0] */
+	{S5K6AAFX_REG_WR, 0x01C3}, /* TVAR_ash_pGAS[1] */
+	{S5K6AAFX_REG_WR, 0x0138}, /* TVAR_ash_pGAS[2] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_pGAS[3] */
+	{S5K6AAFX_REG_WR, 0x00E5}, /* TVAR_ash_pGAS[4] */
+	{S5K6AAFX_REG_WR, 0x00D1}, /* TVAR_ash_pGAS[5] */
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[6] */
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[7] */
+	{S5K6AAFX_REG_WR, 0x00DA}, /* TVAR_ash_pGAS[8] */
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[9] */
+	{S5K6AAFX_REG_WR, 0x0110}, /* TVAR_ash_pGAS[10] */
+	{S5K6AAFX_REG_WR, 0x0179}, /* TVAR_ash_pGAS[11] */
+	{S5K6AAFX_REG_WR, 0x0232}, /* TVAR_ash_pGAS[12] */
+	{S5K6AAFX_REG_WR, 0x01EC}, /* TVAR_ash_pGAS[13] */
+	{S5K6AAFX_REG_WR, 0x0148}, /* TVAR_ash_pGAS[14] */
+	{S5K6AAFX_REG_WR, 0x00F3}, /* TVAR_ash_pGAS[15] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[16] */
+	{S5K6AAFX_REG_WR, 0x00A3}, /* TVAR_ash_pGAS[17] */
+	{S5K6AAFX_REG_WR, 0x0089}, /* TVAR_ash_pGAS[18] */
+	{S5K6AAFX_REG_WR, 0x007A}, /* TVAR_ash_pGAS[19] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[20] */
+	{S5K6AAFX_REG_WR, 0x0093}, /* TVAR_ash_pGAS[21] */
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[22] */
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[23] */
+	{S5K6AAFX_REG_WR, 0x010A}, /* TVAR_ash_pGAS[24] */
+	{S5K6AAFX_REG_WR, 0x0181}, /* TVAR_ash_pGAS[25] */
+	{S5K6AAFX_REG_WR, 0x015D}, /* TVAR_ash_pGAS[26] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[27] */
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[28] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[29] */
+	{S5K6AAFX_REG_WR, 0x0058}, /* TVAR_ash_pGAS[30] */
+	{S5K6AAFX_REG_WR, 0x003F}, /* TVAR_ash_pGAS[31] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[32] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[33] */
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[34] */
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[35] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[36] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[37] */
+	{S5K6AAFX_REG_WR, 0x010A}, /* TVAR_ash_pGAS[38] */
+	{S5K6AAFX_REG_WR, 0x0119}, /* TVAR_ash_pGAS[39] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[40] */
+	{S5K6AAFX_REG_WR, 0x008A}, /* TVAR_ash_pGAS[41] */
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[42] */
+	{S5K6AAFX_REG_WR, 0x0030}, /* TVAR_ash_pGAS[43] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[44] */
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[45] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[46] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[47] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[48] */
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[49] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[50] */
+	{S5K6AAFX_REG_WR, 0x00D2}, /* TVAR_ash_pGAS[51] */
+	{S5K6AAFX_REG_WR, 0x00FA}, /* TVAR_ash_pGAS[52] */
+	{S5K6AAFX_REG_WR, 0x00B7}, /* TVAR_ash_pGAS[53] */
+	{S5K6AAFX_REG_WR, 0x0073}, /* TVAR_ash_pGAS[54] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[55] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[56] */
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[57] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[58] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[59] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[60] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[61] */
+	{S5K6AAFX_REG_WR, 0x0045}, /* TVAR_ash_pGAS[62] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[63] */
+	{S5K6AAFX_REG_WR, 0x00BA}, /* TVAR_ash_pGAS[64] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[65] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[66] */
+	{S5K6AAFX_REG_WR, 0x006B}, /* TVAR_ash_pGAS[67] */
+	{S5K6AAFX_REG_WR, 0x0034}, /* TVAR_ash_pGAS[68] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[69] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[70] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[71] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[72] */
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[73] */
+	{S5K6AAFX_REG_WR, 0x0018}, /* TVAR_ash_pGAS[74] */
+	{S5K6AAFX_REG_WR, 0x003F}, /* TVAR_ash_pGAS[75] */
+	{S5K6AAFX_REG_WR, 0x0080}, /* TVAR_ash_pGAS[76] */
+	{S5K6AAFX_REG_WR, 0x00BA}, /* TVAR_ash_pGAS[77] */
+	{S5K6AAFX_REG_WR, 0x00FD}, /* TVAR_ash_pGAS[78] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[79] */
+	{S5K6AAFX_REG_WR, 0x0075}, /* TVAR_ash_pGAS[80] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[81] */
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[82] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[83] */
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[84] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[85] */
+	{S5K6AAFX_REG_WR, 0x000D}, /* TVAR_ash_pGAS[86] */
+	{S5K6AAFX_REG_WR, 0x0022}, /* TVAR_ash_pGAS[87] */
+	{S5K6AAFX_REG_WR, 0x004C}, /* TVAR_ash_pGAS[88] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[89] */
+	{S5K6AAFX_REG_WR, 0x00CB}, /* TVAR_ash_pGAS[90] */
+	{S5K6AAFX_REG_WR, 0x0121}, /* TVAR_ash_pGAS[91] */
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[92] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[93] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[94] */
+	{S5K6AAFX_REG_WR, 0x002C}, /* TVAR_ash_pGAS[95] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[96] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[97] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[98] */
+	{S5K6AAFX_REG_WR, 0x001E}, /* TVAR_ash_pGAS[99] */
+	{S5K6AAFX_REG_WR, 0x003B}, /* TVAR_ash_pGAS[100] */
+	{S5K6AAFX_REG_WR, 0x006D}, /* TVAR_ash_pGAS[101] */
+	{S5K6AAFX_REG_WR, 0x00AE}, /* TVAR_ash_pGAS[102] */
+	{S5K6AAFX_REG_WR, 0x00F0}, /* TVAR_ash_pGAS[103] */
+	{S5K6AAFX_REG_WR, 0x0163}, /* TVAR_ash_pGAS[104] */
+	{S5K6AAFX_REG_WR, 0x0107}, /* TVAR_ash_pGAS[105] */
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[106] */
+	{S5K6AAFX_REG_WR, 0x0085}, /* TVAR_ash_pGAS[107] */
+	{S5K6AAFX_REG_WR, 0x0053}, /* TVAR_ash_pGAS[108] */
+	{S5K6AAFX_REG_WR, 0x0034}, /* TVAR_ash_pGAS[109] */
+	{S5K6AAFX_REG_WR, 0x0029}, /* TVAR_ash_pGAS[110] */
+	{S5K6AAFX_REG_WR, 0x002F}, /* TVAR_ash_pGAS[111] */
+	{S5K6AAFX_REG_WR, 0x0042}, /* TVAR_ash_pGAS[112] */
+	{S5K6AAFX_REG_WR, 0x0066}, /* TVAR_ash_pGAS[113] */
+	{S5K6AAFX_REG_WR, 0x009E}, /* TVAR_ash_pGAS[114] */
+	{S5K6AAFX_REG_WR, 0x00DC}, /* TVAR_ash_pGAS[115] */
+	{S5K6AAFX_REG_WR, 0x012D}, /* TVAR_ash_pGAS[116] */
+	{S5K6AAFX_REG_WR, 0x01E1}, /* TVAR_ash_pGAS[117] */
+	{S5K6AAFX_REG_WR, 0x014C}, /* TVAR_ash_pGAS[118] */
+	{S5K6AAFX_REG_WR, 0x0102}, /* TVAR_ash_pGAS[119] */
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[120] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[121] */
+	{S5K6AAFX_REG_WR, 0x0072}, /* TVAR_ash_pGAS[122] */
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[123] */
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[124] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[125] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[126] */
+	{S5K6AAFX_REG_WR, 0x00D7}, /* TVAR_ash_pGAS[127] */
+	{S5K6AAFX_REG_WR, 0x011B}, /* TVAR_ash_pGAS[128] */
+	{S5K6AAFX_REG_WR, 0x0196}, /* TVAR_ash_pGAS[129] */
+	{S5K6AAFX_REG_WR, 0x029C}, /* TVAR_ash_pGAS[130] */
+	{S5K6AAFX_REG_WR, 0x01C0}, /* TVAR_ash_pGAS[131] */
+	{S5K6AAFX_REG_WR, 0x0144}, /* TVAR_ash_pGAS[132] */
+	{S5K6AAFX_REG_WR, 0x0108}, /* TVAR_ash_pGAS[133] */
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[134] */
+	{S5K6AAFX_REG_WR, 0x00BB}, /* TVAR_ash_pGAS[135] */
+	{S5K6AAFX_REG_WR, 0x00AB}, /* TVAR_ash_pGAS[136] */
+	{S5K6AAFX_REG_WR, 0x00AC}, /* TVAR_ash_pGAS[137] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[138] */
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[139] */
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[140] */
+	{S5K6AAFX_REG_WR, 0x017B}, /* TVAR_ash_pGAS[141] */
+	{S5K6AAFX_REG_WR, 0x0222}, /* TVAR_ash_pGAS[142] */
+	{S5K6AAFX_REG_WR, 0x0281}, /* TVAR_ash_pGAS[143] */
+	{S5K6AAFX_REG_WR, 0x019C}, /* TVAR_ash_pGAS[144] */
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[145] */
+	{S5K6AAFX_REG_WR, 0x00E7}, /* TVAR_ash_pGAS[146] */
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[147] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[148] */
+	{S5K6AAFX_REG_WR, 0x00B3}, /* TVAR_ash_pGAS[149] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[150] */
+	{S5K6AAFX_REG_WR, 0x00BA}, /* TVAR_ash_pGAS[151] */
+	{S5K6AAFX_REG_WR, 0x00C7}, /* TVAR_ash_pGAS[152] */
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[153] */
+	{S5K6AAFX_REG_WR, 0x0139}, /* TVAR_ash_pGAS[154] */
+	{S5K6AAFX_REG_WR, 0x01E4}, /* TVAR_ash_pGAS[155] */
+	{S5K6AAFX_REG_WR, 0x01B4}, /* TVAR_ash_pGAS[156] */
+	{S5K6AAFX_REG_WR, 0x011D}, /* TVAR_ash_pGAS[157] */
+	{S5K6AAFX_REG_WR, 0x00D8}, /* TVAR_ash_pGAS[158] */
+	{S5K6AAFX_REG_WR, 0x00B4}, /* TVAR_ash_pGAS[159] */
+	{S5K6AAFX_REG_WR, 0x0093}, /* TVAR_ash_pGAS[160] */
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[161] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[162] */
+	{S5K6AAFX_REG_WR, 0x0072}, /* TVAR_ash_pGAS[163] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[164] */
+	{S5K6AAFX_REG_WR, 0x0091}, /* TVAR_ash_pGAS[165] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[166] */
+	{S5K6AAFX_REG_WR, 0x00D6}, /* TVAR_ash_pGAS[167] */
+	{S5K6AAFX_REG_WR, 0x0142}, /* TVAR_ash_pGAS[168] */
+	{S5K6AAFX_REG_WR, 0x013A}, /* TVAR_ash_pGAS[169] */
+	{S5K6AAFX_REG_WR, 0x00D3}, /* TVAR_ash_pGAS[170] */
+	{S5K6AAFX_REG_WR, 0x00AA}, /* TVAR_ash_pGAS[171] */
+	{S5K6AAFX_REG_WR, 0x007C}, /* TVAR_ash_pGAS[172] */
+	{S5K6AAFX_REG_WR, 0x0055}, /* TVAR_ash_pGAS[173] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[174] */
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[175] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[176] */
+	{S5K6AAFX_REG_WR, 0x0044}, /* TVAR_ash_pGAS[177] */
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[178] */
+	{S5K6AAFX_REG_WR, 0x007A}, /* TVAR_ash_pGAS[179] */
+	{S5K6AAFX_REG_WR, 0x009E}, /* TVAR_ash_pGAS[180] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[181] */
+	{S5K6AAFX_REG_WR, 0x00F9}, /* TVAR_ash_pGAS[182] */
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[183] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[184] */
+	{S5K6AAFX_REG_WR, 0x0052}, /* TVAR_ash_pGAS[185] */
+	{S5K6AAFX_REG_WR, 0x002D}, /* TVAR_ash_pGAS[186] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[187] */
+	{S5K6AAFX_REG_WR, 0x0013}, /* TVAR_ash_pGAS[188] */
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[189] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[190] */
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[191] */
+	{S5K6AAFX_REG_WR, 0x0055}, /* TVAR_ash_pGAS[192] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[193] */
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[194] */
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[195] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[196] */
+	{S5K6AAFX_REG_WR, 0x006C}, /* TVAR_ash_pGAS[197] */
+	{S5K6AAFX_REG_WR, 0x0039}, /* TVAR_ash_pGAS[198] */
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[199] */
+	{S5K6AAFX_REG_WR, 0x000D}, /* TVAR_ash_pGAS[200] */
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[201] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[202] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[203] */
+	{S5K6AAFX_REG_WR, 0x0018}, /* TVAR_ash_pGAS[204] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[205] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[206] */
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[207] */
+	{S5K6AAFX_REG_WR, 0x00DA}, /* TVAR_ash_pGAS[208] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[209] */
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[210] */
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[211] */
+	{S5K6AAFX_REG_WR, 0x0015}, /* TVAR_ash_pGAS[212] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[213] */
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[214] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[215] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[216] */
+	{S5K6AAFX_REG_WR, 0x0014}, /* TVAR_ash_pGAS[217] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[218] */
+	{S5K6AAFX_REG_WR, 0x006D}, /* TVAR_ash_pGAS[219] */
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[220] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[221] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[222] */
+	{S5K6AAFX_REG_WR, 0x006B}, /* TVAR_ash_pGAS[223] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[224] */
+	{S5K6AAFX_REG_WR, 0x0019}, /* TVAR_ash_pGAS[225] */
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[226] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[227] */
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[228] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[229] */
+	{S5K6AAFX_REG_WR, 0x001D}, /* TVAR_ash_pGAS[230] */
+	{S5K6AAFX_REG_WR, 0x0043}, /* TVAR_ash_pGAS[231] */
+	{S5K6AAFX_REG_WR, 0x0075}, /* TVAR_ash_pGAS[232] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[233] */
+	{S5K6AAFX_REG_WR, 0x00FA}, /* TVAR_ash_pGAS[234] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[235] */
+	{S5K6AAFX_REG_WR, 0x0087}, /* TVAR_ash_pGAS[236] */
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[237] */
+	{S5K6AAFX_REG_WR, 0x0028}, /* TVAR_ash_pGAS[238] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[239] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[240] */
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[241] */
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[242] */
+	{S5K6AAFX_REG_WR, 0x0033}, /* TVAR_ash_pGAS[243] */
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[244] */
+	{S5K6AAFX_REG_WR, 0x008F}, /* TVAR_ash_pGAS[245] */
+	{S5K6AAFX_REG_WR, 0x00C2}, /* TVAR_ash_pGAS[246] */
+	{S5K6AAFX_REG_WR, 0x0132}, /* TVAR_ash_pGAS[247] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[248] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[249] */
+	{S5K6AAFX_REG_WR, 0x0077}, /* TVAR_ash_pGAS[250] */
+	{S5K6AAFX_REG_WR, 0x004A}, /* TVAR_ash_pGAS[251] */
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[252] */
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[253] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[254] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[255] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[256] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[257] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[258] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[259] */
+	{S5K6AAFX_REG_WR, 0x019B}, /* TVAR_ash_pGAS[260] */
+	{S5K6AAFX_REG_WR, 0x0117}, /* TVAR_ash_pGAS[261] */
+	{S5K6AAFX_REG_WR, 0x00D9}, /* TVAR_ash_pGAS[262] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[263] */
+	{S5K6AAFX_REG_WR, 0x0085}, /* TVAR_ash_pGAS[264] */
+	{S5K6AAFX_REG_WR, 0x0067}, /* TVAR_ash_pGAS[265] */
+	{S5K6AAFX_REG_WR, 0x0059}, /* TVAR_ash_pGAS[266] */
+	{S5K6AAFX_REG_WR, 0x005C}, /* TVAR_ash_pGAS[267] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[268] */
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[269] */
+	{S5K6AAFX_REG_WR, 0x00AE}, /* TVAR_ash_pGAS[270] */
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[271] */
+	{S5K6AAFX_REG_WR, 0x0146}, /* TVAR_ash_pGAS[272] */
+	{S5K6AAFX_REG_WR, 0x0249}, /* TVAR_ash_pGAS[273] */
+	{S5K6AAFX_REG_WR, 0x017C}, /* TVAR_ash_pGAS[274] */
+	{S5K6AAFX_REG_WR, 0x010F}, /* TVAR_ash_pGAS[275] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[276] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[277] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[278] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[279] */
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[280] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[281] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[282] */
+	{S5K6AAFX_REG_WR, 0x00E3}, /* TVAR_ash_pGAS[283] */
+	{S5K6AAFX_REG_WR, 0x012E}, /* TVAR_ash_pGAS[284] */
+	{S5K6AAFX_REG_WR, 0x01BF}, /* TVAR_ash_pGAS[285] */
+	{S5K6AAFX_REG_WR, 0x0289}, /* TVAR_ash_pGAS[286] */
+	{S5K6AAFX_REG_WR, 0x019B}, /* TVAR_ash_pGAS[287] */
+	{S5K6AAFX_REG_WR, 0x0116}, /* TVAR_ash_pGAS[288] */
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[289] */
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[290] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[291] */
+	{S5K6AAFX_REG_WR, 0x009D}, /* TVAR_ash_pGAS[292] */
+	{S5K6AAFX_REG_WR, 0x00A4}, /* TVAR_ash_pGAS[293] */
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[294] */
+	{S5K6AAFX_REG_WR, 0x00D8}, /* TVAR_ash_pGAS[295] */
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[296] */
+	{S5K6AAFX_REG_WR, 0x0175}, /* TVAR_ash_pGAS[297] */
+	{S5K6AAFX_REG_WR, 0x0239}, /* TVAR_ash_pGAS[298] */
+	{S5K6AAFX_REG_WR, 0x01C5}, /* TVAR_ash_pGAS[299] */
+	{S5K6AAFX_REG_WR, 0x0125}, /* TVAR_ash_pGAS[300] */
+	{S5K6AAFX_REG_WR, 0x00D9}, /* TVAR_ash_pGAS[301] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[302] */
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[303] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[304] */
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[305] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[306] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[307] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[308] */
+	{S5K6AAFX_REG_WR, 0x00CD}, /* TVAR_ash_pGAS[309] */
+	{S5K6AAFX_REG_WR, 0x010D}, /* TVAR_ash_pGAS[310] */
+	{S5K6AAFX_REG_WR, 0x0189}, /* TVAR_ash_pGAS[311] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* TVAR_ash_pGAS[312] */
+	{S5K6AAFX_REG_WR, 0x00DF}, /* TVAR_ash_pGAS[313] */
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[314] */
+	{S5K6AAFX_REG_WR, 0x007D}, /* TVAR_ash_pGAS[315] */
+	{S5K6AAFX_REG_WR, 0x0050}, /* TVAR_ash_pGAS[316] */
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[317] */
+	{S5K6AAFX_REG_WR, 0x002D}, /* TVAR_ash_pGAS[318] */
+	{S5K6AAFX_REG_WR, 0x0032}, /* TVAR_ash_pGAS[319] */
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[320] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[321] */
+	{S5K6AAFX_REG_WR, 0x009F}, /* TVAR_ash_pGAS[322] */
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[323] */
+	{S5K6AAFX_REG_WR, 0x0118}, /* TVAR_ash_pGAS[324] */
+	{S5K6AAFX_REG_WR, 0x010C}, /* TVAR_ash_pGAS[325] */
+	{S5K6AAFX_REG_WR, 0x00C3}, /* TVAR_ash_pGAS[326] */
+	{S5K6AAFX_REG_WR, 0x008C}, /* TVAR_ash_pGAS[327] */
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[328] */
+	{S5K6AAFX_REG_WR, 0x002D}, /* TVAR_ash_pGAS[329] */
+	{S5K6AAFX_REG_WR, 0x0017}, /* TVAR_ash_pGAS[330] */
+	{S5K6AAFX_REG_WR, 0x000D}, /* TVAR_ash_pGAS[331] */
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[332] */
+	{S5K6AAFX_REG_WR, 0x001F}, /* TVAR_ash_pGAS[333] */
+	{S5K6AAFX_REG_WR, 0x0040}, /* TVAR_ash_pGAS[334] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[335] */
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[336] */
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[337] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[338] */
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[339] */
+	{S5K6AAFX_REG_WR, 0x0078}, /* TVAR_ash_pGAS[340] */
+	{S5K6AAFX_REG_WR, 0x003E}, /* TVAR_ash_pGAS[341] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[342] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[343] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[344] */
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[345] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[346] */
+	{S5K6AAFX_REG_WR, 0x001F}, /* TVAR_ash_pGAS[347] */
+	{S5K6AAFX_REG_WR, 0x004B}, /* TVAR_ash_pGAS[348] */
+	{S5K6AAFX_REG_WR, 0x0088}, /* TVAR_ash_pGAS[349] */
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[350] */
+	{S5K6AAFX_REG_WR, 0x00EA}, /* TVAR_ash_pGAS[351] */
+	{S5K6AAFX_REG_WR, 0x00B4}, /* TVAR_ash_pGAS[352] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[353] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[354] */
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[355] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[356] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[357] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[358] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[359] */
+	{S5K6AAFX_REG_WR, 0x0013}, /* TVAR_ash_pGAS[360] */
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[361] */
+	{S5K6AAFX_REG_WR, 0x0071}, /* TVAR_ash_pGAS[362] */
+	{S5K6AAFX_REG_WR, 0x00A0}, /* TVAR_ash_pGAS[363] */
+	{S5K6AAFX_REG_WR, 0x00F1}, /* TVAR_ash_pGAS[364] */
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[365] */
+	{S5K6AAFX_REG_WR, 0x0076}, /* TVAR_ash_pGAS[366] */
+	{S5K6AAFX_REG_WR, 0x003E}, /* TVAR_ash_pGAS[367] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[368] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[369] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[370] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[371] */
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[372] */
+	{S5K6AAFX_REG_WR, 0x0014}, /* TVAR_ash_pGAS[373] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[374] */
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[375] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[376] */
+	{S5K6AAFX_REG_WR, 0x010B}, /* TVAR_ash_pGAS[377] */
+	{S5K6AAFX_REG_WR, 0x00CC}, /* TVAR_ash_pGAS[378] */
+	{S5K6AAFX_REG_WR, 0x0093}, /* TVAR_ash_pGAS[379] */
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[380] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[381] */
+	{S5K6AAFX_REG_WR, 0x0015}, /* TVAR_ash_pGAS[382] */
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[383] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[384] */
+	{S5K6AAFX_REG_WR, 0x000E}, /* TVAR_ash_pGAS[385] */
+	{S5K6AAFX_REG_WR, 0x0021}, /* TVAR_ash_pGAS[386] */
+	{S5K6AAFX_REG_WR, 0x0043}, /* TVAR_ash_pGAS[387] */
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[388] */
+	{S5K6AAFX_REG_WR, 0x00A0}, /* TVAR_ash_pGAS[389] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* TVAR_ash_pGAS[390] */
+	{S5K6AAFX_REG_WR, 0x00EB}, /* TVAR_ash_pGAS[391] */
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[392] */
+	{S5K6AAFX_REG_WR, 0x007E}, /* TVAR_ash_pGAS[393] */
+	{S5K6AAFX_REG_WR, 0x004E}, /* TVAR_ash_pGAS[394] */
+	{S5K6AAFX_REG_WR, 0x002F}, /* TVAR_ash_pGAS[395] */
+	{S5K6AAFX_REG_WR, 0x0021}, /* TVAR_ash_pGAS[396] */
+	{S5K6AAFX_REG_WR, 0x0020}, /* TVAR_ash_pGAS[397] */
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[398] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[399] */
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[400] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[401] */
+	{S5K6AAFX_REG_WR, 0x00BD}, /* TVAR_ash_pGAS[402] */
+	{S5K6AAFX_REG_WR, 0x01AD}, /* TVAR_ash_pGAS[403] */
+	{S5K6AAFX_REG_WR, 0x0122}, /* TVAR_ash_pGAS[404] */
+	{S5K6AAFX_REG_WR, 0x00E3}, /* TVAR_ash_pGAS[405] */
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[406] */
+	{S5K6AAFX_REG_WR, 0x0087}, /* TVAR_ash_pGAS[407] */
+	{S5K6AAFX_REG_WR, 0x0064}, /* TVAR_ash_pGAS[408] */
+	{S5K6AAFX_REG_WR, 0x0051}, /* TVAR_ash_pGAS[409] */
+	{S5K6AAFX_REG_WR, 0x004E}, /* TVAR_ash_pGAS[410] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[411] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[412] */
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[413] */
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[414] */
+	{S5K6AAFX_REG_WR, 0x0101}, /* TVAR_ash_pGAS[415] */
+	{S5K6AAFX_REG_WR, 0x0267}, /* TVAR_ash_pGAS[416] */
+	{S5K6AAFX_REG_WR, 0x018C}, /* TVAR_ash_pGAS[417] */
+	{S5K6AAFX_REG_WR, 0x0119}, /* TVAR_ash_pGAS[418] */
+	{S5K6AAFX_REG_WR, 0x00E5}, /* TVAR_ash_pGAS[419] */
+	{S5K6AAFX_REG_WR, 0x00C2}, /* TVAR_ash_pGAS[420] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[421] */
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[422] */
+	{S5K6AAFX_REG_WR, 0x0086}, /* TVAR_ash_pGAS[423] */
+	{S5K6AAFX_REG_WR, 0x008C}, /* TVAR_ash_pGAS[424] */
+	{S5K6AAFX_REG_WR, 0x0099}, /* TVAR_ash_pGAS[425] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[426] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[427] */
+	{S5K6AAFX_REG_WR, 0x016C}, /* TVAR_ash_pGAS[428] */
+	{S5K6AAFX_REG_WR, 0x01F3}, /* TVAR_ash_pGAS[429] */
+	{S5K6AAFX_REG_WR, 0x0136}, /* TVAR_ash_pGAS[430] */
+	{S5K6AAFX_REG_WR, 0x00D6}, /* TVAR_ash_pGAS[431] */
+	{S5K6AAFX_REG_WR, 0x00B3}, /* TVAR_ash_pGAS[432] */
+	{S5K6AAFX_REG_WR, 0x00A1}, /* TVAR_ash_pGAS[433] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[434] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[435] */
+	{S5K6AAFX_REG_WR, 0x0098}, /* TVAR_ash_pGAS[436] */
+	{S5K6AAFX_REG_WR, 0x00AD}, /* TVAR_ash_pGAS[437] */
+	{S5K6AAFX_REG_WR, 0x00C5}, /* TVAR_ash_pGAS[438] */
+	{S5K6AAFX_REG_WR, 0x00ED}, /* TVAR_ash_pGAS[439] */
+	{S5K6AAFX_REG_WR, 0x014D}, /* TVAR_ash_pGAS[440] */
+	{S5K6AAFX_REG_WR, 0x0207}, /* TVAR_ash_pGAS[441] */
+	{S5K6AAFX_REG_WR, 0x014C}, /* TVAR_ash_pGAS[442] */
+	{S5K6AAFX_REG_WR, 0x00D1}, /* TVAR_ash_pGAS[443] */
+	{S5K6AAFX_REG_WR, 0x00A4}, /* TVAR_ash_pGAS[444] */
+	{S5K6AAFX_REG_WR, 0x0091}, /* TVAR_ash_pGAS[445] */
+	{S5K6AAFX_REG_WR, 0x0077}, /* TVAR_ash_pGAS[446] */
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[447] */
+	{S5K6AAFX_REG_WR, 0x005E}, /* TVAR_ash_pGAS[448] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[449] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[450] */
+	{S5K6AAFX_REG_WR, 0x009F}, /* TVAR_ash_pGAS[451] */
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[452] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[453] */
+	{S5K6AAFX_REG_WR, 0x0162}, /* TVAR_ash_pGAS[454] */
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[455] */
+	{S5K6AAFX_REG_WR, 0x008C}, /* TVAR_ash_pGAS[456] */
+	{S5K6AAFX_REG_WR, 0x0079}, /* TVAR_ash_pGAS[457] */
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[458] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[459] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[460] */
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[461] */
+	{S5K6AAFX_REG_WR, 0x0033}, /* TVAR_ash_pGAS[462] */
+	{S5K6AAFX_REG_WR, 0x004A}, /* TVAR_ash_pGAS[463] */
+	{S5K6AAFX_REG_WR, 0x006A}, /* TVAR_ash_pGAS[464] */
+	{S5K6AAFX_REG_WR, 0x0092}, /* TVAR_ash_pGAS[465] */
+	{S5K6AAFX_REG_WR, 0x00B2}, /* TVAR_ash_pGAS[466] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[467] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[468] */
+	{S5K6AAFX_REG_WR, 0x0072}, /* TVAR_ash_pGAS[469] */
+	{S5K6AAFX_REG_WR, 0x0059}, /* TVAR_ash_pGAS[470] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[471] */
+	{S5K6AAFX_REG_WR, 0x001E}, /* TVAR_ash_pGAS[472] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[473] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[474] */
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[475] */
+	{S5K6AAFX_REG_WR, 0x0020}, /* TVAR_ash_pGAS[476] */
+	{S5K6AAFX_REG_WR, 0x003B}, /* TVAR_ash_pGAS[477] */
+	{S5K6AAFX_REG_WR, 0x005E}, /* TVAR_ash_pGAS[478] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[479] */
+	{S5K6AAFX_REG_WR, 0x00AD}, /* TVAR_ash_pGAS[480] */
+	{S5K6AAFX_REG_WR, 0x008B}, /* TVAR_ash_pGAS[481] */
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[482] */
+	{S5K6AAFX_REG_WR, 0x0045}, /* TVAR_ash_pGAS[483] */
+	{S5K6AAFX_REG_WR, 0x0024}, /* TVAR_ash_pGAS[484] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[485] */
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[486] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[487] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[488] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[489] */
+	{S5K6AAFX_REG_WR, 0x0017}, /* TVAR_ash_pGAS[490] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[491] */
+	{S5K6AAFX_REG_WR, 0x0060}, /* TVAR_ash_pGAS[492] */
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[493] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[494] */
+	{S5K6AAFX_REG_WR, 0x0060}, /* TVAR_ash_pGAS[495] */
+	{S5K6AAFX_REG_WR, 0x003D}, /* TVAR_ash_pGAS[496] */
+	{S5K6AAFX_REG_WR, 0x001D}, /* TVAR_ash_pGAS[497] */
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[498] */
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[499] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[500] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[501] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[502] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[503] */
+	{S5K6AAFX_REG_WR, 0x0022}, /* TVAR_ash_pGAS[504] */
+	{S5K6AAFX_REG_WR, 0x0047}, /* TVAR_ash_pGAS[505] */
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[506] */
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[507] */
+	{S5K6AAFX_REG_WR, 0x0064}, /* TVAR_ash_pGAS[508] */
+	{S5K6AAFX_REG_WR, 0x0042}, /* TVAR_ash_pGAS[509] */
+	{S5K6AAFX_REG_WR, 0x0023}, /* TVAR_ash_pGAS[510] */
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[511] */
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[512] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* TVAR_ash_pGAS[513] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[514] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* TVAR_ash_pGAS[515] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[516] */
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[517] */
+	{S5K6AAFX_REG_WR, 0x0039}, /* TVAR_ash_pGAS[518] */
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[519] */
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[520] */
+	{S5K6AAFX_REG_WR, 0x0076}, /* TVAR_ash_pGAS[521] */
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[522] */
+	{S5K6AAFX_REG_WR, 0x0037}, /* TVAR_ash_pGAS[523] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[524] */
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[525] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[526] */
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[527] */
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[528] */
+	{S5K6AAFX_REG_WR, 0x0011}, /* TVAR_ash_pGAS[529] */
+	{S5K6AAFX_REG_WR, 0x0025}, /* TVAR_ash_pGAS[530] */
+	{S5K6AAFX_REG_WR, 0x003E}, /* TVAR_ash_pGAS[531] */
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[532] */
+	{S5K6AAFX_REG_WR, 0x00D0}, /* TVAR_ash_pGAS[533] */
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[534] */
+	{S5K6AAFX_REG_WR, 0x007E}, /* TVAR_ash_pGAS[535] */
+	{S5K6AAFX_REG_WR, 0x005C}, /* TVAR_ash_pGAS[536] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[537] */
+	{S5K6AAFX_REG_WR, 0x0025}, /* TVAR_ash_pGAS[538] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[539] */
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[540] */
+	{S5K6AAFX_REG_WR, 0x001E}, /* TVAR_ash_pGAS[541] */
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[542] */
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[543] */
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[544] */
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[545] */
+	{S5K6AAFX_REG_WR, 0x012F}, /* TVAR_ash_pGAS[546] */
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_pGAS[547] */
+	{S5K6AAFX_REG_WR, 0x00A7}, /* TVAR_ash_pGAS[548] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[549] */
+	{S5K6AAFX_REG_WR, 0x006F}, /* TVAR_ash_pGAS[550] */
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[551] */
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[552] */
+	{S5K6AAFX_REG_WR, 0x0047}, /* TVAR_ash_pGAS[553] */
+	{S5K6AAFX_REG_WR, 0x0049}, /* TVAR_ash_pGAS[554] */
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[555] */
+	{S5K6AAFX_REG_WR, 0x0058}, /* TVAR_ash_pGAS[556] */
+	{S5K6AAFX_REG_WR, 0x006E}, /* TVAR_ash_pGAS[557] */
+	{S5K6AAFX_REG_WR, 0x00B9}, /* TVAR_ash_pGAS[558] */
+	{S5K6AAFX_REG_WR, 0x01CB}, /* TVAR_ash_pGAS[559] */
+	{S5K6AAFX_REG_WR, 0x0123}, /* TVAR_ash_pGAS[560] */
+	{S5K6AAFX_REG_WR, 0x00D5}, /* TVAR_ash_pGAS[561] */
+	{S5K6AAFX_REG_WR, 0x00B9}, /* TVAR_ash_pGAS[562] */
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[563] */
+	{S5K6AAFX_REG_WR, 0x008E}, /* TVAR_ash_pGAS[564] */
+	{S5K6AAFX_REG_WR, 0x0080}, /* TVAR_ash_pGAS[565] */
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[566] */
+	{S5K6AAFX_REG_WR, 0x0079}, /* TVAR_ash_pGAS[567] */
+	{S5K6AAFX_REG_WR, 0x0078}, /* TVAR_ash_pGAS[568] */
+	{S5K6AAFX_REG_WR, 0x0081}, /* TVAR_ash_pGAS[569] */
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[570] */
+	{S5K6AAFX_REG_WR, 0x0108}, /* TVAR_ash_pGAS[571] */
+	/* parawrite _end - TVAR_ash_pGAS */
+
+	{S5K6AAFX_REG_W_ADDL, 0x0C48},
+	{S5K6AAFX_REG_WR, 0x0550}, /* R*/
+	{S5K6AAFX_REG_WR, 0x0400}, /* G*/
+	{S5K6AAFX_REG_WR, 0x0600}, /*B */
+
+#if 0
+	{S5K6AAFX_REG_W_ADDL, 0x0F12},
+	{S5K6AAFX_REG_WR, 0x02C9}, /* awbb_GLocusR */
+	{S5K6AAFX_REG_WR, 0x033F}, /* awbb_GLocusB */
+#endif
+
+	/* param_start - TVAR_ash_AwbAshCord */
+	{S5K6AAFX_REG_W_ADDL, 0x0704},
+	{S5K6AAFX_REG_WR, 0x00ED/*0x00C7*/}, /* TVAR_ash_AwbAshCord[0] */
+	{S5K6AAFX_REG_WR, 0x0124/*0x00F7*/}, /* TVAR_ash_AwbAshCord[1] */
+	{S5K6AAFX_REG_WR, 0x012B/*0x0107*/}, /* TVAR_ash_AwbAshCord[2] */
+	{S5K6AAFX_REG_WR, 0x014A/*0x0142*/}, /* TVAR_ash_AwbAshCord[3] */
+	{S5K6AAFX_REG_WR, 0x0190/*0x017A*/}, /* TVAR_ash_AwbAshCord[4] */
+	{S5K6AAFX_REG_WR, 0x01B2/*0x01A0*/}, /* TVAR_ash_AwbAshCord[5] */
+	{S5K6AAFX_REG_WR, 0x01C4/*0x01B6*/}, /* TVAR_ash_AwbAshCord[6] */
+	/* param_end - TVAR_ash_AwbAshCord */
+
+	{S5K6AAFX_REG_W_ADDL, 0x0754},
+	{S5K6AAFX_REG_WR, 0x247C},
+	{S5K6AAFX_REG_WR, 0x7000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0E1A},
+	{S5K6AAFX_REG_WR, 0x0138},
+
+	/* AWB Speed */
+	{S5K6AAFX_REG_W_ADDL, 0x0E7C},
+	{S5K6AAFX_REG_WR, 0x0010},
+	{S5K6AAFX_REG_WR, 0x0003},
+
+	/* param_start - awbb_IndoorGrZones_m_BGrid */
+	{S5K6AAFX_REG_W_ADDL, 0x0C50},
+	{S5K6AAFX_REG_WR, 0x03BA},
+	{S5K6AAFX_REG_WR, 0x03E3},
+	{S5K6AAFX_REG_WR, 0x039A},
+	{S5K6AAFX_REG_WR, 0x03DB},
+	{S5K6AAFX_REG_WR, 0x037B},
+	{S5K6AAFX_REG_WR, 0x03CD},
+	{S5K6AAFX_REG_WR, 0x035D},
+	{S5K6AAFX_REG_WR, 0x03B2},
+	{S5K6AAFX_REG_WR, 0x0342},
+	{S5K6AAFX_REG_WR, 0x0397},
+	{S5K6AAFX_REG_WR, 0x0325},
+	{S5K6AAFX_REG_WR, 0x0380},
+	{S5K6AAFX_REG_WR, 0x030E},
+	{S5K6AAFX_REG_WR, 0x0369},
+	{S5K6AAFX_REG_WR, 0x02F8},
+	{S5K6AAFX_REG_WR, 0x034B},
+	{S5K6AAFX_REG_WR, 0x02DE},
+	{S5K6AAFX_REG_WR, 0x0336},
+	{S5K6AAFX_REG_WR, 0x02BF},
+	{S5K6AAFX_REG_WR, 0x031F},
+	{S5K6AAFX_REG_WR, 0x02A6},
+	{S5K6AAFX_REG_WR, 0x0306},
+	{S5K6AAFX_REG_WR, 0x028D},
+	{S5K6AAFX_REG_WR, 0x02F4},
+	{S5K6AAFX_REG_WR, 0x027D},
+	{S5K6AAFX_REG_WR, 0x02DD},
+	{S5K6AAFX_REG_WR, 0x026C},
+	{S5K6AAFX_REG_WR, 0x02C2},
+	{S5K6AAFX_REG_WR, 0x025C},
+	{S5K6AAFX_REG_WR, 0x02AE},
+	{S5K6AAFX_REG_WR, 0x024F},
+	{S5K6AAFX_REG_WR, 0x029D},
+	{S5K6AAFX_REG_WR, 0x0245},
+	{S5K6AAFX_REG_WR, 0x028B},
+	{S5K6AAFX_REG_WR, 0x023E},
+	{S5K6AAFX_REG_WR, 0x027F},
+	{S5K6AAFX_REG_WR, 0x0235},
+	{S5K6AAFX_REG_WR, 0x0272},
+	{S5K6AAFX_REG_WR, 0x022B},
+	{S5K6AAFX_REG_WR, 0x0267},
+	{S5K6AAFX_REG_WR, 0x0220},
+	{S5K6AAFX_REG_WR, 0x025B},
+	{S5K6AAFX_REG_WR, 0x0218},
+	{S5K6AAFX_REG_WR, 0x0250},
+	{S5K6AAFX_REG_WR, 0x020E},
+	{S5K6AAFX_REG_WR, 0x0246},
+	{S5K6AAFX_REG_WR, 0x0206},
+	{S5K6AAFX_REG_WR, 0x023D},
+	{S5K6AAFX_REG_WR, 0x01FB},
+	{S5K6AAFX_REG_WR, 0x0234},
+	{S5K6AAFX_REG_WR, 0x01F1},
+	{S5K6AAFX_REG_WR, 0x0229},
+	{S5K6AAFX_REG_WR, 0x01E7},
+	{S5K6AAFX_REG_WR, 0x0220},
+	{S5K6AAFX_REG_WR, 0x01DF},
+	{S5K6AAFX_REG_WR, 0x0216},
+	{S5K6AAFX_REG_WR, 0x01D2},
+	{S5K6AAFX_REG_WR, 0x020D},
+	{S5K6AAFX_REG_WR, 0x01C7},
+	{S5K6AAFX_REG_WR, 0x01FD},
+	{S5K6AAFX_REG_WR, 0x01C4},
+	{S5K6AAFX_REG_WR, 0x01EE},
+	{S5K6AAFX_REG_WR, 0x01D1},
+	{S5K6AAFX_REG_WR, 0x01E1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* param_end - awbb_IndoorGrZones_m_BGrid */
+
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0CF8},
+	{S5K6AAFX_REG_WR, 0x010F},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+
+	/* param_start - SARR_usGammaLutRGBIndoor */
+	{S5K6AAFX_REG_W_ADDL, 0x04C8},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x000E},
+	{S5K6AAFX_REG_WR, 0x002C},
+	{S5K6AAFX_REG_WR, 0x006C},
+	{S5K6AAFX_REG_WR, 0x00D1},
+	{S5K6AAFX_REG_WR, 0x0123},
+	{S5K6AAFX_REG_WR, 0x0164},
+	{S5K6AAFX_REG_WR, 0x01CA},
+	{S5K6AAFX_REG_WR, 0x021B},
+	{S5K6AAFX_REG_WR, 0x028C},
+	{S5K6AAFX_REG_WR, 0x02E7},
+	{S5K6AAFX_REG_WR, 0x0339},
+	{S5K6AAFX_REG_WR, 0x0377},
+	{S5K6AAFX_REG_WR, 0x03BE},
+	{S5K6AAFX_REG_WR, 0x03FF},
+
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x000E},
+	{S5K6AAFX_REG_WR, 0x002C},
+	{S5K6AAFX_REG_WR, 0x006C},
+	{S5K6AAFX_REG_WR, 0x00D1},
+	{S5K6AAFX_REG_WR, 0x0123},
+	{S5K6AAFX_REG_WR, 0x0164},
+	{S5K6AAFX_REG_WR, 0x01CA},
+	{S5K6AAFX_REG_WR, 0x021B},
+	{S5K6AAFX_REG_WR, 0x028C},
+	{S5K6AAFX_REG_WR, 0x02E7},
+	{S5K6AAFX_REG_WR, 0x0339},
+	{S5K6AAFX_REG_WR, 0x0377},
+	{S5K6AAFX_REG_WR, 0x03BE},
+	{S5K6AAFX_REG_WR, 0x03FF},
+
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x000E},
+	{S5K6AAFX_REG_WR, 0x002C},
+	{S5K6AAFX_REG_WR, 0x006C},
+	{S5K6AAFX_REG_WR, 0x00D1},
+	{S5K6AAFX_REG_WR, 0x0123},
+	{S5K6AAFX_REG_WR, 0x0164},
+	{S5K6AAFX_REG_WR, 0x01CA},
+	{S5K6AAFX_REG_WR, 0x021B},
+	{S5K6AAFX_REG_WR, 0x028C},
+	{S5K6AAFX_REG_WR, 0x02E7},
+	{S5K6AAFX_REG_WR, 0x0339},
+	{S5K6AAFX_REG_WR, 0x0377},
+	{S5K6AAFX_REG_WR, 0x03BE},
+	{S5K6AAFX_REG_WR, 0x03FF},
+	/* param_end - SARR_usGammaLutRGBIndoor */
+
+
+	{S5K6AAFX_REG_W_ADDL, 0x1000},
+	{S5K6AAFX_REG_WR, 0x003F},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0474},
+	{S5K6AAFX_REG_WR, 0x0112/*0x010F*//*0x0114*/},
+	{S5K6AAFX_REG_WR, 0x00EF/*0x00F1*//*0x00F9*/},
+
+	{S5K6AAFX_REG_W_ADDL, 0x2180},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x1006},
+	{S5K6AAFX_REG_WR, 0x001F},
+
+	{S5K6AAFX_REG_W_ADDL, 0x108E},
+	{S5K6AAFX_REG_WR, 0x00C7},
+	{S5K6AAFX_REG_WR, 0x00F7},
+	{S5K6AAFX_REG_WR, 0x0107},
+	{S5K6AAFX_REG_WR, 0x0142},
+	{S5K6AAFX_REG_WR, 0x017A},
+	{S5K6AAFX_REG_WR, 0x01A0},
+	{S5K6AAFX_REG_WR, 0x01B6},
+
+	{S5K6AAFX_REG_WR, 0x0100/*0x0112*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0122*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0136*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x00F6*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0100*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x00FE*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0100*/},
+
+	/* param_start - TVAR_wbt_pBaseCcms */
+	{S5K6AAFX_REG_W_ADDL, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x01FA}, /* H */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* A */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* WW */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* CW */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x02A3/*0x020E*/}, /* D50 */
+	{S5K6AAFX_REG_WR, 0xFFB1/*0xFFAE*/},
+	{S5K6AAFX_REG_WR, 0x0018/*0xFFE6*/},
+	{S5K6AAFX_REG_WR, 0x00D2/*0x00D2*/},
+	{S5K6AAFX_REG_WR, 0x0109/*0x0105*/},
+	{S5K6AAFX_REG_WR, 0xFF3A/*0xFF39*/},
+	{S5K6AAFX_REG_WR, 0xFE66/*0xFE4F*/},
+	{S5K6AAFX_REG_WR, 0x017A/*0x0268*/},
+	{S5K6AAFX_REG_WR, 0xFF8A/*0xFFA4*/},
+	{S5K6AAFX_REG_WR, 0xFD89/*0xFEC3*/},
+	{S5K6AAFX_REG_WR, 0x0224/*0x0204*/},
+	{S5K6AAFX_REG_WR, 0x0162/*0x0092*/},
+	{S5K6AAFX_REG_WR, 0x0000/*0xFFB3*/},
+	{S5K6AAFX_REG_WR, 0xFF8F/*0xFF87*/},
+	{S5K6AAFX_REG_WR, 0x015F/*0x01C7*/},
+	{S5K6AAFX_REG_WR, 0x035D/*0x026D*/},
+	{S5K6AAFX_REG_WR, 0xFF67/*0xFF32*/},
+	{S5K6AAFX_REG_WR, 0x01E2/*0x0106*/},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* D65 */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+	/* param_end - TVAR_wbt_pBaseCcms */
+
+	/* param_start - TVAR_wbt_pOutdoorCcm */
+	{S5K6AAFX_REG_W_ADDL, 0x2380},
+	{S5K6AAFX_REG_WR, 0x01F2/*0x01F2*//*0x019D*/}, /* TVAR_wbt_pOutdoorCcm[0] */
+	{S5K6AAFX_REG_WR, 0xFFC3/*0xFFc3*//*0xFFC8*/}, /* TVAR_wbt_pOutdoorCcm[1] */
+	{S5K6AAFX_REG_WR, 0xFFE3/*0xFFe3*//*0x000C*/}, /* TVAR_wbt_pOutdoorCcm[2] */
+	{S5K6AAFX_REG_WR, 0x00F9/*0x00F9*//*0x008D*/}, /* TVAR_wbt_pOutdoorCcm[3] */
+	{S5K6AAFX_REG_WR, 0x013F/*0x013F*//*0x00CD*/}, /* TVAR_wbt_pOutdoorCcm[4] */
+	{S5K6AAFX_REG_WR, 0xFF6E/*0xFF6E*//*0xFF3F*/}, /* TVAR_wbt_pOutdoorCcm[5] */
+	{S5K6AAFX_REG_WR, 0xFEBB/*0xFEbb*//*0xFEDD*/}, /* TVAR_wbt_pOutdoorCcm[6] */
+	{S5K6AAFX_REG_WR, 0x01F2/*0x01F2*//*0x01C6*/}, /* TVAR_wbt_pOutdoorCcm[7] */
+	{S5K6AAFX_REG_WR, 0xFEFA/*0xFEFA*//*0xFF77*/}, /* TVAR_wbt_pOutdoorCcm[8] */
+	{S5K6AAFX_REG_WR, 0xFF37/*0xFF37*//*0xFEAB*/}, /* TVAR_wbt_pOutdoorCcm[9] */
+	{S5K6AAFX_REG_WR, 0x01A2/*0x01A2*//*0x015D*/}, /* TVAR_wbt_pOutdoorCcm[10] */
+	{S5K6AAFX_REG_WR, 0x0126/*0x0126*//*0x0082*/}, /* TVAR_wbt_pOutdoorCcm[11] */
+	{S5K6AAFX_REG_WR, 0xFFE0/*0xFFE0*//*0xFFCA*/}, /* TVAR_wbt_pOutdoorCcm[12] */
+	{S5K6AAFX_REG_WR, 0xFFBF/*0xFFBF*//*0xFFA2*/}, /* TVAR_wbt_pOutdoorCcm[13] */
+	{S5K6AAFX_REG_WR, 0x01E6/*0x01E6*//*0x016F*/}, /* TVAR_wbt_pOutdoorCcm[14] */
+	{S5K6AAFX_REG_WR, 0x0186/*0x0186*//*0x0171*/}, /* TVAR_wbt_pOutdoorCcm[15] */
+	{S5K6AAFX_REG_WR, 0xFF4B/*0xFF4B*//*0xFF35*/}, /* TVAR_wbt_pOutdoorCcm[16] */
+	{S5K6AAFX_REG_WR, 0x01B1/*0x01B1*//*0x013E*/}, /* TVAR_wbt_pOutdoorCcm[17] */
+	/* param_end - TVAR_wbt_pOutdoorCcm */
+
+	{S5K6AAFX_REG_W_ADDL, 0x06D4},
+	{S5K6AAFX_REG_WR, 0x2380},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_W_ADDL, 0x06CC},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_W_ADDL, 0x06E8},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23C8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23EC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2410},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2434},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2458},
+	{S5K6AAFX_REG_WR, 0x7000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x06DA},
+	{S5K6AAFX_REG_WR, 0x00BF}, /* SARR_AwbCcmCord[0] */
+	{S5K6AAFX_REG_WR, 0x00E6}, /* SARR_AwbCcmCord[1] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* SARR_AwbCcmCord[2] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* SARR_AwbCcmCord[3] */
+	{S5K6AAFX_REG_WR, 0x0178}, /* SARR_AwbCcmCord[4] */
+	{S5K6AAFX_REG_WR, 0x01A3}, /* SARR_AwbCcmCord[5] */
+
+	/* param_start - SARR_uNormBrInDoor */
+	{S5K6AAFX_REG_W_ADDL, 0x07E8},
+	{S5K6AAFX_REG_WR, 0x0016/*0x000A*/}, /* SARR_uNormBrInDoor[0] */
+	{S5K6AAFX_REG_WR, 0x0028/*0x0019*/}, /* SARR_uNormBrInDoor[1] */
+	{S5K6AAFX_REG_WR, 0x0096/*0x0096*/}, /* SARR_uNormBrInDoor[2] */
+	{S5K6AAFX_REG_WR, 0x01F4/*0x01F4*/}, /* SARR_uNormBrInDoor[3] */
+	{S5K6AAFX_REG_WR, 0x07D0/*0x07D0*/}, /* SARR_uNormBrInDoor[4] */
+	/* param_end - SARR_uNormBrInDoor */
+
+	/* param_start - afit_uNoiseIndInDoor */
+	{S5K6AAFX_REG_W_ADDL, 0x07D0},
+	{S5K6AAFX_REG_WR, 0x0030}, /* afit_uNoiseIndInDoor[0] */
+	{S5K6AAFX_REG_WR, 0x0046}, /* afit_uNoiseIndInDoor[1] */
+	{S5K6AAFX_REG_WR, 0x0088}, /* afit_uNoiseIndInDoor[2] */
+	{S5K6AAFX_REG_WR, 0x0205}, /* afit_uNoiseIndInDoor[3] */
+	{S5K6AAFX_REG_WR, 0x02BC}, /* afit_uNoiseIndInDoor[4] */
+	/* param_end - afit_uNoiseIndInDoor */
+
+	{S5K6AAFX_REG_W_ADDL, 0x07E6},
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_bUseNoiseInd */
+
+	/* param_start - TVAR_afit_pBaseVals */
+	{S5K6AAFX_REG_W_ADDL, 0x0828},
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[0]     70000828 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[1]     7000082A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[2]     7000082C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[3]     7000082E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[4]     70000830 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[5]     70000832 */
+	{S5K6AAFX_REG_WR, 0x0021}, /*TVAR_afit_pBaseVals[6]     70000834 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[7]     70000836 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[8]     70000838 */
+	{S5K6AAFX_REG_WR, 0x00FF}, /*TVAR_afit_pBaseVals[9]     7000083A */
+	{S5K6AAFX_REG_WR, 0x0129}, /*TVAR_afit_pBaseVals[10]    7000083C */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[11]    7000083E */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[12]    70000840 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[13]    70000842 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[14]    70000844 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[15]    70000846 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[16]    70000848 */
+	{S5K6AAFX_REG_WR, 0x0344}, /*TVAR_afit_pBaseVals[17]    7000084A */
+	{S5K6AAFX_REG_WR, 0x033A}, /*TVAR_afit_pBaseVals[18]    7000084C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[19]    7000084E */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[20]    70000850 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[21]    70000852 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[22]    70000854 */
+	{S5K6AAFX_REG_WR, 0x001E}, /*TVAR_afit_pBaseVals[23]    70000856 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[24]    70000858 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[25]    7000085A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[26]    7000085C */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[27]    7000085E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[28]    70000860 */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[29]    70000862 */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[30]    70000864 */
+	{S5K6AAFX_REG_WR, 0x0C0F}, /*TVAR_afit_pBaseVals[31]    70000866 */
+	{S5K6AAFX_REG_WR, 0x0C0F}, /*TVAR_afit_pBaseVals[32]    70000868 */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[33]    7000086A */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[34]    7000086C */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[35]    7000086E */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[36]    70000870 */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[37]    70000872 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[38]    70000874 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[39]    70000876 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[40]    70000878 */
+	{S5K6AAFX_REG_WR, 0x0E08}, /*TVAR_afit_pBaseVals[41]    7000087A */
+	{S5K6AAFX_REG_WR, 0x030A}, /*TVAR_afit_pBaseVals[42]    7000087C */
+	{S5K6AAFX_REG_WR, 0x0A03}, /*TVAR_afit_pBaseVals[43]    7000087E */
+	{S5K6AAFX_REG_WR, 0x0A11}, /*TVAR_afit_pBaseVals[44]    70000880 */
+	{S5K6AAFX_REG_WR, 0x000F}, /*TVAR_afit_pBaseVals[45]    70000882 */
+	{S5K6AAFX_REG_WR, 0x0500}, /*TVAR_afit_pBaseVals[46]    70000884 */
+	{S5K6AAFX_REG_WR, 0x0914}, /*TVAR_afit_pBaseVals[47]    70000886 */
+	{S5K6AAFX_REG_WR, 0x0012}, /*TVAR_afit_pBaseVals[48]    70000888 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[49]    7000088A */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[50]    7000088C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[51]    7000088E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[52]    70000890 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[53]    70000892 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[54]    70000894 */
+	{S5K6AAFX_REG_WR, 0x0A00}, /*TVAR_afit_pBaseVals[55]    70000896 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[56]    70000898 */
+	{S5K6AAFX_REG_WR, 0x014C}, /*TVAR_afit_pBaseVals[57]    7000089A */
+	{S5K6AAFX_REG_WR, 0x014D}, /*TVAR_afit_pBaseVals[58]    7000089C */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[59]    7000089E */
+	{S5K6AAFX_REG_WR, 0xA020/*0x8020*/}, /*TVAR_afit_pBaseVals[60]    700008A0 */ //CKLIN_20100908 White level low brightness 2.5 pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[61]    700008A2 */
+	{S5K6AAFX_REG_WR, 0x0001/*0x000A*/}, /*TVAR_afit_pBaseVals[62]    700008A4 */ //CKLIN_20100908 Black Noise pass
+
+	{S5K6AAFX_REG_WR, 0xFFFE}, /*TVAR_afit_pBaseVals[63]    700008A6 */
+	{S5K6AAFX_REG_WR, 0xFFEC}, /*TVAR_afit_pBaseVals[64]    700008A8 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[65]    700008AA */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[66]    700008AC */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[67]    700008AE */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[68]    700008B0 */
+	{S5K6AAFX_REG_WR, 0x000C}, /*TVAR_afit_pBaseVals[69]    700008B2 */
+	{S5K6AAFX_REG_WR, 0x000E}, /*TVAR_afit_pBaseVals[70]    700008B4 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[71]    700008B6 */
+	{S5K6AAFX_REG_WR, 0x00FF}, /*TVAR_afit_pBaseVals[72]    700008B8 */
+	{S5K6AAFX_REG_WR, 0x0129}, /*TVAR_afit_pBaseVals[73]    700008BA */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[74]    700008BC */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[75]    700008BE */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[76]    700008C0 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[77]    700008C2 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[78]    700008C4 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[79]    700008C6 */
+	{S5K6AAFX_REG_WR, 0x0114}, /*TVAR_afit_pBaseVals[80]    700008C8 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[81]    700008CA */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[82]    700008CC */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[83]    700008CE */
+	{S5K6AAFX_REG_WR, 0x0018}, /*TVAR_afit_pBaseVals[84]    700008D0 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[85]    700008D2 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[86]    700008D4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[87]    700008D6 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[88]    700008D8 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[89]    700008DA */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[90]    700008DC */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[91]    700008DE */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[92]    700008E0 */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[93]    700008E2 */
+	{S5K6AAFX_REG_WR, 0x050F}, /*TVAR_afit_pBaseVals[94]    700008E4 */
+	{S5K6AAFX_REG_WR, 0x0A1F}, /*TVAR_afit_pBaseVals[95]    700008E6 */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[96]    700008E8 */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[97]    700008EA */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[98]    700008EC */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[99]    700008EE */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[100]   700008F0 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[101]   700008F2 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[102]   700008F4 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[103]   700008F6 */
+	{S5K6AAFX_REG_WR, 0x0E08}, /*TVAR_afit_pBaseVals[104]   700008F8 */
+	{S5K6AAFX_REG_WR, 0x030A}, /*TVAR_afit_pBaseVals[105]   700008FA */
+	{S5K6AAFX_REG_WR, 0x1403}, /*TVAR_afit_pBaseVals[106]   700008FC */
+	{S5K6AAFX_REG_WR, 0x0A11}, /*TVAR_afit_pBaseVals[107]   700008FE */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[108]   70000900 */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[109]   70000902 */
+	{S5K6AAFX_REG_WR, 0x101E}, /*TVAR_afit_pBaseVals[110]   70000904 */
+	{S5K6AAFX_REG_WR, 0x101E}, /*TVAR_afit_pBaseVals[111]   70000906 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[112]   70000908 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[113]   7000090A */
+	{S5K6AAFX_REG_WR, 0x0400}, /*TVAR_afit_pBaseVals[114]   7000090C */
+	{S5K6AAFX_REG_WR, 0x0400}, /*TVAR_afit_pBaseVals[115]   7000090E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[116]   70000910 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[117]   70000912 */
+	{S5K6AAFX_REG_WR, 0x0A00}, /*TVAR_afit_pBaseVals[118]   70000914 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[119]   70000916 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[120]   70000918 */
+	{S5K6AAFX_REG_WR, 0x0151}, /*TVAR_afit_pBaseVals[121]   7000091A */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[122]   7000091C */
+	{S5K6AAFX_REG_WR, 0x9820}, /*TVAR_afit_pBaseVals[123]   7000091E */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[124]   70000920 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[125]   70000922 */
+
+	{S5K6AAFX_REG_WR, 0xFFFB}, /*TVAR_afit_pBaseVals[126]   70000924 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[127]   70000926 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[128]   70000928 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[129]   7000092A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[130]   7000092C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[131]   7000092E */
+	{S5K6AAFX_REG_WR, 0x0008}, /*TVAR_afit_pBaseVals[132]   70000930 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[133]   70000932 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[134]   70000934 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[135]   70000936 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[136]   70000938 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[137]   7000093A */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[138]   7000093C */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[139]   7000093E */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[140]   70000940 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[141]   70000942 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[142]   70000944 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[143]   70000946 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[144]   70000948 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[145]   7000094A */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[146]   7000094C */
+	{S5K6AAFX_REG_WR, 0x001C}, /*TVAR_afit_pBaseVals[147]   7000094E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[148]   70000950 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[149]   70000952 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[150]   70000954 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[151]   70000956 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[152]   70000958 */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[153]   7000095A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[154]   7000095C */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[155]   7000095E */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[156]   70000960 */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[157]   70000962 */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[158]   70000964 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[159]   70000966 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[160]   70000968 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[161]   7000096A */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[162]   7000096C */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[163]   7000096E */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[164]   70000970 */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[165]   70000972 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[166]   70000974 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[167]   70000976 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[168]   70000978 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[169]   7000097A */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[170]   7000097C */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[171]   7000097E */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[172]   70000980 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[173]   70000982 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[174]   70000984 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[175]   70000986 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[176]   70000988 */
+	{S5K6AAFX_REG_WR, 0x0403}, /*TVAR_afit_pBaseVals[177]   7000098A */
+	{S5K6AAFX_REG_WR, 0x0402}, /*TVAR_afit_pBaseVals[178]   7000098C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[179]   7000098E */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[180]   70000990 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[181]   70000992 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[182]   70000994 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[183]   70000996 */
+	{S5K6AAFX_REG_WR, 0x0170}, /*TVAR_afit_pBaseVals[184]   70000998 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[185]   7000099A */
+	{S5K6AAFX_REG_WR, 0x8050/*0x8030*/}, /*TVAR_afit_pBaseVals[186]   7000099C */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[187]   7000099E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[188]   700009A0 */
+
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[189]   700009A2 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[190]   700009A4 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[191]   700009A6 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[192]   700009A8 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[193]   700009AA */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[194]   700009AC */
+	{S5K6AAFX_REG_WR, 0x0008}, /*TVAR_afit_pBaseVals[195]   700009AE */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[196]   700009B0 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[197]   700009B2 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[198]   700009B4 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[199]   700009B6 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[200]   700009B8 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[201]   700009BA */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[202]   700009BC */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[203]   700009BE */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[204]   700009C0 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[205]   700009C2 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[206]   700009C4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[207]   700009C6 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[208]   700009C8 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[209]   700009CA */
+	{S5K6AAFX_REG_WR, 0x001C}, /*TVAR_afit_pBaseVals[210]   700009CC */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[211]   700009CE */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[212]   700009D0 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[213]   700009D2 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[214]   700009D4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[215]   700009D6 */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[216]   700009D8 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[217]   700009DA */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[218]   700009DC */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[219]   700009DE */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[220]   700009E0 */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[221]   700009E2 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[222]   700009E4 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[223]   700009E6 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[224]   700009E8 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[225]   700009EA */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[226]   700009EC */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[227]   700009EE */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[228]   700009F0 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[229]   700009F2 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[230]   700009F4 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[231]   700009F6 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[232]   700009F8 */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[233]   700009FA */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[234]   700009FC */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[235]   700009FE */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[236]   70000A00 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[237]   70000A02 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[238]   70000A04 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[239]   70000A06 */
+	{S5K6AAFX_REG_WR, 0x0403}, /*TVAR_afit_pBaseVals[240]   70000A08 */
+	{S5K6AAFX_REG_WR, 0x0402}, /*TVAR_afit_pBaseVals[241]   70000A0A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[242]   70000A0C */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[243]   70000A0E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[244]   70000A10 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[245]   70000A12 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[246]   70000A14 */
+	{S5K6AAFX_REG_WR, 0x0175}, /*TVAR_afit_pBaseVals[247]   70000A16 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[248]   70000A18 */
+	{S5K6AAFX_REG_WR, 0x8070/*0x8068*/}, /*TVAR_afit_pBaseVals[249]   70000A1A */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[250]   70000A1C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[251]   70000A1E */
+
+	{S5K6AAFX_REG_WR, 0x0032/*0x0000*/}, /*TVAR_afit_pBaseVals[252]   70000A20 */ //CKLIN_20100908 White level high brightness 286~2292 pass
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[253]   70000A22 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[254]   70000A24 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[255]   70000A26 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[256]   70000A28 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[257]   70000A2A */
+	{S5K6AAFX_REG_WR, 0x000E}, /*TVAR_afit_pBaseVals[258]   70000A2C */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[259]   70000A2E */
+	{S5K6AAFX_REG_WR, 0x0020}, /*TVAR_afit_pBaseVals[260]   70000A30 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[261]   70000A32 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[262]   70000A34 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[263]   70000A36 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[264]   70000A38 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[265]   70000A3A */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[266]   70000A3C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[267]   70000A3E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[268]   70000A40 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[269]   70000A42 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[270]   70000A44 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[271]   70000A46 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[272]   70000A48 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[273]   70000A4A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[274]   70000A4C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[275]   70000A4E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[276]   70000A50 */
+	{S5K6AAFX_REG_WR, 0x0020}, /*TVAR_afit_pBaseVals[277]   70000A52 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[278]   70000A54 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[279]   70000A56 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[280]   70000A58 */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[281]   70000A5A */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[282]   70000A5C */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[283]   70000A5E */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[284]   70000A60 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[285]   70000A62 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[286]   70000A64 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[287]   70000A66 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[288]   70000A68 */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[289]   70000A6A */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[290]   70000A6C */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[291]   70000A6E */
+	{S5K6AAFX_REG_WR, 0x0880}, /*TVAR_afit_pBaseVals[292]   70000A70 */
+	{S5K6AAFX_REG_WR, 0x000F}, /*TVAR_afit_pBaseVals[293]   70000A72 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[294]   70000A74 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[295]   70000A76 */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[296]   70000A78 */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[297]   70000A7A */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[298]   70000A7C */
+	{S5K6AAFX_REG_WR, 0x2020}, /*TVAR_afit_pBaseVals[299]   70000A7E */
+	{S5K6AAFX_REG_WR, 0x2020}, /*TVAR_afit_pBaseVals[300]   70000A80 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[301]   70000A82 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[302]   70000A84 */
+	{S5K6AAFX_REG_WR, 0x0408}, /*TVAR_afit_pBaseVals[303]   70000A86 */
+	{S5K6AAFX_REG_WR, 0x0406}, /*TVAR_afit_pBaseVals[304]   70000A88 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[305]   70000A8A */
+	{S5K6AAFX_REG_WR, 0x0608}, /*TVAR_afit_pBaseVals[306]   70000A8C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[307]   70000A8E */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[308]   70000A90 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[309]   70000A92 */
+	{S5K6AAFX_REG_WR, 0x0175}, /*TVAR_afit_pBaseVals[310]   70000A94 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[311]   70000A96 */
+	{S5K6AAFX_REG_WR, 0x7058/*0x7050*/}, /*TVAR_afit_pBaseVals[312]   70000A98 */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[313]   70000A9A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[314]   70000A9C */
+	/* param_end - TVAR_afit_pBaseVals */
+
+	/* param_start - afit_pConstBaseVals */
+	{S5K6AAFX_REG_WR, 0x00FF}, /* afit_pConstBaseVals[0] */
+	{S5K6AAFX_REG_WR, 0x00FF}, /* afit_pConstBaseVals[1] */
+	{S5K6AAFX_REG_WR, 0x0800}, /* afit_pConstBaseVals[2] */
+	{S5K6AAFX_REG_WR, 0x0600}, /* afit_pConstBaseVals[3] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[4] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[5] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[6] */
+	{S5K6AAFX_REG_WR, 0x0300}, /* afit_pConstBaseVals[7] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* afit_pConstBaseVals[8] */
+	{S5K6AAFX_REG_WR, 0x0400}, /* afit_pConstBaseVals[9] */
+	{S5K6AAFX_REG_WR, 0x0106}, /* afit_pConstBaseVals[10] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* afit_pConstBaseVals[11] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[12] */
+	{S5K6AAFX_REG_WR, 0x0703}, /* afit_pConstBaseVals[13] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[14] */
+	{S5K6AAFX_REG_WR, 0xFFD6}, /* afit_pConstBaseVals[15] */
+	{S5K6AAFX_REG_WR, 0x53C1}, /* afit_pConstBaseVals[16] */
+	{S5K6AAFX_REG_WR, 0xE1FE}, /* afit_pConstBaseVals[17] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* afit_pConstBaseVals[18] */
+	/* param_end - afit_pConstBaseVals */
+
+
+	{S5K6AAFX_REG_W_ADDL, 0x0488},
+	{S5K6AAFX_REG_WR, 0x416E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xA316},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x2174},
+	{S5K6AAFX_REG_WR, 0xF424},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0490},
+	{S5K6AAFX_REG_WR, 0x416E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xA316},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x2178},
+	{S5K6AAFX_REG_WR, 0xF424},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0498},
+	{S5K6AAFX_REG_WR, 0x01E8},
+	{S5K6AAFX_REG_WR, 0x0310/*0x0270*/},
+	{S5K6AAFX_REG_W_ADDL, 0x217C},
+	{S5K6AAFX_REG_WR, 0x0580},
+	{S5K6AAFX_REG_W_ADDL, 0x049C},
+	{S5K6AAFX_REG_WR, 0x0160},
+
+
+	/* WRITE #AWBBTune_EVT4_uMaxExp3     0000 */
+	/* WRITE #AWBBTune_EVT4_uCapMaxExp3  0000 */
+	/* WRITE #AWBBTune_EVT4_uMaxAnGain3  0000 */
+
+	{S5K6AAFX_REG_W_ADDL, 0x2170},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0090},
+
+	/* AE Weight */
+	{S5K6AAFX_REG_W_ADDL, 0x100E},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+};
+
+static const struct s5k6aafx_i2c_reg_conf const clk_init_tbl[] = {
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0002}, /* PLL configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1770}, /* 1st system CLK 24MHz */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 24MHz output clock */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 2nd system CLK */
+	{S5K6AAFX_REG_WR, 0x1B58},
+	{S5K6AAFX_REG_WR, 0x36B0},
+	{S5K6AAFX_REG_WR, 0x36B0},
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 100ms */
+};
+
+
+static const struct s5k6aafx_i2c_reg_conf const mipi_clk_init_tbl[] = {
+	/* MIPI Setting */
+	{S5K6AAFX_REG_W_ADDL, 0x03FA},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_EnMipiLanes */
+	{S5K6AAFX_REG_WR, 0x00C3}, /* REG_TC_OIF_EnPackets */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_CfgChanged */
+
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0000}, /* REG_TC_IPRM_UseNPviClocks */
+	{S5K6AAFX_REG_WR, 0x0002}, /* REG_TC_IPRM_UseNMipiClocks - 1 MIPI configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1B58}, /* 1st system CLK 24MHz *//*VGA*/
+	{S5K6AAFX_REG_WR, 0x30D4}, /* 48MHz output clock */
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x1B58}, /* 2nd system CLK *//*HD*/
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 134ms */
+};
+
+
+static const struct s5k6aafx_i2c_reg_conf const clk_init_tb2[] = {
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0002}, /* PLL configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1770}, /* 1st system CLK 24MHz */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 24MHz output clock */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 2nd system CLK */
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_snap_conf_init_tbl[] = {
+	/* PREVIEW CONFIGURATION 3 (VGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x02B4},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x02C0},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x02BA},
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMaxOut4KHzRate *//*VGA*/
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMinOut4KHzRate *//*VGA*/
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x0001}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x02C2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x02C6},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0168},
+	{S5K6AAFX_REG_W_ADDL, 0x02D4},/* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003},/* 0x02D4 value */
+	{S5K6AAFX_REG_WR, 0x0003},/* 0x02D4 value */
+
+	/* PREVIEW CONFIGURATION 1 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0268},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x0274},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x026E},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0278},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0276},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x027A},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0288}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+
+	/* PREVIEW CONFIGURATION 0 (1280X720, YUV) */
+	/* HD Mode */
+	{S5K6AAFX_REG_W_ADDL, 0x0242},
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_WIDTH}, /* REG_0TC_PCFG_usWidth X=1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_HEIGHT}, /* REG_0TC_PCFG_usHeight Y=720 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x024E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0248},
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMaxOut4KHzRate *//*HD*/
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMinOut4KHzRate *//*HD*/
+	{S5K6AAFX_REG_WR, 0x0042}, /* REG_0TC_PCFG_PVIMask */
+	{S5K6AAFX_REG_W_ADDL, 0x0252},
+	{S5K6AAFX_REG_WR, 0x0002}, /* REG_0TC_PCFG_FrRateQualityType */
+	{S5K6AAFX_REG_W_ADDL, 0x0250},
+	{S5K6AAFX_REG_WR, 0x0002}, /* REG_0TC_PCFG_usFrTimeType */
+	{S5K6AAFX_REG_W_ADDL, 0x0254},
+	{S5K6AAFX_REG_WR, 0x029A}, /* REG_0TC_PCFG_usMaxFrTimeMsecMult10 */
+	{S5K6AAFX_REG_WR, 0x0000}, /* REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{S5K6AAFX_REG_W_ADDL, 0x0262}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0262 value */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0262 value */
+#if 0
+	/* Preview */
+	{S5K6AAFX_REG_W_ADDL, 0x03B6},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x03FA},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_EnMipiLanes */
+	{S5K6AAFX_REG_WR, 0x00C3}, /* REG_TC_OIF_EnPackets */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_CfgChanged */
+#endif
+
+	/* CAPTURE CONFIGURATION 0 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x030E},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT}, /* 1024 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x031A},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0314},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x031E},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x031C},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x0320},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* CAPTURE CONFIGURATION 1 (1280X720, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0330},
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_HEIGHT}, /* 720 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x033C},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0336},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0340},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x033E},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x0342},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+
+
+#if 0
+	{S5K6AAFX_REG_W_ADDL, 0x01FA},
+	/* REG_TC_GP_PrevReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_PrevReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_PrevInputWidthOfs */
+	{S5K6AAFX_REG_WR, (S5K6AAFX_FULL_SIZE_WIDTH-S5K6AAFX_ADJ_FULL_SIZE_WIDTH)/2},
+	/* REG_TC_GP_PrevInputHeightOfs */
+	{S5K6AAFX_REG_WR, (S5K6AAFX_FULL_SIZE_HEIGHT-S5K6AAFX_ADJ_FULL_SIZE_HEIGHT)/2},
+	/* REG_TC_GP_CapReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_CapReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_CapInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_PrevZoomReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_PrevZoomReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_PrevZoomReqInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_PrevZoomReqInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapZoomReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_CapZoomReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_CapZoomReqInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapZoomReqInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* REG_TC_GEP_InputsChangeRequest */
+	{S5K6AAFX_REG_W_ADDL, 0x021A},
+	{S5K6AAFX_REG_WR, 0x0001},
+#endif
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_conf_HD[] = {
+	{S5K6AAFX_REG_W_ADDH,0x7000},
+	{S5K6AAFX_REG_W_ADDL,0x021C},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_W_ADDL,0x0224},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_W_ADDL,0x020A},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_W_ADDL,0x01FA},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x0200},
+	{S5K6AAFX_REG_WR,0x0098},
+	{S5K6AAFX_REG_W_ADDL,0x021A},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_W_ADDL,0x0202},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0098},
+	{S5K6AAFX_REG_W_ADDL,0x0212},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x021A},
+	{S5K6AAFX_REG_WR,0x0001},
+	/*delay 100ms*/
+};
+static const struct s5k6aafx_i2c_reg_conf const prev_conf_VGA[] = {
+	/*VGA*/
+	/* REG_TC_GP_ActiveCapConfig-Select snapshot configuration_0 */
+	{S5K6AAFX_REG_W_ADDL, 0x0224},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x0226},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	/*********** APPLY PREVIEW CONFIGURATION & RUN PREVIEW ***********/
+	/* REG_TC_GP_ActivePrevConfig-Select preview configuration_3 */
+	{S5K6AAFX_REG_W_ADDL, 0x021C},
+	{S5K6AAFX_REG_WR, 0x0003},
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{S5K6AAFX_REG_W_ADDL, 0x0220},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_NewConfigSync-Update preview configuration */
+	{S5K6AAFX_REG_W_ADDL, 0x01F8},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_PrevConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x021E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL, 0x01F0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreview - Start preview */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreviewChanged */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_mode_switch_conf_VGA[] = {
+	/*VGA*/
+	/* REG_TC_GP_ActiveCapConfig-Select snapshot configuration_0 */
+	//{S5K6AAFX_REG_W_ADDL, 0x0224},
+	//{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapConfigChanged */
+	//{S5K6AAFX_REG_W_ADDL, 0x0226},
+	//{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL,0x020A},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_W_ADDL,0x020C},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_W_ADDL,0x01FA},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x0200},
+	{S5K6AAFX_REG_WR,0x0020},
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_WIDTH},/*0x0202*/
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_HEIGHT},/*0x0204*/
+	{S5K6AAFX_REG_WR,0x0000},/*0x0206*/
+	{S5K6AAFX_REG_WR,0x0000},/*0x0208*/
+	{S5K6AAFX_REG_W_ADDL,0x0212},
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x021A},
+	{S5K6AAFX_REG_WR,0x0001},
+	/*delay 150ms*/
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_snap_conf_init_tb2[] = {
+	/* PREVIEW CONFIGURATION 3 (VGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x02B4},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x02C0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x02BA},
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x1700},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x0001}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0250},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x02C6},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0168},
+	{S5K6AAFX_REG_W_ADDL, 0x02D4},/* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003},/* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0003},
+
+	/* PREVIEW CONFIGURATION 1 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0268},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x0274},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x026E},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0278},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0276},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x027A},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x029A},
+	{S5K6AAFX_REG_W_ADDL, 0x0288}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+
+	/*********** APPLY PREVIEW CONFIGURATION & RUN PREVIEW ***********/
+	/* REG_TC_GP_ActivePrevConfig-Select preview configuration_3 */
+	{S5K6AAFX_REG_W_ADDL, 0x021C},
+	{S5K6AAFX_REG_WR, 0x0001},/*Preview: 3 : VGA 30fps. 1:Full size 15fps*/
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{S5K6AAFX_REG_W_ADDL, 0x0220},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_NewConfigSync-Update preview configuration */
+	{S5K6AAFX_REG_W_ADDL, 0x01F8},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_PrevConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x021E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL, 0x01F0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreview - Start preview */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreviewChanged */
+
+
+	/* CAPTURE CONFIGURATION 0 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x030E},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT}, /* 1024 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x031A},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0314},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x031E},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x031C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0320},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x029A},
+
+	/* REG_TC_GP_CapConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x0226},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+};
+
+
+struct s5k6aafx_reg s5k6aafx_regs = {
+	.reset_init = &reset_init_tbl[0],
+	.reset_init_size = ARRAY_SIZE(reset_init_tbl),
+	.TP_init = &TP_init_tbl[0],
+	.TP_init_size = ARRAY_SIZE(TP_init_tbl),
+	.analog_setting_init = &analog_setting_init_tbl[0],
+	.analog_setting_init_size = ARRAY_SIZE(analog_setting_init_tbl),
+	.register_init = &register_init_tbl[0],
+	.register_init_size = ARRAY_SIZE(register_init_tbl),
+	.mipi_clk_init = &mipi_clk_init_tbl[0],
+	.mipi_clk_init_size = ARRAY_SIZE(mipi_clk_init_tbl),
+	.clk_init = &clk_init_tbl[0],
+	.clk_init_size = ARRAY_SIZE(clk_init_tbl),
+	.prev_snap_conf_init = &prev_snap_conf_init_tbl[0],
+	.prev_snap_conf_init_size = ARRAY_SIZE(prev_snap_conf_init_tbl),
+	/* for full-size preview */
+	.clk_init_tb2 = &clk_init_tb2[0],
+	.clk_init_tb2_size = ARRAY_SIZE(clk_init_tb2),
+	.prev_snap_conf_init_tb2 = &prev_snap_conf_init_tb2[0],
+	.prev_snap_conf_init_tb2_size = ARRAY_SIZE(prev_snap_conf_init_tb2),
+	.prev_HD = &prev_conf_HD[0],
+	.prev_HD_size = ARRAY_SIZE(prev_conf_HD),
+	.prev_VGA = &prev_conf_VGA[0],
+	.prev_VGA_size = ARRAY_SIZE(prev_conf_VGA),
+	.prev_mode_switch_VGA = &prev_mode_switch_conf_VGA[0],
+	.prev_mode_switch_VGA_size = ARRAY_SIZE(prev_mode_switch_conf_VGA),
+};
diff --git a/drivers/media/video/msm/sensors/s5k6aafx_reg_rider_cob.c b/drivers/media/video/msm/sensors/s5k6aafx_reg_rider_cob.c
new file mode 100644
index 0000000..efbcb50
--- /dev/null
+++ b/drivers/media/video/msm/sensors/s5k6aafx_reg_rider_cob.c
@@ -0,0 +1,2765 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "s5k6aafx.h"
+
+static const struct s5k6aafx_i2c_reg_conf const reset_init_tbl_cob[] = {
+	/* change to general mode */
+	{S5K6AAFX_REG_I2C_MODE, S5K6AAFX_I2C_MODE_GENERAL},
+	{0x0010, 0x0001}, /* Reset */
+	{0x1030, 0x0000}, /* Clear host interrupt so main will wait */
+	{0x0014, 0x0001}, /* ARM go */
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const TP_init_tbl_cob[] = {
+	/* 6AA MIPI COB type */
+	/* Start T&P part */
+	/* DO NOT DELETE T&P SECTION COMMENTS! They are required to debug T&P related issues. */
+	/* svn://transrdsrv/svn/svnroot/System/Software/tcevb/SDK+FW/ISP_Oscar/Firmware */
+	/* Rev: 33110-33110 */
+	/* Signature: */
+	/* md5 f0ba942df15b96de5c09e6cf13fed9c9 .btp */
+	/* md5 8bc59f72129cb36e6f6db4be5ddca1f6 .htp */
+	/* md5 954ec97efcabad291d89f63e29f32490 .RegsMap.h */
+	/* md5 5c29fe50b51e7e860313f5b3b6452bfd .RegsMap.bin */
+	/* md5 6211407baaa234b753431cde4ba32402 .base.RegsMap.h */
+	/* md5 90cc21d42cc5f02eb80b2586e5c46d9b .base.RegsMap.bin */
+
+	{S5K6AAFX_REG_W_ADDH, S5K6AAFX_ADDH_SW_REG_INT},
+	{S5K6AAFX_REG_W_ADDL, 0x1D60},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x4936},
+	{S5K6AAFX_REG_WR, 0x4836},
+	{S5K6AAFX_REG_WR, 0x2205},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA4E},
+	{S5K6AAFX_REG_WR, 0x4935},
+	{S5K6AAFX_REG_WR, 0x2002},
+	{S5K6AAFX_REG_WR, 0x83C8},
+	{S5K6AAFX_REG_WR, 0x2001},
+	{S5K6AAFX_REG_WR, 0x3120},
+	{S5K6AAFX_REG_WR, 0x8088},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x8008},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x8048},
+	{S5K6AAFX_REG_WR, 0x4933},
+	{S5K6AAFX_REG_WR, 0x4833},
+	{S5K6AAFX_REG_WR, 0x2204},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA3E},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x4833},
+	{S5K6AAFX_REG_WR, 0x2206},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA39},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x4832},
+	{S5K6AAFX_REG_WR, 0x2207},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA34},
+	{S5K6AAFX_REG_WR, 0x4931},
+	{S5K6AAFX_REG_WR, 0x4832},
+	{S5K6AAFX_REG_WR, 0x2208},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA2F},
+	{S5K6AAFX_REG_WR, 0x4931},
+	{S5K6AAFX_REG_WR, 0x4831},
+	{S5K6AAFX_REG_WR, 0x2209},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA2A},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x4831},
+	{S5K6AAFX_REG_WR, 0x220A},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA25},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x4830},
+	{S5K6AAFX_REG_WR, 0x220B},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA20},
+	{S5K6AAFX_REG_WR, 0x482F},
+	{S5K6AAFX_REG_WR, 0x4930},
+	{S5K6AAFX_REG_WR, 0x6108},
+	{S5K6AAFX_REG_WR, 0x4830},
+	{S5K6AAFX_REG_WR, 0x39FF},
+	{S5K6AAFX_REG_WR, 0x3901},
+	{S5K6AAFX_REG_WR, 0x6748},
+	{S5K6AAFX_REG_WR, 0x482F},
+	{S5K6AAFX_REG_WR, 0x1C0A},
+	{S5K6AAFX_REG_WR, 0x32C0},
+	{S5K6AAFX_REG_WR, 0x6390},
+	{S5K6AAFX_REG_WR, 0x482E},
+	{S5K6AAFX_REG_WR, 0x6708},
+	{S5K6AAFX_REG_WR, 0x491A},
+	{S5K6AAFX_REG_WR, 0x482D},
+	{S5K6AAFX_REG_WR, 0x3108},
+	{S5K6AAFX_REG_WR, 0x60C1},
+	{S5K6AAFX_REG_WR, 0x6882},
+	{S5K6AAFX_REG_WR, 0x1A51},
+	{S5K6AAFX_REG_WR, 0x8201},
+	{S5K6AAFX_REG_WR, 0x4C2B},
+	{S5K6AAFX_REG_WR, 0x2607},
+	{S5K6AAFX_REG_WR, 0x6821},
+	{S5K6AAFX_REG_WR, 0x0736},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA05},
+	{S5K6AAFX_REG_WR, 0x4829},
+	{S5K6AAFX_REG_WR, 0x22D8},
+	{S5K6AAFX_REG_WR, 0x1C05},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA09},
+	{S5K6AAFX_REG_WR, 0x6025},
+	{S5K6AAFX_REG_WR, 0x68A1},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA07},
+	{S5K6AAFX_REG_WR, 0x4825},
+	{S5K6AAFX_REG_WR, 0x2224},
+	{S5K6AAFX_REG_WR, 0x3824},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xFA00},
+	{S5K6AAFX_REG_WR, 0x4822},
+	{S5K6AAFX_REG_WR, 0x3824},
+	{S5K6AAFX_REG_WR, 0x60A0},
+	{S5K6AAFX_REG_WR, 0x4D22},
+	{S5K6AAFX_REG_WR, 0x6D29},
+	{S5K6AAFX_REG_WR, 0x42B1},
+	{S5K6AAFX_REG_WR, 0xDA07},
+	{S5K6AAFX_REG_WR, 0x481F},
+	{S5K6AAFX_REG_WR, 0x228F},
+	{S5K6AAFX_REG_WR, 0x00D2},
+	{S5K6AAFX_REG_WR, 0x30D8},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9F2},
+	{S5K6AAFX_REG_WR, 0x652C},
+	{S5K6AAFX_REG_WR, 0xBC70},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0x218B},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x127B},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0398},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1376},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2370},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1F0D},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x890D},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1F2F},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x27A9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1FE1},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x27C5},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2043},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x285F},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2003},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x28FF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x20CD},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x6181},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x20EF},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x6663},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x2123},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0100},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1EC1},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1EAD},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1F79},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x04AC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x06CC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0704},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9B9},
+	{S5K6AAFX_REG_WR, 0x48C3},
+	{S5K6AAFX_REG_WR, 0x49C3},
+	{S5K6AAFX_REG_WR, 0x8800},
+	{S5K6AAFX_REG_WR, 0x8048},
+	{S5K6AAFX_REG_WR, 0xBC10},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB5F8},
+	{S5K6AAFX_REG_WR, 0x1C06},
+	{S5K6AAFX_REG_WR, 0x4DC0},
+	{S5K6AAFX_REG_WR, 0x68AC},
+	{S5K6AAFX_REG_WR, 0x1C30},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF9B3},
+	{S5K6AAFX_REG_WR, 0x68A9},
+	{S5K6AAFX_REG_WR, 0x4ABC},
+	{S5K6AAFX_REG_WR, 0x42A1},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x4BBD},
+	{S5K6AAFX_REG_WR, 0x8A1B},
+	{S5K6AAFX_REG_WR, 0x3301},
+	{S5K6AAFX_REG_WR, 0x8013},
+	{S5K6AAFX_REG_WR, 0x8813},
+	{S5K6AAFX_REG_WR, 0x1C14},
+	{S5K6AAFX_REG_WR, 0x2B00},
+	{S5K6AAFX_REG_WR, 0xD00F},
+	{S5K6AAFX_REG_WR, 0x2201},
+	{S5K6AAFX_REG_WR, 0x4281},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x8C2F},
+	{S5K6AAFX_REG_WR, 0x42B9},
+	{S5K6AAFX_REG_WR, 0xD300},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x60AE},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD003},
+	{S5K6AAFX_REG_WR, 0x8C28},
+	{S5K6AAFX_REG_WR, 0x42B0},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C30},
+	{S5K6AAFX_REG_WR, 0x1E59},
+	{S5K6AAFX_REG_WR, 0x8021},
+	{S5K6AAFX_REG_WR, 0xBCF8},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x48AF},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF997},
+	{S5K6AAFX_REG_WR, 0x4AAD},
+	{S5K6AAFX_REG_WR, 0x4BAE},
+	{S5K6AAFX_REG_WR, 0x8811},
+	{S5K6AAFX_REG_WR, 0x885B},
+	{S5K6AAFX_REG_WR, 0x8852},
+	{S5K6AAFX_REG_WR, 0x4359},
+	{S5K6AAFX_REG_WR, 0x1889},
+	{S5K6AAFX_REG_WR, 0x4288},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C08},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE7C5},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x1C05},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF98F},
+	{S5K6AAFX_REG_WR, 0x49A5},
+	{S5K6AAFX_REG_WR, 0x8989},
+	{S5K6AAFX_REG_WR, 0x4348},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x0349},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF98E},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x489F},
+	{S5K6AAFX_REG_WR, 0x8F80},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF991},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x20FF},
+	{S5K6AAFX_REG_WR, 0x43C0},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF994},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF998},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x4898},
+	{S5K6AAFX_REG_WR, 0x8840},
+	{S5K6AAFX_REG_WR, 0x4360},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF97A},
+	{S5K6AAFX_REG_WR, 0x6028},
+	{S5K6AAFX_REG_WR, 0xBC70},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB5F1},
+	{S5K6AAFX_REG_WR, 0xB082},
+	{S5K6AAFX_REG_WR, 0x4D96},
+	{S5K6AAFX_REG_WR, 0x4E91},
+	{S5K6AAFX_REG_WR, 0x88A8},
+	{S5K6AAFX_REG_WR, 0x1C2C},
+	{S5K6AAFX_REG_WR, 0x3420},
+	{S5K6AAFX_REG_WR, 0x4F90},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD018},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF988},
+	{S5K6AAFX_REG_WR, 0x9001},
+	{S5K6AAFX_REG_WR, 0x9802},
+	{S5K6AAFX_REG_WR, 0x6B39},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF974},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF978},
+	{S5K6AAFX_REG_WR, 0x9901},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF95F},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x8871},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF96A},
+	{S5K6AAFX_REG_WR, 0x0400},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x21FF},
+	{S5K6AAFX_REG_WR, 0x3101},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF97A},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x88E8},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD00A},
+	{S5K6AAFX_REG_WR, 0x4980},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x3128},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF979},
+	{S5K6AAFX_REG_WR, 0x8D38},
+	{S5K6AAFX_REG_WR, 0x8871},
+	{S5K6AAFX_REG_WR, 0x4348},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x8538},
+	{S5K6AAFX_REG_WR, 0xBCFE},
+	{S5K6AAFX_REG_WR, 0xBC08},
+	{S5K6AAFX_REG_WR, 0x4718},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF974},
+	{S5K6AAFX_REG_WR, 0x6821},
+	{S5K6AAFX_REG_WR, 0x0409},
+	{S5K6AAFX_REG_WR, 0x0C09},
+	{S5K6AAFX_REG_WR, 0x1A40},
+	{S5K6AAFX_REG_WR, 0x4976},
+	{S5K6AAFX_REG_WR, 0x6849},
+	{S5K6AAFX_REG_WR, 0x4281},
+	{S5K6AAFX_REG_WR, 0xD800},
+	{S5K6AAFX_REG_WR, 0x1C08},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF971},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE75B},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x6801},
+	{S5K6AAFX_REG_WR, 0x040D},
+	{S5K6AAFX_REG_WR, 0x0C2D},
+	{S5K6AAFX_REG_WR, 0x6844},
+	{S5K6AAFX_REG_WR, 0x486F},
+	{S5K6AAFX_REG_WR, 0x8981},
+	{S5K6AAFX_REG_WR, 0x1C28},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF927},
+	{S5K6AAFX_REG_WR, 0x8060},
+	{S5K6AAFX_REG_WR, 0x4970},
+	{S5K6AAFX_REG_WR, 0x69C9},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF968},
+	{S5K6AAFX_REG_WR, 0x1C01},
+	{S5K6AAFX_REG_WR, 0x80A0},
+	{S5K6AAFX_REG_WR, 0x0228},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF92D},
+	{S5K6AAFX_REG_WR, 0x0400},
+	{S5K6AAFX_REG_WR, 0x0C00},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0x496B},
+	{S5K6AAFX_REG_WR, 0x2300},
+	{S5K6AAFX_REG_WR, 0x5EC9},
+	{S5K6AAFX_REG_WR, 0x4288},
+	{S5K6AAFX_REG_WR, 0xDA02},
+	{S5K6AAFX_REG_WR, 0x20FF},
+	{S5K6AAFX_REG_WR, 0x3001},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE797},
+	{S5K6AAFX_REG_WR, 0xB5F8},
+	{S5K6AAFX_REG_WR, 0x1C04},
+	{S5K6AAFX_REG_WR, 0x4867},
+	{S5K6AAFX_REG_WR, 0x4E65},
+	{S5K6AAFX_REG_WR, 0x7800},
+	{S5K6AAFX_REG_WR, 0x6AB7},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD100},
+	{S5K6AAFX_REG_WR, 0x6A37},
+	{S5K6AAFX_REG_WR, 0x495D},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0x688D},
+	{S5K6AAFX_REG_WR, 0xD100},
+	{S5K6AAFX_REG_WR, 0x684D},
+	{S5K6AAFX_REG_WR, 0x4859},
+	{S5K6AAFX_REG_WR, 0x8841},
+	{S5K6AAFX_REG_WR, 0x6820},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF94B},
+	{S5K6AAFX_REG_WR, 0x8DF1},
+	{S5K6AAFX_REG_WR, 0x434F},
+	{S5K6AAFX_REG_WR, 0x0A3A},
+	{S5K6AAFX_REG_WR, 0x4282},
+	{S5K6AAFX_REG_WR, 0xD30C},
+	{S5K6AAFX_REG_WR, 0x4D5C},
+	{S5K6AAFX_REG_WR, 0x26FF},
+	{S5K6AAFX_REG_WR, 0x8829},
+	{S5K6AAFX_REG_WR, 0x3601},
+	{S5K6AAFX_REG_WR, 0x43B1},
+	{S5K6AAFX_REG_WR, 0x8029},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF944},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0x8828},
+	{S5K6AAFX_REG_WR, 0x4330},
+	{S5K6AAFX_REG_WR, 0x8028},
+	{S5K6AAFX_REG_WR, 0xE73B},
+	{S5K6AAFX_REG_WR, 0x1C0A},
+	{S5K6AAFX_REG_WR, 0x436A},
+	{S5K6AAFX_REG_WR, 0x0A12},
+	{S5K6AAFX_REG_WR, 0x4282},
+	{S5K6AAFX_REG_WR, 0xD304},
+	{S5K6AAFX_REG_WR, 0x0200},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8F3},
+	{S5K6AAFX_REG_WR, 0x6020},
+	{S5K6AAFX_REG_WR, 0xE7F4},
+	{S5K6AAFX_REG_WR, 0x6025},
+	{S5K6AAFX_REG_WR, 0xE7F2},
+	{S5K6AAFX_REG_WR, 0xB410},
+	{S5K6AAFX_REG_WR, 0x4848},
+	{S5K6AAFX_REG_WR, 0x4950},
+	{S5K6AAFX_REG_WR, 0x89C0},
+	{S5K6AAFX_REG_WR, 0x2316},
+	{S5K6AAFX_REG_WR, 0x5ECC},
+	{S5K6AAFX_REG_WR, 0x1C02},
+	{S5K6AAFX_REG_WR, 0x42A0},
+	{S5K6AAFX_REG_WR, 0xDC00},
+	{S5K6AAFX_REG_WR, 0x1C22},
+	{S5K6AAFX_REG_WR, 0x82CA},
+	{S5K6AAFX_REG_WR, 0x2318},
+	{S5K6AAFX_REG_WR, 0x5ECA},
+	{S5K6AAFX_REG_WR, 0x4290},
+	{S5K6AAFX_REG_WR, 0xDC00},
+	{S5K6AAFX_REG_WR, 0x1C10},
+	{S5K6AAFX_REG_WR, 0x8308},
+	{S5K6AAFX_REG_WR, 0xBC10},
+	{S5K6AAFX_REG_WR, 0x4770},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x1C06},
+	{S5K6AAFX_REG_WR, 0x4C45},
+	{S5K6AAFX_REG_WR, 0x2501},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x02AD},
+	{S5K6AAFX_REG_WR, 0x43A8},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF91E},
+	{S5K6AAFX_REG_WR, 0x6030},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFE0},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x4328},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE741},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x4C3D},
+	{S5K6AAFX_REG_WR, 0x2501},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x02ED},
+	{S5K6AAFX_REG_WR, 0x43A8},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF916},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFD1},
+	{S5K6AAFX_REG_WR, 0x8820},
+	{S5K6AAFX_REG_WR, 0x4328},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE732},
+	{S5K6AAFX_REG_WR, 0x230D},
+	{S5K6AAFX_REG_WR, 0x071B},
+	{S5K6AAFX_REG_WR, 0x18C3},
+	{S5K6AAFX_REG_WR, 0x8818},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD001},
+	{S5K6AAFX_REG_WR, 0x4308},
+	{S5K6AAFX_REG_WR, 0xE000},
+	{S5K6AAFX_REG_WR, 0x4388},
+	{S5K6AAFX_REG_WR, 0x8018},
+	{S5K6AAFX_REG_WR, 0x4770},
+	{S5K6AAFX_REG_WR, 0xB570},
+	{S5K6AAFX_REG_WR, 0x2402},
+	{S5K6AAFX_REG_WR, 0x4932},
+	{S5K6AAFX_REG_WR, 0x8809},
+	{S5K6AAFX_REG_WR, 0x078A},
+	{S5K6AAFX_REG_WR, 0xD500},
+	{S5K6AAFX_REG_WR, 0x2406},
+	{S5K6AAFX_REG_WR, 0x2900},
+	{S5K6AAFX_REG_WR, 0xD01F},
+	{S5K6AAFX_REG_WR, 0x1C02},
+	{S5K6AAFX_REG_WR, 0x207D},
+	{S5K6AAFX_REG_WR, 0x00C0},
+	{S5K6AAFX_REG_WR, 0x2600},
+	{S5K6AAFX_REG_WR, 0x4D2D},
+	{S5K6AAFX_REG_WR, 0x2A00},
+	{S5K6AAFX_REG_WR, 0xD019},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x8229},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8F9},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0x482A},
+	{S5K6AAFX_REG_WR, 0x0309},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFDB},
+	{S5K6AAFX_REG_WR, 0x2008},
+	{S5K6AAFX_REG_WR, 0x4304},
+	{S5K6AAFX_REG_WR, 0x1C21},
+	{S5K6AAFX_REG_WR, 0x4C26},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x3C14},
+	{S5K6AAFX_REG_WR, 0x1C20},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFD2},
+	{S5K6AAFX_REG_WR, 0x2200},
+	{S5K6AAFX_REG_WR, 0x2121},
+	{S5K6AAFX_REG_WR, 0x1C20},
+	{S5K6AAFX_REG_WR, 0xF7FF},
+	{S5K6AAFX_REG_WR, 0xFFCD},
+	{S5K6AAFX_REG_WR, 0x802E},
+	{S5K6AAFX_REG_WR, 0xE6FD},
+	{S5K6AAFX_REG_WR, 0x822E},
+	{S5K6AAFX_REG_WR, 0x0789},
+	{S5K6AAFX_REG_WR, 0x0FC9},
+	{S5K6AAFX_REG_WR, 0x0089},
+	{S5K6AAFX_REG_WR, 0x223B},
+	{S5K6AAFX_REG_WR, 0x4311},
+	{S5K6AAFX_REG_WR, 0x8029},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8DA},
+	{S5K6AAFX_REG_WR, 0xE7F4},
+	{S5K6AAFX_REG_WR, 0xB510},
+	{S5K6AAFX_REG_WR, 0x491B},
+	{S5K6AAFX_REG_WR, 0x8FC8},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD007},
+	{S5K6AAFX_REG_WR, 0x2000},
+	{S5K6AAFX_REG_WR, 0x87C8},
+	{S5K6AAFX_REG_WR, 0x8F88},
+	{S5K6AAFX_REG_WR, 0x4C19},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD002},
+	{S5K6AAFX_REG_WR, 0x2008},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE689},
+	{S5K6AAFX_REG_WR, 0x4815},
+	{S5K6AAFX_REG_WR, 0x3060},
+	{S5K6AAFX_REG_WR, 0x8900},
+	{S5K6AAFX_REG_WR, 0x2800},
+	{S5K6AAFX_REG_WR, 0xD103},
+	{S5K6AAFX_REG_WR, 0x4814},
+	{S5K6AAFX_REG_WR, 0x2101},
+	{S5K6AAFX_REG_WR, 0xF000},
+	{S5K6AAFX_REG_WR, 0xF8CA},
+	{S5K6AAFX_REG_WR, 0x2010},
+	{S5K6AAFX_REG_WR, 0x8020},
+	{S5K6AAFX_REG_WR, 0xE7F2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1376},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2370},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x14D8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x235C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xF4B0},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x1554},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1AB8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0080},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x046C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0468},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x1100},
+	{S5K6AAFX_REG_WR, 0xD000},
+	{S5K6AAFX_REG_WR, 0x198C},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0AC4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0xB0A0},
+	{S5K6AAFX_REG_WR, 0xD000},
+	{S5K6AAFX_REG_WR, 0xB0B4},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x044E},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x0450},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x9CE7},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0x9FB8},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x14C1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27E1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x88DF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x275D},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1ED3},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27C5},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0xA144},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1F87},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x27A9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x1ECB},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x28FF},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x26F9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x4027},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x9F03},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xF004},
+	{S5K6AAFX_REG_WR, 0xE51F},
+	{S5K6AAFX_REG_WR, 0x9D9C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x285F},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x6181},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x6663},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x85D9},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x4778},
+	{S5K6AAFX_REG_WR, 0x46C0},
+	{S5K6AAFX_REG_WR, 0xC000},
+	{S5K6AAFX_REG_WR, 0xE59F},
+	{S5K6AAFX_REG_WR, 0xFF1C},
+	{S5K6AAFX_REG_WR, 0xE12F},
+	{S5K6AAFX_REG_WR, 0x2001},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xE848},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0xE848},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0500},
+	{S5K6AAFX_REG_WR, 0x0064},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* End T&P part */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const analog_setting_init_tbl_cob[] = {
+	/* Start tuning part */
+
+	/* Analog Settings */
+	{0x0040, 0x0000},
+
+	{0xF454, 0x0001},
+	{0xF418, 0x0050},
+	{0xF43E, 0x0010},
+	{0xF42A, 0x00F0},
+
+	{0x0040, 0x0001},
+
+	{S5K6AAFX_REG_W_ADDL, 0x112A},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1132},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x113E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x115C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1164},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1174},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x1178},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x235C},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x0090},
+
+	{S5K6AAFX_REG_W_ADDL, 0x077A},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x07A2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x07B6},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0005},
+	{S5K6AAFX_REG_WR, 0x0005},
+	{0x002A, 0x0104},
+	{0x0F12, 0x0C2F},
+	{0x002A, 0x10EA},
+	{0x0F12, 0x007C},
+	{0x1000, 0x0001}, /* Set host interrupt so main start run */
+
+	/* delay 10ms */
+
+};
+
+static const struct s5k6aafx_i2c_reg_conf const register_init_tbl_cob[] = {
+// Start user init script
+
+// End user init script
+
+	/* param_start - TVAR_ash_GASAlpha */
+	/* parawrite _start - TVAR_ash_GASAlpha */
+	{S5K6AAFX_REG_W_ADDL, 0x0712},
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[0] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[1] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[2] */
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_GASAlpha[3] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[4] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[5] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[6] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[7] */
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_GASAlpha[8] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[9] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[10] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[11] */
+	{S5K6AAFX_REG_WR, 0x00f0}, /* TVAR_ash_GASAlpha[12] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[13] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[14] */
+	{S5K6AAFX_REG_WR, 0x00d0}, /* TVAR_ash_GASAlpha[15] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[16] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[17] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[18] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[19] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[20] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[21] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[22] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[23] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[24] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[25] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[26] */
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_GASAlpha[27] */
+	/* parawrite _end - TVAR_ash_GASAlpha */
+
+	/* parawrite _start - TVAR_ash_GASOutdoorAlpha */
+	{S5K6AAFX_REG_W_ADDL, 0x074A},
+	{S5K6AAFX_REG_WR, 0x0130},	//TVAR_ash_GASOutdoorAlpha[0]
+	{S5K6AAFX_REG_WR, 0x0100},	//TVAR_ash_GASOutdoorAlpha[1]
+	{S5K6AAFX_REG_WR, 0x0100},	//TVAR_ash_GASOutdoorAlpha[2]
+	{S5K6AAFX_REG_WR, 0x00d0},	//TVAR_ash_GASOutdoorAlpha[3]
+	/* parawrite _end - TVAR_ash_GASOutdoorAlpha */
+
+	{S5K6AAFX_REG_W_ADDL, 0x075A},
+	{S5K6AAFX_REG_WR, 0x0001}, /* ash_bParabolicEstiwrite ation */
+	{S5K6AAFX_REG_WR, 0x0282}, /* ash_uParabolicCenterX */
+	{S5K6AAFX_REG_WR, 0x0216}, /* ash_uParabolicCenterY */
+	{S5K6AAFX_REG_WR, 0x000B}, /* ash_uParabolicScalingA */
+	{S5K6AAFX_REG_WR, 0x000E}, /* ash_uParabolicScalingB */
+
+	/* parawrite _start - TVAR_ash_pGAS */
+	{S5K6AAFX_REG_W_ADDL, 0x247C},
+	{S5K6AAFX_REG_WR, 0x021D}, /* TVAR_ash_pGAS[0] */    
+	{S5K6AAFX_REG_WR, 0x019A}, /* TVAR_ash_pGAS[1] */    
+	{S5K6AAFX_REG_WR, 0x0160}, /* TVAR_ash_pGAS[2] */    
+	{S5K6AAFX_REG_WR, 0x0146}, /* TVAR_ash_pGAS[3] */    
+	{S5K6AAFX_REG_WR, 0x012F}, /* TVAR_ash_pGAS[4] */    
+	{S5K6AAFX_REG_WR, 0x0121}, /* TVAR_ash_pGAS[5] */    
+	{S5K6AAFX_REG_WR, 0x011C}, /* TVAR_ash_pGAS[6] */    
+	{S5K6AAFX_REG_WR, 0x0128}, /* TVAR_ash_pGAS[7] */    
+	{S5K6AAFX_REG_WR, 0x0140}, /* TVAR_ash_pGAS[8] */    
+	{S5K6AAFX_REG_WR, 0x0159}, /* TVAR_ash_pGAS[9] */    
+	{S5K6AAFX_REG_WR, 0x016C}, /* TVAR_ash_pGAS[10] */   
+	{S5K6AAFX_REG_WR, 0x01A7}, /* TVAR_ash_pGAS[11] */   
+	{S5K6AAFX_REG_WR, 0x024E}, /* TVAR_ash_pGAS[12] */   
+	{S5K6AAFX_REG_WR, 0x01A9}, /* TVAR_ash_pGAS[13] */   
+	{S5K6AAFX_REG_WR, 0x0160}, /* TVAR_ash_pGAS[14] */   
+	{S5K6AAFX_REG_WR, 0x0137}, /* TVAR_ash_pGAS[15] */   
+	{S5K6AAFX_REG_WR, 0x0109}, /* TVAR_ash_pGAS[16] */   
+	{S5K6AAFX_REG_WR, 0x00E1}, /* TVAR_ash_pGAS[17] */   
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_pGAS[18] */   
+	{S5K6AAFX_REG_WR, 0x00C4}, /* TVAR_ash_pGAS[19] */   
+	{S5K6AAFX_REG_WR, 0x00D0}, /* TVAR_ash_pGAS[20] */   
+	{S5K6AAFX_REG_WR, 0x00F1}, /* TVAR_ash_pGAS[21] */   
+	{S5K6AAFX_REG_WR, 0x011B}, /* TVAR_ash_pGAS[22] */   
+	{S5K6AAFX_REG_WR, 0x0144}, /* TVAR_ash_pGAS[23] */   
+	{S5K6AAFX_REG_WR, 0x0166}, /* TVAR_ash_pGAS[24] */   
+	{S5K6AAFX_REG_WR, 0x01BA}, /* TVAR_ash_pGAS[25] */   
+	{S5K6AAFX_REG_WR, 0x0170}, /* TVAR_ash_pGAS[26] */   
+	{S5K6AAFX_REG_WR, 0x0141}, /* TVAR_ash_pGAS[27] */   
+	{S5K6AAFX_REG_WR, 0x0103}, /* TVAR_ash_pGAS[28] */   
+	{S5K6AAFX_REG_WR, 0x00C1}, /* TVAR_ash_pGAS[29] */   
+	{S5K6AAFX_REG_WR, 0x0090}, /* TVAR_ash_pGAS[30] */   
+	{S5K6AAFX_REG_WR, 0x0073}, /* TVAR_ash_pGAS[31] */   
+	{S5K6AAFX_REG_WR, 0x006B}, /* TVAR_ash_pGAS[32] */   
+	{S5K6AAFX_REG_WR, 0x0077}, /* TVAR_ash_pGAS[33] */   
+	{S5K6AAFX_REG_WR, 0x009A}, /* TVAR_ash_pGAS[34] */   
+	{S5K6AAFX_REG_WR, 0x00D0}, /* TVAR_ash_pGAS[35] */   
+	{S5K6AAFX_REG_WR, 0x0110}, /* TVAR_ash_pGAS[36] */   
+	{S5K6AAFX_REG_WR, 0x0144}, /* TVAR_ash_pGAS[37] */   
+	{S5K6AAFX_REG_WR, 0x0174}, /* TVAR_ash_pGAS[38] */   
+	{S5K6AAFX_REG_WR, 0x0157}, /* TVAR_ash_pGAS[39] */   
+	{S5K6AAFX_REG_WR, 0x011E}, /* TVAR_ash_pGAS[40] */   
+	{S5K6AAFX_REG_WR, 0x00D0}, /* TVAR_ash_pGAS[41] */   
+	{S5K6AAFX_REG_WR, 0x0088}, /* TVAR_ash_pGAS[42] */   
+	{S5K6AAFX_REG_WR, 0x0054}, /* TVAR_ash_pGAS[43] */   
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[44] */   
+	{S5K6AAFX_REG_WR, 0x002E}, /* TVAR_ash_pGAS[45] */   
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[46] */   
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[47] */   
+	{S5K6AAFX_REG_WR, 0x0094}, /* TVAR_ash_pGAS[48] */   
+	{S5K6AAFX_REG_WR, 0x00DD}, /* TVAR_ash_pGAS[49] */   
+	{S5K6AAFX_REG_WR, 0x0126}, /* TVAR_ash_pGAS[50] */   
+	{S5K6AAFX_REG_WR, 0x015C}, /* TVAR_ash_pGAS[51] */   
+	{S5K6AAFX_REG_WR, 0x0149}, /* TVAR_ash_pGAS[52] */   
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[53] */   
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[54] */   
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[55] */   
+	{S5K6AAFX_REG_WR, 0x0031}, /* TVAR_ash_pGAS[56] */   
+	{S5K6AAFX_REG_WR, 0x0014}, /* TVAR_ash_pGAS[57] */   
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[58] */   
+	{S5K6AAFX_REG_WR, 0x0017}, /* TVAR_ash_pGAS[59] */   
+	{S5K6AAFX_REG_WR, 0x0039}, /* TVAR_ash_pGAS[60] */   
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[61] */   
+	{S5K6AAFX_REG_WR, 0x00BF}, /* TVAR_ash_pGAS[62] */   
+	{S5K6AAFX_REG_WR, 0x0114}, /* TVAR_ash_pGAS[63] */   
+	{S5K6AAFX_REG_WR, 0x0153}, /* TVAR_ash_pGAS[64] */   
+	{S5K6AAFX_REG_WR, 0x014D}, /* TVAR_ash_pGAS[65] */   
+	{S5K6AAFX_REG_WR, 0x0105}, /* TVAR_ash_pGAS[66] */   
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[67] */   
+	{S5K6AAFX_REG_WR, 0x005A}, /* TVAR_ash_pGAS[68] */   
+	{S5K6AAFX_REG_WR, 0x0026}, /* TVAR_ash_pGAS[69] */   
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[70] */   
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[71] */   
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[72] */   
+	{S5K6AAFX_REG_WR, 0x002E}, /* TVAR_ash_pGAS[73] */   
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[74] */   
+	{S5K6AAFX_REG_WR, 0x00B9}, /* TVAR_ash_pGAS[75] */   
+	{S5K6AAFX_REG_WR, 0x0114}, /* TVAR_ash_pGAS[76] */   
+	{S5K6AAFX_REG_WR, 0x015A}, /* TVAR_ash_pGAS[77] */   
+	{S5K6AAFX_REG_WR, 0x015D}, /* TVAR_ash_pGAS[78] */   
+	{S5K6AAFX_REG_WR, 0x0116}, /* TVAR_ash_pGAS[79] */   
+	{S5K6AAFX_REG_WR, 0x00B5}, /* TVAR_ash_pGAS[80] */   
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[81] */   
+	{S5K6AAFX_REG_WR, 0x002F}, /* TVAR_ash_pGAS[82] */   
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[83] */   
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[84] */   
+	{S5K6AAFX_REG_WR, 0x0014}, /* TVAR_ash_pGAS[85] */   
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[86] */   
+	{S5K6AAFX_REG_WR, 0x0075}, /* TVAR_ash_pGAS[87] */   
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[88] */   
+	{S5K6AAFX_REG_WR, 0x0126}, /* TVAR_ash_pGAS[89] */   
+	{S5K6AAFX_REG_WR, 0x0170}, /* TVAR_ash_pGAS[90] */   
+	{S5K6AAFX_REG_WR, 0x017D}, /* TVAR_ash_pGAS[91] */   
+	{S5K6AAFX_REG_WR, 0x013E}, /* TVAR_ash_pGAS[92] */   
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[93] */   
+	{S5K6AAFX_REG_WR, 0x008B}, /* TVAR_ash_pGAS[94] */   
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[95] */   
+	{S5K6AAFX_REG_WR, 0x002E}, /* TVAR_ash_pGAS[96] */   
+	{S5K6AAFX_REG_WR, 0x0025}, /* TVAR_ash_pGAS[97] */   
+	{S5K6AAFX_REG_WR, 0x0033}, /* TVAR_ash_pGAS[98] */   
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[99] */   
+	{S5K6AAFX_REG_WR, 0x009B}, /* TVAR_ash_pGAS[100] */  
+	{S5K6AAFX_REG_WR, 0x00F2}, /* TVAR_ash_pGAS[101] */  
+	{S5K6AAFX_REG_WR, 0x014B}, /* TVAR_ash_pGAS[102] */  
+	{S5K6AAFX_REG_WR, 0x018C}, /* TVAR_ash_pGAS[103] */  
+	{S5K6AAFX_REG_WR, 0x01A2}, /* TVAR_ash_pGAS[104] */  
+	{S5K6AAFX_REG_WR, 0x0172}, /* TVAR_ash_pGAS[105] */  
+	{S5K6AAFX_REG_WR, 0x011F}, /* TVAR_ash_pGAS[106] */  
+	{S5K6AAFX_REG_WR, 0x00C8}, /* TVAR_ash_pGAS[107] */  
+	{S5K6AAFX_REG_WR, 0x0089}, /* TVAR_ash_pGAS[108] */  
+	{S5K6AAFX_REG_WR, 0x0064}, /* TVAR_ash_pGAS[109] */  
+	{S5K6AAFX_REG_WR, 0x005A}, /* TVAR_ash_pGAS[110] */  
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[111] */  
+	{S5K6AAFX_REG_WR, 0x0092}, /* TVAR_ash_pGAS[112] */  
+	{S5K6AAFX_REG_WR, 0x00D7}, /* TVAR_ash_pGAS[113] */  
+	{S5K6AAFX_REG_WR, 0x012C}, /* TVAR_ash_pGAS[114] */  
+	{S5K6AAFX_REG_WR, 0x0178}, /* TVAR_ash_pGAS[115] */  
+	{S5K6AAFX_REG_WR, 0x01AF}, /* TVAR_ash_pGAS[116] */  
+	{S5K6AAFX_REG_WR, 0x01D2}, /* TVAR_ash_pGAS[117] */  
+	{S5K6AAFX_REG_WR, 0x01A3}, /* TVAR_ash_pGAS[118] */  
+	{S5K6AAFX_REG_WR, 0x016B}, /* TVAR_ash_pGAS[119] */  
+	{S5K6AAFX_REG_WR, 0x0120}, /* TVAR_ash_pGAS[120] */  
+	{S5K6AAFX_REG_WR, 0x00E2}, /* TVAR_ash_pGAS[121] */  
+	{S5K6AAFX_REG_WR, 0x00BB}, /* TVAR_ash_pGAS[122] */  
+	{S5K6AAFX_REG_WR, 0x00AF}, /* TVAR_ash_pGAS[123] */  
+	{S5K6AAFX_REG_WR, 0x00BD}, /* TVAR_ash_pGAS[124] */  
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[125] */  
+	{S5K6AAFX_REG_WR, 0x012B}, /* TVAR_ash_pGAS[126] */  
+	{S5K6AAFX_REG_WR, 0x0174}, /* TVAR_ash_pGAS[127] */  
+	{S5K6AAFX_REG_WR, 0x01A9}, /* TVAR_ash_pGAS[128] */  
+	{S5K6AAFX_REG_WR, 0x01E9}, /* TVAR_ash_pGAS[129] */  
+	{S5K6AAFX_REG_WR, 0x0221}, /* TVAR_ash_pGAS[130] */  
+	{S5K6AAFX_REG_WR, 0x01C9}, /* TVAR_ash_pGAS[131] */  
+	{S5K6AAFX_REG_WR, 0x01A1}, /* TVAR_ash_pGAS[132] */  
+	{S5K6AAFX_REG_WR, 0x016D}, /* TVAR_ash_pGAS[133] */  
+	{S5K6AAFX_REG_WR, 0x0137}, /* TVAR_ash_pGAS[134] */  
+	{S5K6AAFX_REG_WR, 0x0112}, /* TVAR_ash_pGAS[135] */  
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[136] */  
+	{S5K6AAFX_REG_WR, 0x0113}, /* TVAR_ash_pGAS[137] */  
+	{S5K6AAFX_REG_WR, 0x013C}, /* TVAR_ash_pGAS[138] */  
+	{S5K6AAFX_REG_WR, 0x0172}, /* TVAR_ash_pGAS[139] */  
+	{S5K6AAFX_REG_WR, 0x01A2}, /* TVAR_ash_pGAS[140] */  
+	{S5K6AAFX_REG_WR, 0x01D0}, /* TVAR_ash_pGAS[141] */  
+	{S5K6AAFX_REG_WR, 0x0247}, /* TVAR_ash_pGAS[142] */  
+	{S5K6AAFX_REG_WR, 0x01D3}, /* TVAR_ash_pGAS[143] */  
+	{S5K6AAFX_REG_WR, 0x0158}, /* TVAR_ash_pGAS[144] */  
+	{S5K6AAFX_REG_WR, 0x0126}, /* TVAR_ash_pGAS[145] */  
+	{S5K6AAFX_REG_WR, 0x0112}, /* TVAR_ash_pGAS[146] */  
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_pGAS[147] */  
+	{S5K6AAFX_REG_WR, 0x00F6}, /* TVAR_ash_pGAS[148] */  
+	{S5K6AAFX_REG_WR, 0x00F6}, /* TVAR_ash_pGAS[149] */  
+	{S5K6AAFX_REG_WR, 0x0101}, /* TVAR_ash_pGAS[150] */  
+	{S5K6AAFX_REG_WR, 0x0113}, /* TVAR_ash_pGAS[151] */  
+	{S5K6AAFX_REG_WR, 0x0123}, /* TVAR_ash_pGAS[152] */  
+	{S5K6AAFX_REG_WR, 0x0131}, /* TVAR_ash_pGAS[153] */  
+	{S5K6AAFX_REG_WR, 0x0166}, /* TVAR_ash_pGAS[154] */  
+	{S5K6AAFX_REG_WR, 0x020E}, /* TVAR_ash_pGAS[155] */  
+	{S5K6AAFX_REG_WR, 0x0165}, /* TVAR_ash_pGAS[156] */  
+	{S5K6AAFX_REG_WR, 0x0122}, /* TVAR_ash_pGAS[157] */  
+	{S5K6AAFX_REG_WR, 0x00FE}, /* TVAR_ash_pGAS[158] */  
+	{S5K6AAFX_REG_WR, 0x00DB}, /* TVAR_ash_pGAS[159] */  
+	{S5K6AAFX_REG_WR, 0x00BD}, /* TVAR_ash_pGAS[160] */  
+	{S5K6AAFX_REG_WR, 0x00AA}, /* TVAR_ash_pGAS[161] */  
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[162] */  
+	{S5K6AAFX_REG_WR, 0x00B4}, /* TVAR_ash_pGAS[163] */  
+	{S5K6AAFX_REG_WR, 0x00CF}, /* TVAR_ash_pGAS[164] */  
+	{S5K6AAFX_REG_WR, 0x00EF}, /* TVAR_ash_pGAS[165] */  
+	{S5K6AAFX_REG_WR, 0x010E}, /* TVAR_ash_pGAS[166] */  
+	{S5K6AAFX_REG_WR, 0x0127}, /* TVAR_ash_pGAS[167] */  
+	{S5K6AAFX_REG_WR, 0x017A}, /* TVAR_ash_pGAS[168] */  
+	{S5K6AAFX_REG_WR, 0x0134}, /* TVAR_ash_pGAS[169] */  
+	{S5K6AAFX_REG_WR, 0x010C}, /* TVAR_ash_pGAS[170] */  
+	{S5K6AAFX_REG_WR, 0x00DA}, /* TVAR_ash_pGAS[171] */  
+	{S5K6AAFX_REG_WR, 0x00A4}, /* TVAR_ash_pGAS[172] */  
+	{S5K6AAFX_REG_WR, 0x007C}, /* TVAR_ash_pGAS[173] */  
+	{S5K6AAFX_REG_WR, 0x0063}, /* TVAR_ash_pGAS[174] */  
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[175] */  
+	{S5K6AAFX_REG_WR, 0x006C}, /* TVAR_ash_pGAS[176] */  
+	{S5K6AAFX_REG_WR, 0x008B}, /* TVAR_ash_pGAS[177] */  
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[178] */  
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[179] */  
+	{S5K6AAFX_REG_WR, 0x010F}, /* TVAR_ash_pGAS[180] */  
+	{S5K6AAFX_REG_WR, 0x013D}, /* TVAR_ash_pGAS[181] */  
+	{S5K6AAFX_REG_WR, 0x0122}, /* TVAR_ash_pGAS[182] */  
+	{S5K6AAFX_REG_WR, 0x00F1}, /* TVAR_ash_pGAS[183] */  
+	{S5K6AAFX_REG_WR, 0x00B0}, /* TVAR_ash_pGAS[184] */  
+	{S5K6AAFX_REG_WR, 0x0074}, /* TVAR_ash_pGAS[185] */  
+	{S5K6AAFX_REG_WR, 0x0047}, /* TVAR_ash_pGAS[186] */  
+	{S5K6AAFX_REG_WR, 0x002E}, /* TVAR_ash_pGAS[187] */  
+	{S5K6AAFX_REG_WR, 0x0029}, /* TVAR_ash_pGAS[188] */  
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[189] */  
+	{S5K6AAFX_REG_WR, 0x0055}, /* TVAR_ash_pGAS[190] */  
+	{S5K6AAFX_REG_WR, 0x0086}, /* TVAR_ash_pGAS[191] */  
+	{S5K6AAFX_REG_WR, 0x00C4}, /* TVAR_ash_pGAS[192] */  
+	{S5K6AAFX_REG_WR, 0x00FD}, /* TVAR_ash_pGAS[193] */  
+	{S5K6AAFX_REG_WR, 0x012B}, /* TVAR_ash_pGAS[194] */  
+	{S5K6AAFX_REG_WR, 0x0119}, /* TVAR_ash_pGAS[195] */  
+	{S5K6AAFX_REG_WR, 0x00DE}, /* TVAR_ash_pGAS[196] */  
+	{S5K6AAFX_REG_WR, 0x0094}, /* TVAR_ash_pGAS[197] */  
+	{S5K6AAFX_REG_WR, 0x0053}, /* TVAR_ash_pGAS[198] */  
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[199] */  
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[200] */  
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[201] */  
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[202] */  
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[203] */  
+	{S5K6AAFX_REG_WR, 0x0067}, /* TVAR_ash_pGAS[204] */  
+	{S5K6AAFX_REG_WR, 0x00AB}, /* TVAR_ash_pGAS[205] */  
+	{S5K6AAFX_REG_WR, 0x00F1}, /* TVAR_ash_pGAS[206] */  
+	{S5K6AAFX_REG_WR, 0x012A}, /* TVAR_ash_pGAS[207] */  
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[208] */  
+	{S5K6AAFX_REG_WR, 0x00D9}, /* TVAR_ash_pGAS[209] */  
+	{S5K6AAFX_REG_WR, 0x008A}, /* TVAR_ash_pGAS[210] */  
+	{S5K6AAFX_REG_WR, 0x0048}, /* TVAR_ash_pGAS[211] */  
+	{S5K6AAFX_REG_WR, 0x001C}, /* TVAR_ash_pGAS[212] */  
+	{S5K6AAFX_REG_WR, 0x0004}, /* TVAR_ash_pGAS[213] */  
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[214] */  
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[215] */  
+	{S5K6AAFX_REG_WR, 0x002C}, /* TVAR_ash_pGAS[216] */  
+	{S5K6AAFX_REG_WR, 0x0061}, /* TVAR_ash_pGAS[217] */  
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[218] */  
+	{S5K6AAFX_REG_WR, 0x00F4}, /* TVAR_ash_pGAS[219] */  
+	{S5K6AAFX_REG_WR, 0x0134}, /* TVAR_ash_pGAS[220] */  
+	{S5K6AAFX_REG_WR, 0x0125}, /* TVAR_ash_pGAS[221] */  
+	{S5K6AAFX_REG_WR, 0x00E5}, /* TVAR_ash_pGAS[222] */  
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[223] */  
+	{S5K6AAFX_REG_WR, 0x0052}, /* TVAR_ash_pGAS[224] */  
+	{S5K6AAFX_REG_WR, 0x0024}, /* TVAR_ash_pGAS[225] */  
+	{S5K6AAFX_REG_WR, 0x000C}, /* TVAR_ash_pGAS[226] */  
+	{S5K6AAFX_REG_WR, 0x0007}, /* TVAR_ash_pGAS[227] */  
+	{S5K6AAFX_REG_WR, 0x0015}, /* TVAR_ash_pGAS[228] */  
+	{S5K6AAFX_REG_WR, 0x0038}, /* TVAR_ash_pGAS[229] */  
+	{S5K6AAFX_REG_WR, 0x006E}, /* TVAR_ash_pGAS[230] */  
+	{S5K6AAFX_REG_WR, 0x00B9}, /* TVAR_ash_pGAS[231] */  
+	{S5K6AAFX_REG_WR, 0x0105}, /* TVAR_ash_pGAS[232] */  
+	{S5K6AAFX_REG_WR, 0x0147}, /* TVAR_ash_pGAS[233] */  
+	{S5K6AAFX_REG_WR, 0x013E}, /* TVAR_ash_pGAS[234] */  
+	{S5K6AAFX_REG_WR, 0x0105}, /* TVAR_ash_pGAS[235] */  
+	{S5K6AAFX_REG_WR, 0x00B7}, /* TVAR_ash_pGAS[236] */  
+	{S5K6AAFX_REG_WR, 0x0073}, /* TVAR_ash_pGAS[237] */  
+	{S5K6AAFX_REG_WR, 0x0044}, /* TVAR_ash_pGAS[238] */  
+	{S5K6AAFX_REG_WR, 0x002A}, /* TVAR_ash_pGAS[239] */  
+	{S5K6AAFX_REG_WR, 0x0025}, /* TVAR_ash_pGAS[240] */  
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[241] */  
+	{S5K6AAFX_REG_WR, 0x005B}, /* TVAR_ash_pGAS[242] */  
+	{S5K6AAFX_REG_WR, 0x0096}, /* TVAR_ash_pGAS[243] */  
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[244] */  
+	{S5K6AAFX_REG_WR, 0x0129}, /* TVAR_ash_pGAS[245] */  
+	{S5K6AAFX_REG_WR, 0x0163}, /* TVAR_ash_pGAS[246] */  
+	{S5K6AAFX_REG_WR, 0x015B}, /* TVAR_ash_pGAS[247] */  
+	{S5K6AAFX_REG_WR, 0x0131}, /* TVAR_ash_pGAS[248] */  
+	{S5K6AAFX_REG_WR, 0x00EB}, /* TVAR_ash_pGAS[249] */  
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[250] */  
+	{S5K6AAFX_REG_WR, 0x0078}, /* TVAR_ash_pGAS[251] */  
+	{S5K6AAFX_REG_WR, 0x005C}, /* TVAR_ash_pGAS[252] */  
+	{S5K6AAFX_REG_WR, 0x0057}, /* TVAR_ash_pGAS[253] */  
+	{S5K6AAFX_REG_WR, 0x0068}, /* TVAR_ash_pGAS[254] */  
+	{S5K6AAFX_REG_WR, 0x0091}, /* TVAR_ash_pGAS[255] */  
+	{S5K6AAFX_REG_WR, 0x00CD}, /* TVAR_ash_pGAS[256] */  
+	{S5K6AAFX_REG_WR, 0x0115}, /* TVAR_ash_pGAS[257] */  
+	{S5K6AAFX_REG_WR, 0x0150}, /* TVAR_ash_pGAS[258] */  
+	{S5K6AAFX_REG_WR, 0x0180}, /* TVAR_ash_pGAS[259] */  
+	{S5K6AAFX_REG_WR, 0x0181}, /* TVAR_ash_pGAS[260] */  
+	{S5K6AAFX_REG_WR, 0x0158}, /* TVAR_ash_pGAS[261] */  
+	{S5K6AAFX_REG_WR, 0x012B}, /* TVAR_ash_pGAS[262] */  
+	{S5K6AAFX_REG_WR, 0x00F3}, /* TVAR_ash_pGAS[263] */  
+	{S5K6AAFX_REG_WR, 0x00C4}, /* TVAR_ash_pGAS[264] */  
+	{S5K6AAFX_REG_WR, 0x00AB}, /* TVAR_ash_pGAS[265] */  
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[266] */  
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[267] */  
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[268] */  
+	{S5K6AAFX_REG_WR, 0x0119}, /* TVAR_ash_pGAS[269] */  
+	{S5K6AAFX_REG_WR, 0x0156}, /* TVAR_ash_pGAS[270] */  
+	{S5K6AAFX_REG_WR, 0x017E}, /* TVAR_ash_pGAS[271] */  
+	{S5K6AAFX_REG_WR, 0x01BB}, /* TVAR_ash_pGAS[272] */  
+	{S5K6AAFX_REG_WR, 0x01CF}, /* TVAR_ash_pGAS[273] */  
+	{S5K6AAFX_REG_WR, 0x017C}, /* TVAR_ash_pGAS[274] */  
+	{S5K6AAFX_REG_WR, 0x015C}, /* TVAR_ash_pGAS[275] */  
+	{S5K6AAFX_REG_WR, 0x0135}, /* TVAR_ash_pGAS[276] */  
+	{S5K6AAFX_REG_WR, 0x010F}, /* TVAR_ash_pGAS[277] */  
+	{S5K6AAFX_REG_WR, 0x00F9}, /* TVAR_ash_pGAS[278] */  
+	{S5K6AAFX_REG_WR, 0x00F8}, /* TVAR_ash_pGAS[279] */  
+	{S5K6AAFX_REG_WR, 0x0107}, /* TVAR_ash_pGAS[280] */  
+	{S5K6AAFX_REG_WR, 0x012B}, /* TVAR_ash_pGAS[281] */  
+	{S5K6AAFX_REG_WR, 0x015A}, /* TVAR_ash_pGAS[282] */  
+	{S5K6AAFX_REG_WR, 0x0183}, /* TVAR_ash_pGAS[283] */  
+	{S5K6AAFX_REG_WR, 0x01A6}, /* TVAR_ash_pGAS[284] */  
+	{S5K6AAFX_REG_WR, 0x0219}, /* TVAR_ash_pGAS[285] */  
+	{S5K6AAFX_REG_WR, 0x01E9}, /* TVAR_ash_pGAS[286] */  
+	{S5K6AAFX_REG_WR, 0x0167}, /* TVAR_ash_pGAS[287] */  
+	{S5K6AAFX_REG_WR, 0x0133}, /* TVAR_ash_pGAS[288] */  
+	{S5K6AAFX_REG_WR, 0x011B}, /* TVAR_ash_pGAS[289] */  
+	{S5K6AAFX_REG_WR, 0x0102}, /* TVAR_ash_pGAS[290] */  
+	{S5K6AAFX_REG_WR, 0x00F5}, /* TVAR_ash_pGAS[291] */  
+	{S5K6AAFX_REG_WR, 0x00F3}, /* TVAR_ash_pGAS[292] */  
+	{S5K6AAFX_REG_WR, 0x0100}, /* TVAR_ash_pGAS[293] */  
+	{S5K6AAFX_REG_WR, 0x011D}, /* TVAR_ash_pGAS[294] */  
+	{S5K6AAFX_REG_WR, 0x013B}, /* TVAR_ash_pGAS[295] */  
+	{S5K6AAFX_REG_WR, 0x0153}, /* TVAR_ash_pGAS[296] */  
+	{S5K6AAFX_REG_WR, 0x018B}, /* TVAR_ash_pGAS[297] */  
+	{S5K6AAFX_REG_WR, 0x023A}, /* TVAR_ash_pGAS[298] */  
+	{S5K6AAFX_REG_WR, 0x017F}, /* TVAR_ash_pGAS[299] */  
+	{S5K6AAFX_REG_WR, 0x0136}, /* TVAR_ash_pGAS[300] */  
+	{S5K6AAFX_REG_WR, 0x0112}, /* TVAR_ash_pGAS[301] */  
+	{S5K6AAFX_REG_WR, 0x00E7}, /* TVAR_ash_pGAS[302] */  
+	{S5K6AAFX_REG_WR, 0x00C3}, /* TVAR_ash_pGAS[303] */  
+	{S5K6AAFX_REG_WR, 0x00AC}, /* TVAR_ash_pGAS[304] */  
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[305] */  
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[306] */  
+	{S5K6AAFX_REG_WR, 0x00DD}, /* TVAR_ash_pGAS[307] */  
+	{S5K6AAFX_REG_WR, 0x010B}, /* TVAR_ash_pGAS[308] */  
+	{S5K6AAFX_REG_WR, 0x0134}, /* TVAR_ash_pGAS[309] */  
+	{S5K6AAFX_REG_WR, 0x0151}, /* TVAR_ash_pGAS[310] */  
+	{S5K6AAFX_REG_WR, 0x01A3}, /* TVAR_ash_pGAS[311] */  
+	{S5K6AAFX_REG_WR, 0x014F}, /* TVAR_ash_pGAS[312] */  
+	{S5K6AAFX_REG_WR, 0x0123}, /* TVAR_ash_pGAS[313] */  
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[314] */  
+	{S5K6AAFX_REG_WR, 0x00B1}, /* TVAR_ash_pGAS[315] */  
+	{S5K6AAFX_REG_WR, 0x0083}, /* TVAR_ash_pGAS[316] */  
+	{S5K6AAFX_REG_WR, 0x0067}, /* TVAR_ash_pGAS[317] */  
+	{S5K6AAFX_REG_WR, 0x0061}, /* TVAR_ash_pGAS[318] */  
+	{S5K6AAFX_REG_WR, 0x0070}, /* TVAR_ash_pGAS[319] */  
+	{S5K6AAFX_REG_WR, 0x0098}, /* TVAR_ash_pGAS[320] */  
+	{S5K6AAFX_REG_WR, 0x00D0}, /* TVAR_ash_pGAS[321] */  
+	{S5K6AAFX_REG_WR, 0x010E}, /* TVAR_ash_pGAS[322] */  
+	{S5K6AAFX_REG_WR, 0x013A}, /* TVAR_ash_pGAS[323] */  
+	{S5K6AAFX_REG_WR, 0x0165}, /* TVAR_ash_pGAS[324] */  
+	{S5K6AAFX_REG_WR, 0x013C}, /* TVAR_ash_pGAS[325] */  
+	{S5K6AAFX_REG_WR, 0x010A}, /* TVAR_ash_pGAS[326] */  
+	{S5K6AAFX_REG_WR, 0x00C3}, /* TVAR_ash_pGAS[327] */  
+	{S5K6AAFX_REG_WR, 0x0080}, /* TVAR_ash_pGAS[328] */  
+	{S5K6AAFX_REG_WR, 0x004E}, /* TVAR_ash_pGAS[329] */  
+	{S5K6AAFX_REG_WR, 0x0032}, /* TVAR_ash_pGAS[330] */  
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[331] */  
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[332] */  
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[333] */  
+	{S5K6AAFX_REG_WR, 0x0099}, /* TVAR_ash_pGAS[334] */  
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[335] */  
+	{S5K6AAFX_REG_WR, 0x0121}, /* TVAR_ash_pGAS[336] */  
+	{S5K6AAFX_REG_WR, 0x014E}, /* TVAR_ash_pGAS[337] */  
+	{S5K6AAFX_REG_WR, 0x0133}, /* TVAR_ash_pGAS[338] */  
+	{S5K6AAFX_REG_WR, 0x00F5}, /* TVAR_ash_pGAS[339] */  
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[340] */  
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[341] */  
+	{S5K6AAFX_REG_WR, 0x002E}, /* TVAR_ash_pGAS[342] */  
+	{S5K6AAFX_REG_WR, 0x0012}, /* TVAR_ash_pGAS[343] */  
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[344] */  
+	{S5K6AAFX_REG_WR, 0x0018}, /* TVAR_ash_pGAS[345] */  
+	{S5K6AAFX_REG_WR, 0x003A}, /* TVAR_ash_pGAS[346] */  
+	{S5K6AAFX_REG_WR, 0x0071}, /* TVAR_ash_pGAS[347] */  
+	{S5K6AAFX_REG_WR, 0x00BC}, /* TVAR_ash_pGAS[348] */  
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[349] */  
+	{S5K6AAFX_REG_WR, 0x013D}, /* TVAR_ash_pGAS[350] */  
+	{S5K6AAFX_REG_WR, 0x0131}, /* TVAR_ash_pGAS[351] */  
+	{S5K6AAFX_REG_WR, 0x00EF}, /* TVAR_ash_pGAS[352] */  
+	{S5K6AAFX_REG_WR, 0x009B}, /* TVAR_ash_pGAS[353] */  
+	{S5K6AAFX_REG_WR, 0x0054}, /* TVAR_ash_pGAS[354] */  
+	{S5K6AAFX_REG_WR, 0x0023}, /* TVAR_ash_pGAS[355] */  
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[356] */  
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[357] */  
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[358] */  
+	{S5K6AAFX_REG_WR, 0x002B}, /* TVAR_ash_pGAS[359] */  
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[360] */  
+	{S5K6AAFX_REG_WR, 0x00A9}, /* TVAR_ash_pGAS[361] */  
+	{S5K6AAFX_REG_WR, 0x00F6}, /* TVAR_ash_pGAS[362] */  
+	{S5K6AAFX_REG_WR, 0x0133}, /* TVAR_ash_pGAS[363] */  
+	{S5K6AAFX_REG_WR, 0x013C}, /* TVAR_ash_pGAS[364] */  
+	{S5K6AAFX_REG_WR, 0x00FB}, /* TVAR_ash_pGAS[365] */  
+	{S5K6AAFX_REG_WR, 0x00A6}, /* TVAR_ash_pGAS[366] */  
+	{S5K6AAFX_REG_WR, 0x005E}, /* TVAR_ash_pGAS[367] */  
+	{S5K6AAFX_REG_WR, 0x002C}, /* TVAR_ash_pGAS[368] */  
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[369] */  
+	{S5K6AAFX_REG_WR, 0x0006}, /* TVAR_ash_pGAS[370] */  
+	{S5K6AAFX_REG_WR, 0x0010}, /* TVAR_ash_pGAS[371] */  
+	{S5K6AAFX_REG_WR, 0x0030}, /* TVAR_ash_pGAS[372] */  
+	{S5K6AAFX_REG_WR, 0x0063}, /* TVAR_ash_pGAS[373] */  
+	{S5K6AAFX_REG_WR, 0x00AA}, /* TVAR_ash_pGAS[374] */  
+	{S5K6AAFX_REG_WR, 0x00F4}, /* TVAR_ash_pGAS[375] */  
+	{S5K6AAFX_REG_WR, 0x0133}, /* TVAR_ash_pGAS[376] */  
+	{S5K6AAFX_REG_WR, 0x0155}, /* TVAR_ash_pGAS[377] */  
+	{S5K6AAFX_REG_WR, 0x011B}, /* TVAR_ash_pGAS[378] */  
+	{S5K6AAFX_REG_WR, 0x00C9}, /* TVAR_ash_pGAS[379] */  
+	{S5K6AAFX_REG_WR, 0x0080}, /* TVAR_ash_pGAS[380] */  
+	{S5K6AAFX_REG_WR, 0x004B}, /* TVAR_ash_pGAS[381] */  
+	{S5K6AAFX_REG_WR, 0x002C}, /* TVAR_ash_pGAS[382] */  
+	{S5K6AAFX_REG_WR, 0x0022}, /* TVAR_ash_pGAS[383] */  
+	{S5K6AAFX_REG_WR, 0x002C}, /* TVAR_ash_pGAS[384] */  
+	{S5K6AAFX_REG_WR, 0x004B}, /* TVAR_ash_pGAS[385] */  
+	{S5K6AAFX_REG_WR, 0x007D}, /* TVAR_ash_pGAS[386] */  
+	{S5K6AAFX_REG_WR, 0x00C2}, /* TVAR_ash_pGAS[387] */  
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[388] */  
+	{S5K6AAFX_REG_WR, 0x013D}, /* TVAR_ash_pGAS[389] */  
+	{S5K6AAFX_REG_WR, 0x0172}, /* TVAR_ash_pGAS[390] */  
+	{S5K6AAFX_REG_WR, 0x0144}, /* TVAR_ash_pGAS[391] */  
+	{S5K6AAFX_REG_WR, 0x00FD}, /* TVAR_ash_pGAS[392] */  
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[393] */  
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[394] */  
+	{S5K6AAFX_REG_WR, 0x005F}, /* TVAR_ash_pGAS[395] */  
+	{S5K6AAFX_REG_WR, 0x0053}, /* TVAR_ash_pGAS[396] */  
+	{S5K6AAFX_REG_WR, 0x005D}, /* TVAR_ash_pGAS[397] */  
+	{S5K6AAFX_REG_WR, 0x007B}, /* TVAR_ash_pGAS[398] */  
+	{S5K6AAFX_REG_WR, 0x00AB}, /* TVAR_ash_pGAS[399] */  
+	{S5K6AAFX_REG_WR, 0x00E9}, /* TVAR_ash_pGAS[400] */  
+	{S5K6AAFX_REG_WR, 0x0120}, /* TVAR_ash_pGAS[401] */  
+	{S5K6AAFX_REG_WR, 0x0150}, /* TVAR_ash_pGAS[402] */  
+	{S5K6AAFX_REG_WR, 0x019B}, /* TVAR_ash_pGAS[403] */  
+	{S5K6AAFX_REG_WR, 0x016C}, /* TVAR_ash_pGAS[404] */  
+	{S5K6AAFX_REG_WR, 0x013D}, /* TVAR_ash_pGAS[405] */  
+	{S5K6AAFX_REG_WR, 0x0101}, /* TVAR_ash_pGAS[406] */  
+	{S5K6AAFX_REG_WR, 0x00CE}, /* TVAR_ash_pGAS[407] */  
+	{S5K6AAFX_REG_WR, 0x00AD}, /* TVAR_ash_pGAS[408] */  
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[409] */  
+	{S5K6AAFX_REG_WR, 0x00AA}, /* TVAR_ash_pGAS[410] */  
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[411] */  
+	{S5K6AAFX_REG_WR, 0x00F1}, /* TVAR_ash_pGAS[412] */  
+	{S5K6AAFX_REG_WR, 0x0121}, /* TVAR_ash_pGAS[413] */  
+	{S5K6AAFX_REG_WR, 0x0148}, /* TVAR_ash_pGAS[414] */  
+	{S5K6AAFX_REG_WR, 0x0185}, /* TVAR_ash_pGAS[415] */  
+	{S5K6AAFX_REG_WR, 0x01EC}, /* TVAR_ash_pGAS[416] */  
+	{S5K6AAFX_REG_WR, 0x0193}, /* TVAR_ash_pGAS[417] */  
+	{S5K6AAFX_REG_WR, 0x016E}, /* TVAR_ash_pGAS[418] */  
+	{S5K6AAFX_REG_WR, 0x0145}, /* TVAR_ash_pGAS[419] */  
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[420] */  
+	{S5K6AAFX_REG_WR, 0x00FE}, /* TVAR_ash_pGAS[421] */  
+	{S5K6AAFX_REG_WR, 0x00F3}, /* TVAR_ash_pGAS[422] */  
+	{S5K6AAFX_REG_WR, 0x00FA}, /* TVAR_ash_pGAS[423] */  
+	{S5K6AAFX_REG_WR, 0x0111}, /* TVAR_ash_pGAS[424] */  
+	{S5K6AAFX_REG_WR, 0x0132}, /* TVAR_ash_pGAS[425] */  
+	{S5K6AAFX_REG_WR, 0x0151}, /* TVAR_ash_pGAS[426] */  
+	{S5K6AAFX_REG_WR, 0x0173}, /* TVAR_ash_pGAS[427] */  
+	{S5K6AAFX_REG_WR, 0x01E3}, /* TVAR_ash_pGAS[428] */  
+	{S5K6AAFX_REG_WR, 0x0172}, /* TVAR_ash_pGAS[429] */  
+	{S5K6AAFX_REG_WR, 0x0109}, /* TVAR_ash_pGAS[430] */  
+	{S5K6AAFX_REG_WR, 0x00E0}, /* TVAR_ash_pGAS[431] */  
+	{S5K6AAFX_REG_WR, 0x00D2}, /* TVAR_ash_pGAS[432] */  
+	{S5K6AAFX_REG_WR, 0x00C5}, /* TVAR_ash_pGAS[433] */  
+	{S5K6AAFX_REG_WR, 0x00BE}, /* TVAR_ash_pGAS[434] */  
+	{S5K6AAFX_REG_WR, 0x00C5}, /* TVAR_ash_pGAS[435] */  
+	{S5K6AAFX_REG_WR, 0x00D5}, /* TVAR_ash_pGAS[436] */  
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[437] */  
+	{S5K6AAFX_REG_WR, 0x0109}, /* TVAR_ash_pGAS[438] */  
+	{S5K6AAFX_REG_WR, 0x011D}, /* TVAR_ash_pGAS[439] */  
+	{S5K6AAFX_REG_WR, 0x014E}, /* TVAR_ash_pGAS[440] */  
+	{S5K6AAFX_REG_WR, 0x01E5}, /* TVAR_ash_pGAS[441] */  
+	{S5K6AAFX_REG_WR, 0x011A}, /* TVAR_ash_pGAS[442] */  
+	{S5K6AAFX_REG_WR, 0x00E1}, /* TVAR_ash_pGAS[443] */  
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[444] */  
+	{S5K6AAFX_REG_WR, 0x00AB}, /* TVAR_ash_pGAS[445] */  
+	{S5K6AAFX_REG_WR, 0x0094}, /* TVAR_ash_pGAS[446] */  
+	{S5K6AAFX_REG_WR, 0x0088}, /* TVAR_ash_pGAS[447] */  
+	{S5K6AAFX_REG_WR, 0x008B}, /* TVAR_ash_pGAS[448] */  
+	{S5K6AAFX_REG_WR, 0x009D}, /* TVAR_ash_pGAS[449] */  
+	{S5K6AAFX_REG_WR, 0x00BF}, /* TVAR_ash_pGAS[450] */  
+	{S5K6AAFX_REG_WR, 0x00E6}, /* TVAR_ash_pGAS[451] */  
+	{S5K6AAFX_REG_WR, 0x0107}, /* TVAR_ash_pGAS[452] */  
+	{S5K6AAFX_REG_WR, 0x011B}, /* TVAR_ash_pGAS[453] */  
+	{S5K6AAFX_REG_WR, 0x0164}, /* TVAR_ash_pGAS[454] */  
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[455] */  
+	{S5K6AAFX_REG_WR, 0x00CD}, /* TVAR_ash_pGAS[456] */  
+	{S5K6AAFX_REG_WR, 0x00A8}, /* TVAR_ash_pGAS[457] */  
+	{S5K6AAFX_REG_WR, 0x007F}, /* TVAR_ash_pGAS[458] */  
+	{S5K6AAFX_REG_WR, 0x0060}, /* TVAR_ash_pGAS[459] */  
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[460] */  
+	{S5K6AAFX_REG_WR, 0x0050}, /* TVAR_ash_pGAS[461] */  
+	{S5K6AAFX_REG_WR, 0x0063}, /* TVAR_ash_pGAS[462] */  
+	{S5K6AAFX_REG_WR, 0x0085}, /* TVAR_ash_pGAS[463] */  
+	{S5K6AAFX_REG_WR, 0x00B6}, /* TVAR_ash_pGAS[464] */  
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[465] */  
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[466] */  
+	{S5K6AAFX_REG_WR, 0x0129}, /* TVAR_ash_pGAS[467] */  
+	{S5K6AAFX_REG_WR, 0x00D9}, /* TVAR_ash_pGAS[468] */  
+	{S5K6AAFX_REG_WR, 0x00B4}, /* TVAR_ash_pGAS[469] */  
+	{S5K6AAFX_REG_WR, 0x0084}, /* TVAR_ash_pGAS[470] */  
+	{S5K6AAFX_REG_WR, 0x0056}, /* TVAR_ash_pGAS[471] */  
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[472] */  
+	{S5K6AAFX_REG_WR, 0x0024}, /* TVAR_ash_pGAS[473] */  
+	{S5K6AAFX_REG_WR, 0x0024}, /* TVAR_ash_pGAS[474] */  
+	{S5K6AAFX_REG_WR, 0x0034}, /* TVAR_ash_pGAS[475] */  
+	{S5K6AAFX_REG_WR, 0x0055}, /* TVAR_ash_pGAS[476] */  
+	{S5K6AAFX_REG_WR, 0x0086}, /* TVAR_ash_pGAS[477] */  
+	{S5K6AAFX_REG_WR, 0x00BF}, /* TVAR_ash_pGAS[478] */  
+	{S5K6AAFX_REG_WR, 0x00ED}, /* TVAR_ash_pGAS[479] */  
+	{S5K6AAFX_REG_WR, 0x0110}, /* TVAR_ash_pGAS[480] */  
+	{S5K6AAFX_REG_WR, 0x00CD}, /* TVAR_ash_pGAS[481] */  
+	{S5K6AAFX_REG_WR, 0x00A2}, /* TVAR_ash_pGAS[482] */  
+	{S5K6AAFX_REG_WR, 0x006C}, /* TVAR_ash_pGAS[483] */  
+	{S5K6AAFX_REG_WR, 0x003C}, /* TVAR_ash_pGAS[484] */  
+	{S5K6AAFX_REG_WR, 0x001B}, /* TVAR_ash_pGAS[485] */  
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[486] */  
+	{S5K6AAFX_REG_WR, 0x0009}, /* TVAR_ash_pGAS[487] */  
+	{S5K6AAFX_REG_WR, 0x0016}, /* TVAR_ash_pGAS[488] */  
+	{S5K6AAFX_REG_WR, 0x0035}, /* TVAR_ash_pGAS[489] */  
+	{S5K6AAFX_REG_WR, 0x0062}, /* TVAR_ash_pGAS[490] */  
+	{S5K6AAFX_REG_WR, 0x009C}, /* TVAR_ash_pGAS[491] */  
+	{S5K6AAFX_REG_WR, 0x00D1}, /* TVAR_ash_pGAS[492] */  
+	{S5K6AAFX_REG_WR, 0x00FB}, /* TVAR_ash_pGAS[493] */  
+	{S5K6AAFX_REG_WR, 0x00CC}, /* TVAR_ash_pGAS[494] */  
+	{S5K6AAFX_REG_WR, 0x009F}, /* TVAR_ash_pGAS[495] */  
+	{S5K6AAFX_REG_WR, 0x0065}, /* TVAR_ash_pGAS[496] */  
+	{S5K6AAFX_REG_WR, 0x0034}, /* TVAR_ash_pGAS[497] */  
+	{S5K6AAFX_REG_WR, 0x0013}, /* TVAR_ash_pGAS[498] */  
+	{S5K6AAFX_REG_WR, 0x0003}, /* TVAR_ash_pGAS[499] */  
+	{S5K6AAFX_REG_WR, 0x0000}, /* TVAR_ash_pGAS[500] */  
+	{S5K6AAFX_REG_WR, 0x000B}, /* TVAR_ash_pGAS[501] */  
+	{S5K6AAFX_REG_WR, 0x0026}, /* TVAR_ash_pGAS[502] */  
+	{S5K6AAFX_REG_WR, 0x0051}, /* TVAR_ash_pGAS[503] */  
+	{S5K6AAFX_REG_WR, 0x008A}, /* TVAR_ash_pGAS[504] */  
+	{S5K6AAFX_REG_WR, 0x00C0}, /* TVAR_ash_pGAS[505] */  
+	{S5K6AAFX_REG_WR, 0x00ED}, /* TVAR_ash_pGAS[506] */  
+	{S5K6AAFX_REG_WR, 0x00D4}, /* TVAR_ash_pGAS[507] */  
+	{S5K6AAFX_REG_WR, 0x00A7}, /* TVAR_ash_pGAS[508] */  
+	{S5K6AAFX_REG_WR, 0x006D}, /* TVAR_ash_pGAS[509] */  
+	{S5K6AAFX_REG_WR, 0x003C}, /* TVAR_ash_pGAS[510] */  
+	{S5K6AAFX_REG_WR, 0x001A}, /* TVAR_ash_pGAS[511] */  
+	{S5K6AAFX_REG_WR, 0x0008}, /* TVAR_ash_pGAS[512] */  
+	{S5K6AAFX_REG_WR, 0x0005}, /* TVAR_ash_pGAS[513] */  
+	{S5K6AAFX_REG_WR, 0x000F}, /* TVAR_ash_pGAS[514] */  
+	{S5K6AAFX_REG_WR, 0x0029}, /* TVAR_ash_pGAS[515] */  
+	{S5K6AAFX_REG_WR, 0x0051}, /* TVAR_ash_pGAS[516] */  
+	{S5K6AAFX_REG_WR, 0x0087}, /* TVAR_ash_pGAS[517] */  
+	{S5K6AAFX_REG_WR, 0x00BC}, /* TVAR_ash_pGAS[518] */  
+	{S5K6AAFX_REG_WR, 0x00EB}, /* TVAR_ash_pGAS[519] */  
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[520] */  
+	{S5K6AAFX_REG_WR, 0x00C3}, /* TVAR_ash_pGAS[521] */  
+	{S5K6AAFX_REG_WR, 0x008A}, /* TVAR_ash_pGAS[522] */  
+	{S5K6AAFX_REG_WR, 0x0059}, /* TVAR_ash_pGAS[523] */  
+	{S5K6AAFX_REG_WR, 0x0036}, /* TVAR_ash_pGAS[524] */  
+	{S5K6AAFX_REG_WR, 0x0022}, /* TVAR_ash_pGAS[525] */  
+	{S5K6AAFX_REG_WR, 0x001D}, /* TVAR_ash_pGAS[526] */  
+	{S5K6AAFX_REG_WR, 0x0027}, /* TVAR_ash_pGAS[527] */  
+	{S5K6AAFX_REG_WR, 0x0040}, /* TVAR_ash_pGAS[528] */  
+	{S5K6AAFX_REG_WR, 0x0067}, /* TVAR_ash_pGAS[529] */  
+	{S5K6AAFX_REG_WR, 0x009A}, /* TVAR_ash_pGAS[530] */  
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[531] */  
+	{S5K6AAFX_REG_WR, 0x00F5}, /* TVAR_ash_pGAS[532] */  
+	{S5K6AAFX_REG_WR, 0x0106}, /* TVAR_ash_pGAS[533] */  
+	{S5K6AAFX_REG_WR, 0x00E8}, /* TVAR_ash_pGAS[534] */  
+	{S5K6AAFX_REG_WR, 0x00B8}, /* TVAR_ash_pGAS[535] */  
+	{S5K6AAFX_REG_WR, 0x0087}, /* TVAR_ash_pGAS[536] */  
+	{S5K6AAFX_REG_WR, 0x0064}, /* TVAR_ash_pGAS[537] */  
+	{S5K6AAFX_REG_WR, 0x004F}, /* TVAR_ash_pGAS[538] */  
+	{S5K6AAFX_REG_WR, 0x0049}, /* TVAR_ash_pGAS[539] */  
+	{S5K6AAFX_REG_WR, 0x0053}, /* TVAR_ash_pGAS[540] */  
+	{S5K6AAFX_REG_WR, 0x006C}, /* TVAR_ash_pGAS[541] */  
+	{S5K6AAFX_REG_WR, 0x008F}, /* TVAR_ash_pGAS[542] */  
+	{S5K6AAFX_REG_WR, 0x00BD}, /* TVAR_ash_pGAS[543] */  
+	{S5K6AAFX_REG_WR, 0x00E2}, /* TVAR_ash_pGAS[544] */  
+	{S5K6AAFX_REG_WR, 0x0109}, /* TVAR_ash_pGAS[545] */  
+	{S5K6AAFX_REG_WR, 0x012F}, /* TVAR_ash_pGAS[546] */  
+	{S5K6AAFX_REG_WR, 0x010C}, /* TVAR_ash_pGAS[547] */  
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[548] */  
+	{S5K6AAFX_REG_WR, 0x00C6}, /* TVAR_ash_pGAS[549] */  
+	{S5K6AAFX_REG_WR, 0x00A5}, /* TVAR_ash_pGAS[550] */  
+	{S5K6AAFX_REG_WR, 0x0091}, /* TVAR_ash_pGAS[551] */  
+	{S5K6AAFX_REG_WR, 0x008D}, /* TVAR_ash_pGAS[552] */  
+	{S5K6AAFX_REG_WR, 0x0095}, /* TVAR_ash_pGAS[553] */  
+	{S5K6AAFX_REG_WR, 0x00AD}, /* TVAR_ash_pGAS[554] */  
+	{S5K6AAFX_REG_WR, 0x00CC}, /* TVAR_ash_pGAS[555] */  
+	{S5K6AAFX_REG_WR, 0x00EE}, /* TVAR_ash_pGAS[556] */  
+	{S5K6AAFX_REG_WR, 0x0108}, /* TVAR_ash_pGAS[557] */  
+	{S5K6AAFX_REG_WR, 0x013A}, /* TVAR_ash_pGAS[558] */  
+	{S5K6AAFX_REG_WR, 0x016F}, /* TVAR_ash_pGAS[559] */  
+	{S5K6AAFX_REG_WR, 0x012B}, /* TVAR_ash_pGAS[560] */  
+	{S5K6AAFX_REG_WR, 0x0110}, /* TVAR_ash_pGAS[561] */  
+	{S5K6AAFX_REG_WR, 0x00F8}, /* TVAR_ash_pGAS[562] */  
+	{S5K6AAFX_REG_WR, 0x00DD}, /* TVAR_ash_pGAS[563] */  
+	{S5K6AAFX_REG_WR, 0x00CE}, /* TVAR_ash_pGAS[564] */  
+	{S5K6AAFX_REG_WR, 0x00CA}, /* TVAR_ash_pGAS[565] */  
+	{S5K6AAFX_REG_WR, 0x00D1}, /* TVAR_ash_pGAS[566] */  
+	{S5K6AAFX_REG_WR, 0x00E3}, /* TVAR_ash_pGAS[567] */  
+	{S5K6AAFX_REG_WR, 0x00FC}, /* TVAR_ash_pGAS[568] */  
+	{S5K6AAFX_REG_WR, 0x010D}, /* TVAR_ash_pGAS[569] */  
+	{S5K6AAFX_REG_WR, 0x0127}, /* TVAR_ash_pGAS[570] */  
+	{S5K6AAFX_REG_WR, 0x0184}, /* TVAR_ash_pGAS[571] */  
+	/* parawrite _end - TVAR_ash_pGAS */
+
+	{S5K6AAFX_REG_W_ADDL, 0x0C48},
+	{S5K6AAFX_REG_WR, 0x0520}, /* R*/ //{S5K6AAFX_REG_WR, 0x0550}
+	{S5K6AAFX_REG_WR, 0x0400}, /* G*/ //{S5K6AAFX_REG_WR, 0x0400}
+	{S5K6AAFX_REG_WR, 0x0660}, /*B */ //{S5K6AAFX_REG_WR, 0x0600}
+
+#if 0
+	{S5K6AAFX_REG_W_ADDL, 0x0F12},
+	{S5K6AAFX_REG_WR, 0x02C9}, /* awbb_GLocusR */
+	{S5K6AAFX_REG_WR, 0x033F}, /* awbb_GLocusB */
+#endif
+
+	/* param_start - TVAR_ash_AwbAshCord */
+	{S5K6AAFX_REG_W_ADDL, 0x0704},
+	{S5K6AAFX_REG_WR, 0x00ED/*0x00C7*/}, /* TVAR_ash_AwbAshCord[0] */
+	{S5K6AAFX_REG_WR, 0x0124/*0x00F7*/}, /* TVAR_ash_AwbAshCord[1] */
+	{S5K6AAFX_REG_WR, 0x012B/*0x0107*/}, /* TVAR_ash_AwbAshCord[2] */
+	{S5K6AAFX_REG_WR, 0x014A/*0x0142*/}, /* TVAR_ash_AwbAshCord[3] */
+	{S5K6AAFX_REG_WR, 0x0190/*0x017A*/}, /* TVAR_ash_AwbAshCord[4] */
+	{S5K6AAFX_REG_WR, 0x01B2/*0x01A0*/}, /* TVAR_ash_AwbAshCord[5] */
+	{S5K6AAFX_REG_WR, 0x01C4/*0x01B6*/}, /* TVAR_ash_AwbAshCord[6] */
+	/* param_end - TVAR_ash_AwbAshCord */
+
+	{S5K6AAFX_REG_W_ADDL, 0x0754},
+	{S5K6AAFX_REG_WR, 0x247C},
+	{S5K6AAFX_REG_WR, 0x7000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0E1A},
+	{S5K6AAFX_REG_WR, 0x0138},
+
+	/* AWB Speed */
+	{S5K6AAFX_REG_W_ADDL, 0x0E7C},
+	{S5K6AAFX_REG_WR, 0x0010},
+	{S5K6AAFX_REG_WR, 0x0003},
+
+	/* param_start - awbb_IndoorGrZones_m_BGrid */
+	{S5K6AAFX_REG_W_ADDL, 0x0C50},
+	{S5K6AAFX_REG_WR, 0x03BA},
+	{S5K6AAFX_REG_WR, 0x03E3},
+	{S5K6AAFX_REG_WR, 0x039A},
+	{S5K6AAFX_REG_WR, 0x03DB},
+	{S5K6AAFX_REG_WR, 0x037B},
+	{S5K6AAFX_REG_WR, 0x03CD},
+	{S5K6AAFX_REG_WR, 0x035D},
+	{S5K6AAFX_REG_WR, 0x03B2},
+	{S5K6AAFX_REG_WR, 0x0342},
+	{S5K6AAFX_REG_WR, 0x0397},
+	{S5K6AAFX_REG_WR, 0x0325},
+	{S5K6AAFX_REG_WR, 0x0380},
+	{S5K6AAFX_REG_WR, 0x030E},
+	{S5K6AAFX_REG_WR, 0x0369},
+	{S5K6AAFX_REG_WR, 0x02F8},
+	{S5K6AAFX_REG_WR, 0x034B},
+	{S5K6AAFX_REG_WR, 0x02DE},
+	{S5K6AAFX_REG_WR, 0x0336},
+	{S5K6AAFX_REG_WR, 0x02BF},
+	{S5K6AAFX_REG_WR, 0x031F},
+	{S5K6AAFX_REG_WR, 0x02A6},
+	{S5K6AAFX_REG_WR, 0x0306},
+	{S5K6AAFX_REG_WR, 0x028D},
+	{S5K6AAFX_REG_WR, 0x02F4},
+	{S5K6AAFX_REG_WR, 0x027D},
+	{S5K6AAFX_REG_WR, 0x02DD},
+	{S5K6AAFX_REG_WR, 0x026C},
+	{S5K6AAFX_REG_WR, 0x02C2},
+	{S5K6AAFX_REG_WR, 0x025C},
+	{S5K6AAFX_REG_WR, 0x02AE},
+	{S5K6AAFX_REG_WR, 0x024F},
+	{S5K6AAFX_REG_WR, 0x029D},
+	{S5K6AAFX_REG_WR, 0x0245},
+	{S5K6AAFX_REG_WR, 0x028B},
+	{S5K6AAFX_REG_WR, 0x023E},
+	{S5K6AAFX_REG_WR, 0x027F},
+	{S5K6AAFX_REG_WR, 0x0235},
+	{S5K6AAFX_REG_WR, 0x0272},
+	{S5K6AAFX_REG_WR, 0x022B},
+	{S5K6AAFX_REG_WR, 0x0267},
+	{S5K6AAFX_REG_WR, 0x0220},
+	{S5K6AAFX_REG_WR, 0x025B},
+	{S5K6AAFX_REG_WR, 0x0218},
+	{S5K6AAFX_REG_WR, 0x0250},
+	{S5K6AAFX_REG_WR, 0x020E},
+	{S5K6AAFX_REG_WR, 0x0246},
+	{S5K6AAFX_REG_WR, 0x0206},
+	{S5K6AAFX_REG_WR, 0x023D},
+	{S5K6AAFX_REG_WR, 0x01FB},
+	{S5K6AAFX_REG_WR, 0x0234},
+	{S5K6AAFX_REG_WR, 0x01F1},
+	{S5K6AAFX_REG_WR, 0x0229},
+	{S5K6AAFX_REG_WR, 0x01E7},
+	{S5K6AAFX_REG_WR, 0x0220},
+	{S5K6AAFX_REG_WR, 0x01DF},
+	{S5K6AAFX_REG_WR, 0x0216},
+	{S5K6AAFX_REG_WR, 0x01D2},
+	{S5K6AAFX_REG_WR, 0x020D},
+	{S5K6AAFX_REG_WR, 0x01C7},
+	{S5K6AAFX_REG_WR, 0x01FD},
+	{S5K6AAFX_REG_WR, 0x01C4},
+	{S5K6AAFX_REG_WR, 0x01EE},
+	{S5K6AAFX_REG_WR, 0x01D1},
+	{S5K6AAFX_REG_WR, 0x01E1},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* param_end - awbb_IndoorGrZones_m_BGrid */
+
+	{S5K6AAFX_REG_WR, 0x0004},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0CF8},
+	{S5K6AAFX_REG_WR, 0x010F},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+
+	/* param_start - SARR_usGammaLutRGBIndoor */
+	{S5K6AAFX_REG_W_ADDL, 0x04C8},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x000E},
+	{S5K6AAFX_REG_WR, 0x002C},
+	{S5K6AAFX_REG_WR, 0x005D},
+	{S5K6AAFX_REG_WR, 0x00C5},
+	{S5K6AAFX_REG_WR, 0x010F},
+	{S5K6AAFX_REG_WR, 0x0150},
+	{S5K6AAFX_REG_WR, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x01FD},
+	{S5K6AAFX_REG_WR, 0x0269},
+	{S5K6AAFX_REG_WR, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x031F},
+	{S5K6AAFX_REG_WR, 0x0364},
+	{S5K6AAFX_REG_WR, 0x03AE},
+	{S5K6AAFX_REG_WR, 0x03FF},
+
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x000E},
+	{S5K6AAFX_REG_WR, 0x002C},
+	{S5K6AAFX_REG_WR, 0x005D},
+	{S5K6AAFX_REG_WR, 0x00C5},
+	{S5K6AAFX_REG_WR, 0x010F},
+	{S5K6AAFX_REG_WR, 0x0150},
+	{S5K6AAFX_REG_WR, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x01FD},
+	{S5K6AAFX_REG_WR, 0x0269},
+	{S5K6AAFX_REG_WR, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x031F},
+	{S5K6AAFX_REG_WR, 0x0364},
+	{S5K6AAFX_REG_WR, 0x03AE},
+	{S5K6AAFX_REG_WR, 0x03FF},
+
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0x0001},
+	{S5K6AAFX_REG_WR, 0x000E},
+	{S5K6AAFX_REG_WR, 0x002C},
+	{S5K6AAFX_REG_WR, 0x005D},
+	{S5K6AAFX_REG_WR, 0x00C5},
+	{S5K6AAFX_REG_WR, 0x010F},
+	{S5K6AAFX_REG_WR, 0x0150},
+	{S5K6AAFX_REG_WR, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x01FD},
+	{S5K6AAFX_REG_WR, 0x0269},
+	{S5K6AAFX_REG_WR, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x031F},
+	{S5K6AAFX_REG_WR, 0x0364},
+	{S5K6AAFX_REG_WR, 0x03AE},
+	{S5K6AAFX_REG_WR, 0x03FF},
+	/* param_end - SARR_usGammaLutRGBIndoor */
+
+
+	{S5K6AAFX_REG_W_ADDL, 0x1000},
+	{S5K6AAFX_REG_WR, 0x003F},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0474},
+	{S5K6AAFX_REG_WR, 0x0112/*0x010F*//*0x0114*/},
+	{S5K6AAFX_REG_WR, 0x00EF/*0x00F1*//*0x00F9*/},
+
+	{S5K6AAFX_REG_W_ADDL, 0x2180},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x1006},
+	{S5K6AAFX_REG_WR, 0x001F},
+
+	{S5K6AAFX_REG_W_ADDL, 0x108E},
+	{S5K6AAFX_REG_WR, 0x00C7},
+	{S5K6AAFX_REG_WR, 0x00F7},
+	{S5K6AAFX_REG_WR, 0x0107},
+	{S5K6AAFX_REG_WR, 0x0142},
+	{S5K6AAFX_REG_WR, 0x017A},
+	{S5K6AAFX_REG_WR, 0x01A0},
+	{S5K6AAFX_REG_WR, 0x01B6},
+
+	{S5K6AAFX_REG_WR, 0x0100/*0x0112*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0122*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0136*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x00F6*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0100*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x00FE*/},
+	{S5K6AAFX_REG_WR, 0x0100/*0x0100*/},
+
+	/* param_start - TVAR_wbt_pBaseCcms */
+	{S5K6AAFX_REG_W_ADDL, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x01FA}, /* H */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* A */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* WW */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x01FA}, /* CW */
+	{S5K6AAFX_REG_WR, 0xFFB9},
+	{S5K6AAFX_REG_WR, 0xFFF8},
+	{S5K6AAFX_REG_WR, 0x0116},
+	{S5K6AAFX_REG_WR, 0x00BD},
+	{S5K6AAFX_REG_WR, 0xFF38},
+	{S5K6AAFX_REG_WR, 0xFF23},
+	{S5K6AAFX_REG_WR, 0x01AB},
+	{S5K6AAFX_REG_WR, 0xFF81},
+	{S5K6AAFX_REG_WR, 0xFF0D},
+	{S5K6AAFX_REG_WR, 0x0169},
+	{S5K6AAFX_REG_WR, 0x00DE},
+	{S5K6AAFX_REG_WR, 0xFFEF},
+	{S5K6AAFX_REG_WR, 0xFFCA},
+	{S5K6AAFX_REG_WR, 0x014D},
+	{S5K6AAFX_REG_WR, 0x01C3},
+	{S5K6AAFX_REG_WR, 0xFF7E},
+	{S5K6AAFX_REG_WR, 0x016F},
+
+	{S5K6AAFX_REG_WR, 0x030B/*0x020E*/}, /* D50 */
+	{S5K6AAFX_REG_WR, 0xFF9D/*0xFFAE*/},
+	{S5K6AAFX_REG_WR, 0x001C/*0xFFE6*/},
+	{S5K6AAFX_REG_WR, 0x00BD/*0x00D2*/},
+	{S5K6AAFX_REG_WR, 0x0137/*0x0105*/},
+	{S5K6AAFX_REG_WR, 0xFF22/*0xFF39*/},
+	{S5K6AAFX_REG_WR, 0xFDB5/*0xFE4F*/},
+	{S5K6AAFX_REG_WR, 0x01D2/*0x0268*/},
+	{S5K6AAFX_REG_WR, 0xFF7A/*0xFFA4*/},
+	{S5K6AAFX_REG_WR, 0xFCE1/*0xFEC3*/},
+	{S5K6AAFX_REG_WR, 0x0273/*0x0204*/},
+	{S5K6AAFX_REG_WR, 0x019A/*0x0092*/},
+	{S5K6AAFX_REG_WR, 0x000A/*0xFFB3*/},
+	{S5K6AAFX_REG_WR, 0xFF78/*0xFF87*/},
+	{S5K6AAFX_REG_WR, 0x0167/*0x01C7*/},
+	{S5K6AAFX_REG_WR, 0x0412/*0x026D*/},
+	{S5K6AAFX_REG_WR, 0xFF60/*0xFF32*/},
+	{S5K6AAFX_REG_WR, 0x0215/*0x0106*/},
+
+	{S5K6AAFX_REG_WR, 0x0255 /* 026C 02C2 01FA R*/}, /* D65 */    
+	{S5K6AAFX_REG_WR, 0xFFA7 /* FF9A FF99 FFB9  */},              
+	{S5K6AAFX_REG_WR, 0xFFF4 /* FFEB FFEB FFF8  */},              
+	{S5K6AAFX_REG_WR, 0x01D8 /* 0158 0112 00E0 0116 Y*/},             
+	{S5K6AAFX_REG_WR, 0x0145 /* 00D5 00DC 0159 00BD  */},              
+	{S5K6AAFX_REG_WR, 0xFF0B /* FEFA FF12 FF38  */},              
+	{S5K6AAFX_REG_WR, 0xFE8F /* FE8F FDCD FF23 G*/},              
+	{S5K6AAFX_REG_WR, 0x0216 /* 0216 0252 01AB  */},              
+	{S5K6AAFX_REG_WR, 0xFF16 /* FF16 FEB9 FF81  */},              
+	{S5K6AAFX_REG_WR, 0xFE9F /* FE9F FE03 FF0D C*/},              
+	{S5K6AAFX_REG_WR, 0x01BA /* 01BA 0237 0169  */},              
+	{S5K6AAFX_REG_WR, 0x00F5 /* 00F5 0163 00DE  */},              
+	{S5K6AAFX_REG_WR, 0xFF8D /* FFBE FF0A FFEF B*/},              
+	{S5K6AAFX_REG_WR, 0xFF8B /* FF75 FE35 FFCA  */},              
+	{S5K6AAFX_REG_WR, 0x028D /* 0202 0442 014D  */},              
+	{S5K6AAFX_REG_WR, 0x0215 /* 0215 02B2 01C3 M*/},              
+	{S5K6AAFX_REG_WR, 0xFF2E /* FF2E FEFF FF7E  */},              
+	{S5K6AAFX_REG_WR, 0x01BD /* 01BD 0220 016F  */},              
+	/* param_end - TVAR_wbt_pBaseCcms */
+
+	/* param_start - TVAR_wbt_pOutdoorCcm */
+	{S5K6AAFX_REG_W_ADDL, 0x2380},
+	{S5K6AAFX_REG_WR, 0x01F2/*0x01F2*//*0x019D*/}, /* TVAR_wbt_pOutdoorCcm[0] */
+	{S5K6AAFX_REG_WR, 0xFFC3/*0xFFc3*//*0xFFC8*/}, /* TVAR_wbt_pOutdoorCcm[1] */
+	{S5K6AAFX_REG_WR, 0xFFE3/*0xFFe3*//*0x000C*/}, /* TVAR_wbt_pOutdoorCcm[2] */
+	{S5K6AAFX_REG_WR, 0x00F9/*0x00F9*//*0x008D*/}, /* TVAR_wbt_pOutdoorCcm[3] */
+	{S5K6AAFX_REG_WR, 0x013F/*0x013F*//*0x00CD*/}, /* TVAR_wbt_pOutdoorCcm[4] */
+	{S5K6AAFX_REG_WR, 0xFF6E/*0xFF6E*//*0xFF3F*/}, /* TVAR_wbt_pOutdoorCcm[5] */
+	{S5K6AAFX_REG_WR, 0xFEBB/*0xFEbb*//*0xFEDD*/}, /* TVAR_wbt_pOutdoorCcm[6] */
+	{S5K6AAFX_REG_WR, 0x01F2/*0x01F2*//*0x01C6*/}, /* TVAR_wbt_pOutdoorCcm[7] */
+	{S5K6AAFX_REG_WR, 0xFEFA/*0xFEFA*//*0xFF77*/}, /* TVAR_wbt_pOutdoorCcm[8] */
+	{S5K6AAFX_REG_WR, 0xFF37/*0xFF37*//*0xFEAB*/}, /* TVAR_wbt_pOutdoorCcm[9] */
+	{S5K6AAFX_REG_WR, 0x01A2/*0x01A2*//*0x015D*/}, /* TVAR_wbt_pOutdoorCcm[10] */
+	{S5K6AAFX_REG_WR, 0x0126/*0x0126*//*0x0082*/}, /* TVAR_wbt_pOutdoorCcm[11] */
+	{S5K6AAFX_REG_WR, 0xFFE0/*0xFFE0*//*0xFFCA*/}, /* TVAR_wbt_pOutdoorCcm[12] */
+	{S5K6AAFX_REG_WR, 0xFFBF/*0xFFBF*//*0xFFA2*/}, /* TVAR_wbt_pOutdoorCcm[13] */
+	{S5K6AAFX_REG_WR, 0x01E6/*0x01E6*//*0x016F*/}, /* TVAR_wbt_pOutdoorCcm[14] */
+	{S5K6AAFX_REG_WR, 0x0186/*0x0186*//*0x0171*/}, /* TVAR_wbt_pOutdoorCcm[15] */
+	{S5K6AAFX_REG_WR, 0xFF4B/*0xFF4B*//*0xFF35*/}, /* TVAR_wbt_pOutdoorCcm[16] */
+	{S5K6AAFX_REG_WR, 0x01B1/*0x01B1*//*0x013E*/}, /* TVAR_wbt_pOutdoorCcm[17] */
+	/* param_end - TVAR_wbt_pOutdoorCcm */
+
+	{S5K6AAFX_REG_W_ADDL, 0x06D4},
+	{S5K6AAFX_REG_WR, 0x2380},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_W_ADDL, 0x06CC},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_W_ADDL, 0x06E8},
+	{S5K6AAFX_REG_WR, 0x23A4},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23C8},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x23EC},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2410},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2434},
+	{S5K6AAFX_REG_WR, 0x7000},
+	{S5K6AAFX_REG_WR, 0x2458},
+	{S5K6AAFX_REG_WR, 0x7000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x06DA},
+	{S5K6AAFX_REG_WR, 0x00BF}, /* SARR_AwbCcmCord[0] */
+	{S5K6AAFX_REG_WR, 0x00E6}, /* SARR_AwbCcmCord[1] */
+	{S5K6AAFX_REG_WR, 0x00F2}, /* SARR_AwbCcmCord[2] */
+	{S5K6AAFX_REG_WR, 0x0143}, /* SARR_AwbCcmCord[3] */
+	{S5K6AAFX_REG_WR, 0x0178}, /* SARR_AwbCcmCord[4] */
+	{S5K6AAFX_REG_WR, 0x01A3}, /* SARR_AwbCcmCord[5] */
+
+	/* param_start - SARR_uNormBrInDoor */
+	{S5K6AAFX_REG_W_ADDL, 0x07E8},
+	{S5K6AAFX_REG_WR, 0x0016/*0x000A*/}, /* SARR_uNormBrInDoor[0] */
+	{S5K6AAFX_REG_WR, 0x0028/*0x0019*/}, /* SARR_uNormBrInDoor[1] */
+	{S5K6AAFX_REG_WR, 0x0096/*0x0096*/}, /* SARR_uNormBrInDoor[2] */
+	{S5K6AAFX_REG_WR, 0x01F4/*0x01F4*/}, /* SARR_uNormBrInDoor[3] */
+	{S5K6AAFX_REG_WR, 0x07D0/*0x07D0*/}, /* SARR_uNormBrInDoor[4] */
+	/* param_end - SARR_uNormBrInDoor */
+
+	/* param_start - afit_uNoiseIndInDoor */
+	{S5K6AAFX_REG_W_ADDL, 0x07D0},
+	{S5K6AAFX_REG_WR, 0x0030}, /* afit_uNoiseIndInDoor[0] */
+	{S5K6AAFX_REG_WR, 0x0046}, /* afit_uNoiseIndInDoor[1] */
+	{S5K6AAFX_REG_WR, 0x0088}, /* afit_uNoiseIndInDoor[2] */
+	{S5K6AAFX_REG_WR, 0x0205}, /* afit_uNoiseIndInDoor[3] */
+	{S5K6AAFX_REG_WR, 0x02BC}, /* afit_uNoiseIndInDoor[4] */
+	/* param_end - afit_uNoiseIndInDoor */
+
+	{S5K6AAFX_REG_W_ADDL, 0x07E6},
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_bUseNoiseInd */
+
+	/* param_start - TVAR_afit_pBaseVals */
+	{S5K6AAFX_REG_W_ADDL, 0x0828},
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[0]     70000828 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[1]     7000082A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[2]     7000082C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[3]     7000082E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[4]     70000830 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[5]     70000832 */
+	{S5K6AAFX_REG_WR, 0x0021}, /*TVAR_afit_pBaseVals[6]     70000834 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[7]     70000836 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[8]     70000838 */
+	{S5K6AAFX_REG_WR, 0x00FF}, /*TVAR_afit_pBaseVals[9]     7000083A */
+	{S5K6AAFX_REG_WR, 0x0129}, /*TVAR_afit_pBaseVals[10]    7000083C */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[11]    7000083E */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[12]    70000840 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[13]    70000842 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[14]    70000844 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[15]    70000846 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[16]    70000848 */
+	{S5K6AAFX_REG_WR, 0x0344}, /*TVAR_afit_pBaseVals[17]    7000084A */
+	{S5K6AAFX_REG_WR, 0x033A}, /*TVAR_afit_pBaseVals[18]    7000084C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[19]    7000084E */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[20]    70000850 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[21]    70000852 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[22]    70000854 */
+	{S5K6AAFX_REG_WR, 0x001E}, /*TVAR_afit_pBaseVals[23]    70000856 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[24]    70000858 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[25]    7000085A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[26]    7000085C */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[27]    7000085E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[28]    70000860 */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[29]    70000862 */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[30]    70000864 */
+	{S5K6AAFX_REG_WR, 0x0C0F}, /*TVAR_afit_pBaseVals[31]    70000866 */
+	{S5K6AAFX_REG_WR, 0x0C1F}, /*TVAR_afit_pBaseVals[32]    70000868 */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[33]    7000086A */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[34]    7000086C */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[35]    7000086E */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[36]    70000870 */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[37]    70000872 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[38]    70000874 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[39]    70000876 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[40]    70000878 */
+	{S5K6AAFX_REG_WR, 0x0E08}, /*TVAR_afit_pBaseVals[41]    7000087A */
+	{S5K6AAFX_REG_WR, 0x030A}, /*TVAR_afit_pBaseVals[42]    7000087C */
+	{S5K6AAFX_REG_WR, 0x0A03}, /*TVAR_afit_pBaseVals[43]    7000087E */
+	{S5K6AAFX_REG_WR, 0x0A11}, /*TVAR_afit_pBaseVals[44]    70000880 */
+	{S5K6AAFX_REG_WR, 0x000F}, /*TVAR_afit_pBaseVals[45]    70000882 */
+	{S5K6AAFX_REG_WR, 0x0500}, /*TVAR_afit_pBaseVals[46]    70000884 */
+	{S5K6AAFX_REG_WR, 0x0914}, /*TVAR_afit_pBaseVals[47]    70000886 */
+	{S5K6AAFX_REG_WR, 0x0012}, /*TVAR_afit_pBaseVals[48]    70000888 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[49]    7000088A */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[50]    7000088C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[51]    7000088E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[52]    70000890 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[53]    70000892 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[54]    70000894 */
+	{S5K6AAFX_REG_WR, 0x0A00}, /*TVAR_afit_pBaseVals[55]    70000896 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[56]    70000898 */
+	{S5K6AAFX_REG_WR, 0x014C}, /*TVAR_afit_pBaseVals[57]    7000089A */
+	{S5K6AAFX_REG_WR, 0x014D}, /*TVAR_afit_pBaseVals[58]    7000089C */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[59]    7000089E */
+	{S5K6AAFX_REG_WR, 0xA01c/*0x8020*/}, /*TVAR_afit_pBaseVals[60]    700008A0 */ //CKLIN_20100908 White level low brightness 2.5 pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[61]    700008A2 */
+	{S5K6AAFX_REG_WR, 0x0001/*0x000A*/}, /*TVAR_afit_pBaseVals[62]    700008A4 */ //CKLIN_20100908 Black Noise pass
+
+	{S5K6AAFX_REG_WR, 0xFFFE}, /*TVAR_afit_pBaseVals[63]    700008A6 */
+	{S5K6AAFX_REG_WR, 0xFFEC}, /*TVAR_afit_pBaseVals[64]    700008A8 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[65]    700008AA */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[66]    700008AC */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[67]    700008AE */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[68]    700008B0 */
+	{S5K6AAFX_REG_WR, 0x000C}, /*TVAR_afit_pBaseVals[69]    700008B2 */
+	{S5K6AAFX_REG_WR, 0x000E}, /*TVAR_afit_pBaseVals[70]    700008B4 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[71]    700008B6 */
+	{S5K6AAFX_REG_WR, 0x00FF}, /*TVAR_afit_pBaseVals[72]    700008B8 */
+	{S5K6AAFX_REG_WR, 0x0129}, /*TVAR_afit_pBaseVals[73]    700008BA */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[74]    700008BC */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[75]    700008BE */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[76]    700008C0 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[77]    700008C2 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[78]    700008C4 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[79]    700008C6 */
+	{S5K6AAFX_REG_WR, 0x0114}, /*TVAR_afit_pBaseVals[80]    700008C8 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[81]    700008CA */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[82]    700008CC */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[83]    700008CE */
+	{S5K6AAFX_REG_WR, 0x0018}, /*TVAR_afit_pBaseVals[84]    700008D0 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[85]    700008D2 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[86]    700008D4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[87]    700008D6 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[88]    700008D8 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[89]    700008DA */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[90]    700008DC */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[91]    700008DE */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[92]    700008E0 */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[93]    700008E2 */
+	{S5K6AAFX_REG_WR, 0x050F}, /*TVAR_afit_pBaseVals[94]    700008E4 */
+	{S5K6AAFX_REG_WR, 0x0A1F}, /*TVAR_afit_pBaseVals[95]    700008E6 */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[96]    700008E8 */
+	{S5K6AAFX_REG_WR, 0x0303}, /*TVAR_afit_pBaseVals[97]    700008EA */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[98]    700008EC */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[99]    700008EE */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[100]   700008F0 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[101]   700008F2 */
+	{S5K6AAFX_REG_WR, 0x020A}, /*TVAR_afit_pBaseVals[102]   700008F4 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[103]   700008F6 */
+	{S5K6AAFX_REG_WR, 0x0E08}, /*TVAR_afit_pBaseVals[104]   700008F8 */
+	{S5K6AAFX_REG_WR, 0x030A}, /*TVAR_afit_pBaseVals[105]   700008FA */
+	{S5K6AAFX_REG_WR, 0x1403}, /*TVAR_afit_pBaseVals[106]   700008FC */
+	{S5K6AAFX_REG_WR, 0x0A11}, /*TVAR_afit_pBaseVals[107]   700008FE */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[108]   70000900 */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[109]   70000902 */
+	{S5K6AAFX_REG_WR, 0x101E}, /*TVAR_afit_pBaseVals[110]   70000904 */
+	{S5K6AAFX_REG_WR, 0x101E}, /*TVAR_afit_pBaseVals[111]   70000906 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[112]   70000908 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[113]   7000090A */
+	{S5K6AAFX_REG_WR, 0x0400}, /*TVAR_afit_pBaseVals[114]   7000090C */
+	{S5K6AAFX_REG_WR, 0x0400}, /*TVAR_afit_pBaseVals[115]   7000090E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[116]   70000910 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[117]   70000912 */
+	{S5K6AAFX_REG_WR, 0x0A00}, /*TVAR_afit_pBaseVals[118]   70000914 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[119]   70000916 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[120]   70000918 */
+	{S5K6AAFX_REG_WR, 0x0151}, /*TVAR_afit_pBaseVals[121]   7000091A */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[122]   7000091C */
+	{S5K6AAFX_REG_WR, 0x981c}, /*TVAR_afit_pBaseVals[123]   7000091E */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[124]   70000920 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[125]   70000922 */
+
+	{S5K6AAFX_REG_WR, 0xFFFB}, /*TVAR_afit_pBaseVals[126]   70000924 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[127]   70000926 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[128]   70000928 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[129]   7000092A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[130]   7000092C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[131]   7000092E */
+	{S5K6AAFX_REG_WR, 0x0008}, /*TVAR_afit_pBaseVals[132]   70000930 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[133]   70000932 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[134]   70000934 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[135]   70000936 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[136]   70000938 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[137]   7000093A */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[138]   7000093C */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[139]   7000093E */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[140]   70000940 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[141]   70000942 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[142]   70000944 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[143]   70000946 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[144]   70000948 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[145]   7000094A */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[146]   7000094C */
+	{S5K6AAFX_REG_WR, 0x001C}, /*TVAR_afit_pBaseVals[147]   7000094E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[148]   70000950 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[149]   70000952 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[150]   70000954 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[151]   70000956 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[152]   70000958 */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[153]   7000095A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[154]   7000095C */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[155]   7000095E */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[156]   70000960 */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[157]   70000962 */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[158]   70000964 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[159]   70000966 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[160]   70000968 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[161]   7000096A */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[162]   7000096C */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[163]   7000096E */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[164]   70000970 */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[165]   70000972 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[166]   70000974 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[167]   70000976 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[168]   70000978 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[169]   7000097A */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[170]   7000097C */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[171]   7000097E */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[172]   70000980 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[173]   70000982 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[174]   70000984 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[175]   70000986 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[176]   70000988 */
+	{S5K6AAFX_REG_WR, 0x0403}, /*TVAR_afit_pBaseVals[177]   7000098A */
+	{S5K6AAFX_REG_WR, 0x0402}, /*TVAR_afit_pBaseVals[178]   7000098C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[179]   7000098E */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[180]   70000990 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[181]   70000992 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[182]   70000994 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[183]   70000996 */
+	{S5K6AAFX_REG_WR, 0x0170}, /*TVAR_afit_pBaseVals[184]   70000998 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[185]   7000099A */
+	{S5K6AAFX_REG_WR, 0x804c/*0x8030*/}, /*TVAR_afit_pBaseVals[186]   7000099C */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[187]   7000099E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[188]   700009A0 */
+
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[189]   700009A2 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[190]   700009A4 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[191]   700009A6 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[192]   700009A8 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[193]   700009AA */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[194]   700009AC */
+	{S5K6AAFX_REG_WR, 0x0008}, /*TVAR_afit_pBaseVals[195]   700009AE */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[196]   700009B0 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[197]   700009B2 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[198]   700009B4 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[199]   700009B6 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[200]   700009B8 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[201]   700009BA */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[202]   700009BC */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[203]   700009BE */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[204]   700009C0 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[205]   700009C2 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[206]   700009C4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[207]   700009C6 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[208]   700009C8 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[209]   700009CA */
+	{S5K6AAFX_REG_WR, 0x001C}, /*TVAR_afit_pBaseVals[210]   700009CC */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[211]   700009CE */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[212]   700009D0 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[213]   700009D2 */
+	{S5K6AAFX_REG_WR, 0x0028}, /*TVAR_afit_pBaseVals[214]   700009D4 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[215]   700009D6 */
+	{S5K6AAFX_REG_WR, 0x0010}, /*TVAR_afit_pBaseVals[216]   700009D8 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[217]   700009DA */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[218]   700009DC */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[219]   700009DE */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[220]   700009E0 */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[221]   700009E2 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[222]   700009E4 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[223]   700009E6 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[224]   700009E8 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[225]   700009EA */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[226]   700009EC */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[227]   700009EE */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[228]   700009F0 */
+	{S5K6AAFX_REG_WR, 0x0480}, /*TVAR_afit_pBaseVals[229]   700009F2 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[230]   700009F4 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[231]   700009F6 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[232]   700009F8 */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[233]   700009FA */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[234]   700009FC */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[235]   700009FE */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[236]   70000A00 */
+	{S5K6AAFX_REG_WR, 0x2028}, /*TVAR_afit_pBaseVals[237]   70000A02 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[238]   70000A04 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[239]   70000A06 */
+	{S5K6AAFX_REG_WR, 0x0403}, /*TVAR_afit_pBaseVals[240]   70000A08 */
+	{S5K6AAFX_REG_WR, 0x0402}, /*TVAR_afit_pBaseVals[241]   70000A0A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[242]   70000A0C */
+	{S5K6AAFX_REG_WR, 0x0203}, /*TVAR_afit_pBaseVals[243]   70000A0E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[244]   70000A10 */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[245]   70000A12 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[246]   70000A14 */
+	{S5K6AAFX_REG_WR, 0x0175}, /*TVAR_afit_pBaseVals[247]   70000A16 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[248]   70000A18 */
+	{S5K6AAFX_REG_WR, 0x8058/*0x8068*/}, /*TVAR_afit_pBaseVals[249]   70000A1A */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[250]   70000A1C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[251]   70000A1E */
+
+	{S5K6AAFX_REG_WR, 0x0032/*0x0000*/}, /*TVAR_afit_pBaseVals[252]   70000A20 */ //CKLIN_20100908 White level high brightness 286~2292 pass
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[253]   70000A22 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[254]   70000A24 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[255]   70000A26 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[256]   70000A28 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[257]   70000A2A */
+	{S5K6AAFX_REG_WR, 0x000E}, /*TVAR_afit_pBaseVals[258]   70000A2C */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[259]   70000A2E */
+	{S5K6AAFX_REG_WR, 0x0020}, /*TVAR_afit_pBaseVals[260]   70000A30 */
+	{S5K6AAFX_REG_WR, 0x0050}, /*TVAR_afit_pBaseVals[261]   70000A32 */
+	{S5K6AAFX_REG_WR, 0x0002}, /*TVAR_afit_pBaseVals[262]   70000A34 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[263]   70000A36 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[264]   70000A38 */
+	{S5K6AAFX_REG_WR, 0x000A}, /*TVAR_afit_pBaseVals[265]   70000A3A */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[266]   70000A3C */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[267]   70000A3E */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[268]   70000A40 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[269]   70000A42 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[270]   70000A44 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[271]   70000A46 */
+	{S5K6AAFX_REG_WR, 0x03FF}, /*TVAR_afit_pBaseVals[272]   70000A48 */
+	{S5K6AAFX_REG_WR, 0x0014}, /*TVAR_afit_pBaseVals[273]   70000A4A */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[274]   70000A4C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[275]   70000A4E */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[276]   70000A50 */
+	{S5K6AAFX_REG_WR, 0x0020}, /*TVAR_afit_pBaseVals[277]   70000A52 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[278]   70000A54 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[279]   70000A56 */
+	{S5K6AAFX_REG_WR, 0x0032}, /*TVAR_afit_pBaseVals[280]   70000A58 */
+	{S5K6AAFX_REG_WR, 0x0106}, /*TVAR_afit_pBaseVals[281]   70000A5A */
+	{S5K6AAFX_REG_WR, 0x006F}, /*TVAR_afit_pBaseVals[282]   70000A5C */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[283]   70000A5E */
+	{S5K6AAFX_REG_WR, 0x051E}, /*TVAR_afit_pBaseVals[284]   70000A60 */
+	{S5K6AAFX_REG_WR, 0x0101}, /*TVAR_afit_pBaseVals[285]   70000A62 */
+	{S5K6AAFX_REG_WR, 0x0202}, /*TVAR_afit_pBaseVals[286]   70000A64 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[287]   70000A66 */
+	{S5K6AAFX_REG_WR, 0x140A}, /*TVAR_afit_pBaseVals[288]   70000A68 */
+	{S5K6AAFX_REG_WR, 0x2828}, /*TVAR_afit_pBaseVals[289]   70000A6A */
+	{S5K6AAFX_REG_WR, 0x0606}, /*TVAR_afit_pBaseVals[290]   70000A6C */
+	{S5K6AAFX_REG_WR, 0x0205}, /*TVAR_afit_pBaseVals[291]   70000A6E */
+	{S5K6AAFX_REG_WR, 0x0880}, /*TVAR_afit_pBaseVals[292]   70000A70 */
+	{S5K6AAFX_REG_WR, 0x000F}, /*TVAR_afit_pBaseVals[293]   70000A72 */
+	{S5K6AAFX_REG_WR, 0x0005}, /*TVAR_afit_pBaseVals[294]   70000A74 */
+	{S5K6AAFX_REG_WR, 0x1903}, /*TVAR_afit_pBaseVals[295]   70000A76 */
+	{S5K6AAFX_REG_WR, 0x1911}, /*TVAR_afit_pBaseVals[296]   70000A78 */
+	{S5K6AAFX_REG_WR, 0x0A0F}, /*TVAR_afit_pBaseVals[297]   70000A7A */
+	{S5K6AAFX_REG_WR, 0x050A}, /*TVAR_afit_pBaseVals[298]   70000A7C */
+	{S5K6AAFX_REG_WR, 0x2020}, /*TVAR_afit_pBaseVals[299]   70000A7E */
+	{S5K6AAFX_REG_WR, 0x2020}, /*TVAR_afit_pBaseVals[300]   70000A80 */
+	{S5K6AAFX_REG_WR, 0x0A08}, /*TVAR_afit_pBaseVals[301]   70000A82 */
+	{S5K6AAFX_REG_WR, 0x0007}, /*TVAR_afit_pBaseVals[302]   70000A84 */
+	{S5K6AAFX_REG_WR, 0x0408}, /*TVAR_afit_pBaseVals[303]   70000A86 */
+	{S5K6AAFX_REG_WR, 0x0406}, /*TVAR_afit_pBaseVals[304]   70000A88 */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[305]   70000A8A */
+	{S5K6AAFX_REG_WR, 0x0608}, /*TVAR_afit_pBaseVals[306]   70000A8C */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[307]   70000A8E */
+	{S5K6AAFX_REG_WR, 0x0006}, /*TVAR_afit_pBaseVals[308]   70000A90 */
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[309]   70000A92 */
+	{S5K6AAFX_REG_WR, 0x0175}, /*TVAR_afit_pBaseVals[310]   70000A94 */
+	{S5K6AAFX_REG_WR, 0x0100}, /*TVAR_afit_pBaseVals[311]   70000A96 */
+	{S5K6AAFX_REG_WR, 0x7037/*0x7050*/}, /*TVAR_afit_pBaseVals[312]   70000A98 */ //CKLIN_20100908 Shading pass
+	{S5K6AAFX_REG_WR, 0x0180}, /*TVAR_afit_pBaseVals[313]   70000A9A */
+	{S5K6AAFX_REG_WR, 0x0000}, /*TVAR_afit_pBaseVals[314]   70000A9C */
+	/* param_end - TVAR_afit_pBaseVals */
+
+	/* param_start - afit_pConstBaseVals */
+	{S5K6AAFX_REG_WR, 0x00FF}, /* afit_pConstBaseVals[0] */
+	{S5K6AAFX_REG_WR, 0x00FF}, /* afit_pConstBaseVals[1] */
+	{S5K6AAFX_REG_WR, 0x0800}, /* afit_pConstBaseVals[2] */
+	{S5K6AAFX_REG_WR, 0x0600}, /* afit_pConstBaseVals[3] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[4] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[5] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[6] */
+	{S5K6AAFX_REG_WR, 0x0300}, /* afit_pConstBaseVals[7] */
+	{S5K6AAFX_REG_WR, 0x0002}, /* afit_pConstBaseVals[8] */
+	{S5K6AAFX_REG_WR, 0x0400}, /* afit_pConstBaseVals[9] */
+	{S5K6AAFX_REG_WR, 0x0106}, /* afit_pConstBaseVals[10] */
+	{S5K6AAFX_REG_WR, 0x0005}, /* afit_pConstBaseVals[11] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[12] */
+	{S5K6AAFX_REG_WR, 0x0703}, /* afit_pConstBaseVals[13] */
+	{S5K6AAFX_REG_WR, 0x0000}, /* afit_pConstBaseVals[14] */
+	{S5K6AAFX_REG_WR, 0xFFD6}, /* afit_pConstBaseVals[15] */
+	{S5K6AAFX_REG_WR, 0x53C1}, /* afit_pConstBaseVals[16] */
+	{S5K6AAFX_REG_WR, 0xE1FE}, /* afit_pConstBaseVals[17] */
+	{S5K6AAFX_REG_WR, 0x0001}, /* afit_pConstBaseVals[18] */
+	/* param_end - afit_pConstBaseVals */
+
+
+	{S5K6AAFX_REG_W_ADDL, 0x0488},
+	{S5K6AAFX_REG_WR, 0x416E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xA316},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x2360},
+	{S5K6AAFX_REG_WR, 0xF424},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0490},
+	{S5K6AAFX_REG_WR, 0x416E},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_WR, 0xA316},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x2364},
+	{S5K6AAFX_REG_WR, 0xF424},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	{S5K6AAFX_REG_W_ADDL, 0x0498},
+	{S5K6AAFX_REG_WR, 0x01E8},
+	{S5K6AAFX_REG_WR, 0x0310},
+	{S5K6AAFX_REG_W_ADDL, 0x2368},
+	{S5K6AAFX_REG_WR, 0x0580},
+	{S5K6AAFX_REG_W_ADDL, 0x049C},
+	{S5K6AAFX_REG_WR, 0x0160},
+
+	{S5K6AAFX_REG_W_ADDL, 0x235C},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_WR, 0x0090},
+
+	/* AE Weight */
+	{S5K6AAFX_REG_W_ADDL, 0x100E},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0201},
+	{S5K6AAFX_REG_WR, 0x0302},
+	{S5K6AAFX_REG_WR, 0x0203},
+	{S5K6AAFX_REG_WR, 0x0102},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0202},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+	{S5K6AAFX_REG_WR, 0x0101},
+};
+
+static const struct s5k6aafx_i2c_reg_conf const clk_init_tbl_cob[] = {
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0002}, /* PLL configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1770}, /* 1st system CLK 24MHz */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 24MHz output clock */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 2nd system CLK */
+	{S5K6AAFX_REG_WR, 0x1B58},
+	{S5K6AAFX_REG_WR, 0x36B0},
+	{S5K6AAFX_REG_WR, 0x36B0},
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 100ms */
+};
+
+
+static const struct s5k6aafx_i2c_reg_conf const mipi_clk_init_tbl_cob[] = {
+	/* MIPI Setting */
+	{S5K6AAFX_REG_W_ADDL, 0x03FA},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_EnMipiLanes */
+	{S5K6AAFX_REG_WR, 0x00C3}, /* REG_TC_OIF_EnPackets */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_CfgChanged */
+
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0000}, /* REG_TC_IPRM_UseNPviClocks */
+	{S5K6AAFX_REG_WR, 0x0002}, /* REG_TC_IPRM_UseNMipiClocks - 1 MIPI configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1B58}, /* 1st system CLK 24MHz *//*VGA*/
+	{S5K6AAFX_REG_WR, 0x30D4}, /* 48MHz output clock */
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x1B58}, /* 2nd system CLK *//*HD*/
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* delay 134ms */
+};
+
+
+static const struct s5k6aafx_i2c_reg_conf const clk_init_tb2_cob[] = {
+	/* clk Settings */
+	{S5K6AAFX_REG_W_ADDL, 0x01B8},
+	{S5K6AAFX_REG_WR, 0x5DC0}, /* 24MHz input clock */
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x01C6},
+	{S5K6AAFX_REG_WR, 0x0002}, /* PLL configurations */
+	{S5K6AAFX_REG_W_ADDL, 0x01CC},
+	{S5K6AAFX_REG_WR, 0x1770}, /* 1st system CLK 24MHz */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 24MHz output clock */
+	{S5K6AAFX_REG_WR, 0x1770}, /* 2nd system CLK */
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_W_ADDL, 0x01E0},
+	{S5K6AAFX_REG_WR, 0x0001},
+
+	/* delay 100ms */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_snap_conf_init_tbl_cob[] = {
+	/* PREVIEW CONFIGURATION 3 (VGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x02B4},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x02C0},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x02BA},
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMaxOut4KHzRate *//*VGA*/
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMinOut4KHzRate *//*VGA*/
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x0001}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x02C2},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x02C6},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0168},
+	{S5K6AAFX_REG_W_ADDL, 0x02D4},/* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003},/* 0x02D4 value */
+	{S5K6AAFX_REG_WR, 0x0003},/* 0x02D4 value */
+
+	/* PREVIEW CONFIGURATION 1 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0268},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x0274},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x026E},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0278},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0276},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x027A},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0288}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+
+	/* PREVIEW CONFIGURATION 0 (1280X720, YUV) */
+	/* HD Mode */
+	{S5K6AAFX_REG_W_ADDL, 0x0242},
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_WIDTH}, /* REG_0TC_PCFG_usWidth X=1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_HEIGHT}, /* REG_0TC_PCFG_usHeight Y=720 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x024E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0248},
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMaxOut4KHzRate *//*HD*/
+	{S5K6AAFX_REG_WR, 0x30D4}, /* REG_0TC_PCFG_usMinOut4KHzRate *//*HD*/
+	{S5K6AAFX_REG_WR, 0x0042}, /* REG_0TC_PCFG_PVIMask */
+	{S5K6AAFX_REG_W_ADDL, 0x0252},
+	{S5K6AAFX_REG_WR, 0x0002}, /* REG_0TC_PCFG_FrRateQualityType */
+	{S5K6AAFX_REG_W_ADDL, 0x0250},
+	{S5K6AAFX_REG_WR, 0x0002}, /* REG_0TC_PCFG_usFrTimeType */
+	{S5K6AAFX_REG_W_ADDL, 0x0254},
+	{S5K6AAFX_REG_WR, 0x029A}, /* REG_0TC_PCFG_usMaxFrTimeMsecMult10 */
+	{S5K6AAFX_REG_WR, 0x0000}, /* REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{S5K6AAFX_REG_W_ADDL, 0x0262}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0262 value */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0262 value */
+#if 0
+	/* Preview */
+	{S5K6AAFX_REG_W_ADDL, 0x03B6},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x03FA},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_EnMipiLanes */
+	{S5K6AAFX_REG_WR, 0x00C3}, /* REG_TC_OIF_EnPackets */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_OIF_CfgChanged */
+#endif
+
+	/* CAPTURE CONFIGURATION 0 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x030E},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT}, /* 1024 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x031A},
+	{S5K6AAFX_REG_WR, 0x0000}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0314},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x031E},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x031C},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x0320},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* CAPTURE CONFIGURATION 1 (1280X720, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0330},
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_720P_SIZE_HEIGHT}, /* 720 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x033C},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0336},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x30D4},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0340},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x033E},
+	{S5K6AAFX_REG_WR, 0x0002},
+	{S5K6AAFX_REG_W_ADDL, 0x0342},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0000},
+
+
+
+#if 0
+	{S5K6AAFX_REG_W_ADDL, 0x01FA},
+	/* REG_TC_GP_PrevReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_PrevReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_PrevInputWidthOfs */
+	{S5K6AAFX_REG_WR, (S5K6AAFX_FULL_SIZE_WIDTH-S5K6AAFX_ADJ_FULL_SIZE_WIDTH)/2},
+	/* REG_TC_GP_PrevInputHeightOfs */
+	{S5K6AAFX_REG_WR, (S5K6AAFX_FULL_SIZE_HEIGHT-S5K6AAFX_ADJ_FULL_SIZE_HEIGHT)/2},
+	/* REG_TC_GP_CapReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_CapReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_CapInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_PrevZoomReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_PrevZoomReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_PrevZoomReqInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_PrevZoomReqInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapZoomReqInputWidth */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	/* REG_TC_GP_CapZoomReqInputHeight */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	/* REG_TC_GP_CapZoomReqInputWidthOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapZoomReqInputHeightOfs */
+	{S5K6AAFX_REG_WR, 0x0000},
+
+	/* REG_TC_GEP_InputsChangeRequest */
+	{S5K6AAFX_REG_W_ADDL, 0x021A},
+	{S5K6AAFX_REG_WR, 0x0001},
+#endif
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_conf_HD_cob[] = {
+	{S5K6AAFX_REG_W_ADDH,0x7000},
+	{S5K6AAFX_REG_W_ADDL,0x021C},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_W_ADDL,0x0224},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_W_ADDL,0x020A},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_W_ADDL,0x01FA},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x0200},
+	{S5K6AAFX_REG_WR,0x0098},
+	{S5K6AAFX_REG_W_ADDL,0x021A},
+	{S5K6AAFX_REG_WR,0x0001},
+	{S5K6AAFX_REG_W_ADDL,0x0202},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0098},
+	{S5K6AAFX_REG_W_ADDL,0x0212},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_720P_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x021A},
+	{S5K6AAFX_REG_WR,0x0001},
+	/*delay 100ms*/
+};
+static const struct s5k6aafx_i2c_reg_conf const prev_conf_VGA_cob[] = {
+	/*VGA*/
+	/* REG_TC_GP_ActiveCapConfig-Select snapshot configuration_0 */
+	{S5K6AAFX_REG_W_ADDL, 0x0224},
+	{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x0226},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	/*********** APPLY PREVIEW CONFIGURATION & RUN PREVIEW ***********/
+	/* REG_TC_GP_ActivePrevConfig-Select preview configuration_3 */
+	{S5K6AAFX_REG_W_ADDL, 0x021C},
+	{S5K6AAFX_REG_WR, 0x0003},
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{S5K6AAFX_REG_W_ADDL, 0x0220},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_NewConfigSync-Update preview configuration */
+	{S5K6AAFX_REG_W_ADDL, 0x01F8},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_PrevConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x021E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL, 0x01F0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreview - Start preview */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreviewChanged */
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_mode_switch_conf_VGA_cob[] = {
+	/*VGA*/
+	/* REG_TC_GP_ActiveCapConfig-Select snapshot configuration_0 */
+	//{S5K6AAFX_REG_W_ADDL, 0x0224},
+	//{S5K6AAFX_REG_WR, 0x0000},
+	/* REG_TC_GP_CapConfigChanged */
+	//{S5K6AAFX_REG_W_ADDL, 0x0226},
+	//{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL,0x020A},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_W_ADDL,0x020C},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_W_ADDL,0x01FA},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_ADJ_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x0200},
+	{S5K6AAFX_REG_WR,0x0020},
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_WIDTH},/*0x0202*/
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_HEIGHT},/*0x0204*/
+	{S5K6AAFX_REG_WR,0x0000},/*0x0206*/
+	{S5K6AAFX_REG_WR,0x0000},/*0x0208*/
+	{S5K6AAFX_REG_W_ADDL,0x0212},
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR,S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_WR,0x0000},
+	{S5K6AAFX_REG_W_ADDL,0x021A},
+	{S5K6AAFX_REG_WR,0x0001},
+	/*delay 150ms*/
+};
+
+static const struct s5k6aafx_i2c_reg_conf const prev_snap_conf_init_tb2_cob[] = {
+	/* PREVIEW CONFIGURATION 3 (VGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x02B4},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_QTR_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x02C0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x02BA},
+	{S5K6AAFX_REG_WR, 0x1770},
+	{S5K6AAFX_REG_WR, 0x1700},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x02C4},
+	{S5K6AAFX_REG_WR, 0x0001}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0250},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x02C6},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x0168},
+	{S5K6AAFX_REG_W_ADDL, 0x02D4},/* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003},/* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0003},
+
+	/* PREVIEW CONFIGURATION 1 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x0268},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT},
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x0274},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x026E},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x0278},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x0276},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x027A},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x029A},
+	{S5K6AAFX_REG_W_ADDL, 0x0288}, /* flip and mirror */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+	{S5K6AAFX_REG_WR, 0x0003}, /* 0x0288 value */
+
+	/*********** APPLY PREVIEW CONFIGURATION & RUN PREVIEW ***********/
+	/* REG_TC_GP_ActivePrevConfig-Select preview configuration_3 */
+	{S5K6AAFX_REG_W_ADDL, 0x021C},
+	{S5K6AAFX_REG_WR, 0x0001},/*Preview: 3 : VGA 30fps. 1:Full size 15fps*/
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{S5K6AAFX_REG_W_ADDL, 0x0220},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_NewConfigSync-Update preview configuration */
+	{S5K6AAFX_REG_W_ADDL, 0x01F8},
+	{S5K6AAFX_REG_WR, 0x0001},
+	/* REG_TC_GP_PrevConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x021E},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+	{S5K6AAFX_REG_W_ADDL, 0x01F0},
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreview - Start preview */
+	{S5K6AAFX_REG_WR, 0x0001}, /* REG_TC_GP_EnablePreviewChanged */
+
+
+	/* CAPTURE CONFIGURATION 0 (SXGA, YUV) */
+	{S5K6AAFX_REG_W_ADDL, 0x030E},
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_WIDTH}, /* 1280 */
+	{S5K6AAFX_REG_WR, S5K6AAFX_FULL_SIZE_HEIGHT}, /* 1024 */
+	{S5K6AAFX_REG_WR, 0x0005}, /* YUV */
+	{S5K6AAFX_REG_W_ADDL, 0x031A},
+	{S5K6AAFX_REG_WR, 0x0001}, /* PLL config */
+	{S5K6AAFX_REG_W_ADDL, 0x0314},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x2EE0},
+	{S5K6AAFX_REG_WR, 0x0042},
+	{S5K6AAFX_REG_W_ADDL, 0x031E},
+	{S5K6AAFX_REG_WR, 0x0002}, /* 1b: Avg S.S 2b: SXGA */
+	{S5K6AAFX_REG_W_ADDL, 0x031C},
+	{S5K6AAFX_REG_WR, 0x0000},
+	{S5K6AAFX_REG_W_ADDL, 0x0320},
+	{S5K6AAFX_REG_WR, 0x0535},
+	{S5K6AAFX_REG_WR, 0x029A},
+
+	/* REG_TC_GP_CapConfigChanged */
+	{S5K6AAFX_REG_W_ADDL, 0x0226},
+	{S5K6AAFX_REG_WR, 0x0001}, /* Enable output after config change */
+};
+
+
+struct s5k6aafx_reg s5k6aafx_regs_cob = {
+	.reset_init = &reset_init_tbl_cob[0],
+	.reset_init_size = ARRAY_SIZE(reset_init_tbl_cob),
+	.TP_init = &TP_init_tbl_cob[0],
+	.TP_init_size = ARRAY_SIZE(TP_init_tbl_cob),
+	.analog_setting_init = &analog_setting_init_tbl_cob[0],
+	.analog_setting_init_size = ARRAY_SIZE(analog_setting_init_tbl_cob),
+	.register_init = &register_init_tbl_cob[0],
+	.register_init_size = ARRAY_SIZE(register_init_tbl_cob),
+	.mipi_clk_init = &mipi_clk_init_tbl_cob[0],
+	.mipi_clk_init_size = ARRAY_SIZE(mipi_clk_init_tbl_cob),
+	.clk_init = &clk_init_tbl_cob[0],
+	.clk_init_size = ARRAY_SIZE(clk_init_tbl_cob),
+	.prev_snap_conf_init = &prev_snap_conf_init_tbl_cob[0],
+	.prev_snap_conf_init_size = ARRAY_SIZE(prev_snap_conf_init_tbl_cob),
+	/* for full-size preview */
+	.clk_init_tb2 = &clk_init_tb2_cob[0],
+	.clk_init_tb2_size = ARRAY_SIZE(clk_init_tb2_cob),
+	.prev_snap_conf_init_tb2 = &prev_snap_conf_init_tb2_cob[0],
+	.prev_snap_conf_init_tb2_size = ARRAY_SIZE(prev_snap_conf_init_tb2_cob),
+	.prev_HD = &prev_conf_HD_cob[0],
+	.prev_HD_size = ARRAY_SIZE(prev_conf_HD_cob),
+	.prev_VGA = &prev_conf_VGA_cob[0],
+	.prev_VGA_size = ARRAY_SIZE(prev_conf_VGA_cob),
+	.prev_mode_switch_VGA = &prev_mode_switch_conf_VGA_cob[0],
+	.prev_mode_switch_VGA_size = ARRAY_SIZE(prev_mode_switch_conf_VGA_cob),
+};
-- 
1.8.5.1


